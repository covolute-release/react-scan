This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
bin/
  cli.js
scripts/
  bump-version.js
src/
  core/
    monitor/
      params/
        astro/
          component.ts
          index.ts
          Monitoring.astro
        next.ts
        react-router-v5.ts
        react-router-v6.ts
        remix.ts
        types.ts
        utils.ts
      constants.ts
      index.ts
      network.ts
      performance.ts
      types.ts
      utils.ts
    notifications/
      event-tracking.ts
      interaction-store.ts
      outline-overlay.ts
      performance-store.ts
      performance-utils.ts
      performance.ts
      types.ts
    fast-serialize.test.ts
    index.ts
    instrumentation.ts
    utils.ts
  html-to-image/
    apply-style.ts
    clone-node.ts
    clone-pseudos.ts
    dataurl.ts
    embed-images.ts
    embed-resources.ts
    embed-webfonts.ts
    index.ts
    mimes.ts
    types.ts
    util.ts
  new-outlines/
    canvas.ts
    index.ts
    offscreen-canvas.worker.ts
    types.ts
  react-component-name/
    __tests__/
      arrow-function.test.ts
      complex-patterns.test.ts
      function-declarations.test.ts
      general-cases.test.ts
      react-patterns.test.ts
      ts-patterns.test.ts
      utils.ts
    babel/
      get-descriptive-name.ts
      get-root-statement-path.ts
      index.ts
      is-componentish-name.ts
      is-nested-expression.ts
      is-path-valid.ts
      is-statement-top-level.ts
      path-references-import.ts
      unwrap.ts
    core/
      options.ts
    astro.ts
    esbuild.ts
    index.ts
    loader.ts
    rolldown.ts
    rollup.ts
    rspack.ts
    tsconfig.json
    vite.ts
    webpack.ts
  web/
    assets/
      css/
        styles.tailwind.css
    components/
      copy-to-clipboard/
        index.tsx
      icon/
        index.tsx
      slider/
        index.tsx
      sticky-section/
        index.tsx
      svg-sprite/
        index.tsx
      toggle/
        index.tsx
    hooks/
      use-delayed-value.ts
      use-merged-refs.ts
      use-virtual-list.ts
    utils/
      preact/
        constant.ts
        use-constant.ts
        use-lazy-ref.ts
      constants.ts
      create-store.ts
      geiger.ts
      helpers.ts
      lerp.ts
      log.ts
      lru.ts
      outline.ts
      pin.ts
    views/
      inspector/
        components-tree/
          index.tsx
          state.ts
        overlay/
          index.tsx
        timeline/
          index.tsx
          utils.ts
        whats-changed/
          use-change-store.ts
        diff-value.tsx
        flash-overlay.ts
        header.tsx
        index.tsx
        logging.ts
        properties.tsx
        states.ts
        utils.ts
        what-changed.tsx
      notifications/
        collapsed-event.tsx
        data.ts
        details-routes.tsx
        icons.tsx
        notification-header.tsx
        notification-tabs.tsx
        notifications.tsx
        optimize.tsx
        other-visualization.tsx
        popover.tsx
        render-bar-chart.tsx
        render-explanation.tsx
        slowdown-history.tsx
      settings/
        header.tsx
      toolbar/
        index.tsx
      index.tsx
    widget/
      fps-meter.tsx
      header.tsx
      helpers.ts
      index.tsx
      resize-handle.tsx
      types.ts
    constants.ts
    state.ts
    toolbar.tsx
  auto.ts
  cli.mts
  index.ts
  install-hook.ts
  types.d.ts
  types.ts
  worker-shim.ts
.gitignore
auto.d.ts
global.d.ts
package.json
postcss.config.mjs
postcss.rem2px.mjs
README.md
tailwind.config.mjs
tsconfig.json
tsup.config.ts
vite.config.mts
worker-plugin.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="bin/cli.js">
#! /usr/bin/env node
require('../dist/cli');
</file>

<file path="scripts/bump-version.js">
import { execSync } from 'node:child_process';
import fs from 'node:fs';
import path from 'node:path';

// Read the current version from scan package.json
const scanPackagePath = path.join(__dirname, '../package.json');
const scanPackage = JSON.parse(fs.readFileSync(scanPackagePath, 'utf8'));

// Bump patch version
const version = scanPackage.version.split('.');
version[2] = Number.parseInt(version[2]) + 1;
const newVersion = version.join('.');

// Update the version in package.json
scanPackage.version = newVersion;

// Write back to package.json
fs.writeFileSync(scanPackagePath, `${JSON.stringify(scanPackage, null, 2)}\n`);

// Get the tar file path
const tarFileName = `react-scan-${newVersion}.tgz`;
const tarFilePath = path.join(__dirname, '..', tarFileName);

// Copy to clipboard
execSync(`echo "${tarFilePath}" | pbcopy`);

// biome-ignore lint/suspicious/noConsole: Intended debug output
console.log(`Bumped version to ${newVersion}`);
// biome-ignore lint/suspicious/noConsole: Intended debug output
console.log(`Tar file path copied to clipboard: ${tarFilePath}`);
</file>

<file path="src/core/monitor/params/astro/component.ts">
import { createElement } from 'react';
import {
  Monitoring as BaseMonitoring,
  type MonitoringWithoutRouteProps,
} from '../..';
import { computeRoute } from '../utils';

export function AstroMonitor(
  props: {
    path: string;
    params: Record<string, string | undefined>;
  } & MonitoringWithoutRouteProps,
) {
  const path = props.path;
  const route = computeRoute(path, props.params);

  return createElement(BaseMonitoring, {
    ...props,
    route,
    path,
  });
}
</file>

<file path="src/core/monitor/params/astro/index.ts">
// This file will not be packaged

export { default as Monitoring } from './Monitoring.astro';
</file>

<file path="src/core/monitor/params/astro/Monitoring.astro">
---
import type { MonitoringWithoutRouteProps } from '../..';
// @ts-ignore This file will not be packaged, so the file to be imported should be a .mjs file.
import { AstroMonitor } from './component.mjs';

type Props = MonitoringWithoutRouteProps;

const path = Astro.url.pathname;
const params = Astro.params;
---

<AstroMonitor path={path} params={params} {...Astro.props} client:only="react" />
</file>

<file path="src/core/monitor/params/next.ts">
'use client';

import { useParams, usePathname, useSearchParams } from 'next/navigation.js';
import { createElement, Suspense } from 'react';
import {
  Monitoring as BaseMonitoring,
  type MonitoringWithoutRouteProps,
} from '..';
import { computeRoute } from './utils';

/**
 * This hook works in both Next.js Pages and App Router:
 * - App Router: Uses the new useParams() hook directly
 * - Pages Router: useParams() returns empty object, falls back to searchParams
 * This fallback behavior ensures compatibility across both routing systems
 */
const useRoute = (): {
  route: string | null;
  path: string;
} => {
  const params = useParams();
  const searchParams = useSearchParams();
  const path = usePathname();

  // Until we have route parameters, we don't compute the route
  if (!params) {
    return { route: null, path };
  }
  // in Next.js@13, useParams() could return an empty object for pages router, and we default to searchParams.
  const finalParams = Object.keys(params).length
    ? (params as Record<string, string | Array<string>>)
    : Object.fromEntries(searchParams.entries());
  return { route: computeRoute(path, finalParams), path };
};
export function MonitoringInner(props: MonitoringWithoutRouteProps) {
  const { route, path } = useRoute();

  // we need to fix build so this doesn't get compiled to preact jsx
  return createElement(BaseMonitoring, {
    ...props,
    route,
    path,
  });
}

/**
 * The double 'use client' directive pattern is intentional:
 * 1. Top-level directive marks the entire module as client-side
 * 2. IIFE-wrapped component with its own directive ensures:
 *    - Component is properly tree-shaken (via @__PURE__)
 *    - Component maintains client context when code-split
 *    - Execution scope is preserved
 *
 * This pattern is particularly important for Next.js's module
 * system and its handling of Server/Client Components.
 */
export const Monitoring = /* @__PURE__ */ (() => {
  'use client';
  return function Monitoring(props: MonitoringWithoutRouteProps) {
    return createElement(
      Suspense,
      { fallback: null },
      createElement(MonitoringInner, props),
    );
  };
})();
</file>

<file path="src/core/monitor/params/react-router-v5.ts">
import { createElement } from 'react';
import { useRouteMatch, useLocation } from 'react-router';
import { Monitoring as BaseMonitoring, type MonitoringWithoutRouteProps} from '..';
import { computeRoute } from './utils';
import type { RouteInfo } from './types';

const useRoute = (): RouteInfo => {
  const match = useRouteMatch();
  const { pathname } = useLocation();
  const params = match?.params || {};

  if (!params) {
    return { route: null, path: pathname };
  }

  return {
    route: computeRoute(pathname, params),
    path: pathname,
  };
};

function ReactRouterV5Monitor(props: MonitoringWithoutRouteProps) {
  const { route, path } = useRoute();
  return createElement(BaseMonitoring, {
    ...props,
    route,
    path,
  });
}

export { ReactRouterV5Monitor as Monitoring };
</file>

<file path="src/core/monitor/params/react-router-v6.ts">
import { createElement } from 'react';
import { useParams, useLocation } from 'react-router';
import { Monitoring as BaseMonitoring, type MonitoringWithoutRouteProps } from '..';
import { computeReactRouterRoute } from './utils';
import type { RouteInfo } from './types';

const useRoute = (): RouteInfo => {
  const params = useParams();
  const { pathname } = useLocation();

  if (!params || Object.keys(params).length === 0) {
    return { route: null, path: pathname };
  }

  const validParams = Object.fromEntries(
    Object.entries(params).filter(([_, v]) => v !== undefined),
  ) as Record<string, string | Array<string>>;

  return {
    route: computeReactRouterRoute(pathname, validParams),
    path: pathname,
  };
};

function ReactRouterMonitor(props: MonitoringWithoutRouteProps) {
  const { route, path } = useRoute();
  return createElement(BaseMonitoring, {
    ...props,
    route,
    path,
  });
}

export { ReactRouterMonitor as Monitoring };
</file>

<file path="src/core/monitor/params/remix.ts">
import { createElement } from 'react';
import { useParams, useLocation } from '@remix-run/react';
import { Monitoring as BaseMonitoring, type MonitoringWithoutRouteProps} from '..';
import { computeReactRouterRoute } from './utils';
import type { RouteInfo } from './types';

const useRoute = (): RouteInfo => {
  const params = useParams();
  const { pathname } = useLocation();

  if (!params || Object.keys(params).length === 0) {
    return { route: null, path: pathname };
  }

  const validParams = params as Record<string, string>;

  return {
    route: computeReactRouterRoute(pathname, validParams),
    path: pathname,
  };
};

function RemixMonitor(props: MonitoringWithoutRouteProps) {
  const { route, path } = useRoute();
  return createElement(BaseMonitoring, {
    ...props,
    route,
    path,
  });
}

export { RemixMonitor as Monitoring };
</file>

<file path="src/core/monitor/params/types.ts">
export interface RouteInfo {
  route: string | null;
  path: string;
}
</file>

<file path="src/core/monitor/params/utils.ts">
// adapted from vercel analytics https://github.dev/vercel/analytics
interface DynamicSegmentFormatter {
  param: (key: string) => string;
  catchAll: (key: string) => string;
}

function computeRouteWithFormatter(
  pathname: string | null,
  pathParams: Record<string, string | Array<string>> | null,
  formatter: DynamicSegmentFormatter,
): string | null {
  if (!pathname || !pathParams) {
    return pathname;
  }

  let result = pathname;
  try {
    const entries = Object.entries(pathParams);
    // simple keys must be handled first
    for (const [key, value] of entries) {
      if (!Array.isArray(value)) {
        const matcher = turnValueToRegExp(value);
        if (matcher.test(result)) {
          result = result.replace(matcher, formatter.param(key));
        }
      }
    }
    // array values next
    for (const [key, value] of entries) {
      if (Array.isArray(value)) {
        const matcher = turnValueToRegExp(value.join('/'));
        if (matcher.test(result)) {
          result = result.replace(matcher, formatter.catchAll(key));
        }
      }
    }
    return result;
  } catch {
    return pathname;
  }
}

// Next.js style routes (default)
export function computeRoute(
  pathname: string | null,
  pathParams: Record<string, string | Array<string>> | null,
): string | null {
  return computeRouteWithFormatter(pathname, pathParams, {
    param: (key) => `/[${key}]`,
    catchAll: (key) => `/[...${key}]`,
  });
}

export function computeReactRouterRoute(
  pathname: string | null,
  pathParams: Record<string, string | Array<string>> | null,
): string | null {
  return computeRouteWithFormatter(pathname, pathParams, {
    param: (key) => `/:${key}`,
    catchAll: (key) => `/*${key}`,
  });
}

export function turnValueToRegExp(value: string): RegExp {
  return new RegExp(`/${escapeRegExp(value)}(?=[/?#]|$)`);
}

export function escapeRegExp(string: string): string {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
</file>

<file path="src/core/monitor/constants.ts">
/**
 * We do prototype caching for highly performant code, do not put browser specific code here without a guard.
 *
 * _{global} is also a hack that reduces the size of the bundle
 *
 * Examples:
 * @see https://github.com/ged-odoo/blockdom/blob/5849f0887ff8dc7f3f173f870ed850a89946fcfd/src/block_compiler.ts#L9
 * @see https://github.com/localvoid/ivi/blob/bd5bbe8c6b39a7be1051c16ea0a07b3df9a178bd/packages/ivi/src/client/core.ts#L13
 */

/**
 * Do not destructure exports or import React from "react" here.
 * From empirical ad-hoc testing, this breaks in certain scenarios.
 */
import * as React from 'react';
import { IS_CLIENT } from '~web/utils/constants';

/**
 * useRef will be undefined in "use server"
 *
 * @see https://nextjs.org/docs/messages/react-client-hook-in-server-component
 */
const isRSC = () => !React.useRef;
export const isSSR = () => !IS_CLIENT || isRSC();

interface WindowWithCypress extends Window {
  Cypress?: unknown;
}

export const isTest =
  (IS_CLIENT &&
    /**
     * @see https://docs.cypress.io/faq/questions/using-cypress-faq#Is-there-any-way-to-detect-if-my-app-is-running-under-Cypress
     */
    ((window as WindowWithCypress).Cypress ||
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/webdriver
       */
      navigator.webdriver)) ||
  /**
   * @see https://stackoverflow.com/a/60491322
   */
  // @ts-expect-error jest is a global in test
  typeof jest !== 'undefined';

export const VERSION = null; // todo
export const PAYLOAD_VERSION = null; // todo

export const MAX_QUEUE_SIZE = 300;
export const FLUSH_TIMEOUT = isTest
  ? 100 // Make sure there is no data loss in tests
  : process.env.NODE_ENV === 'production'
    ? 5000
    : 1000;
export const SESSION_EXPIRE_TIMEOUT = 300000; // 5 minutes
export const GZIP_MIN_LEN = 1000;
export const GZIP_MAX_LEN = 60000; // 1 minute
export const MAX_PENDING_REQUESTS = 15;
</file>

<file path="src/core/monitor/index.ts">
'use client';
import {
  type Fiber,
  getDisplayName,
  getTimings,
  isCompositeFiber,
} from 'bippy';
import { type FC, useEffect } from 'react';
import { IS_CLIENT } from '~web/utils/constants';
import {
  type MonitoringOptions,
  ReactScanInternals,
  Store,
  setOptions,
} from '..';
import { type Render, createInstrumentation } from '../instrumentation';
import { updateFiberRenderData } from '../utils';
import { flush } from './network';
import { computeRoute } from './params/utils';
import { initPerformanceMonitoring } from './performance';
import { getSession } from './utils';

// max retries before the set of components do not get reported (avoid memory leaks of the set of fibers stored on the component aggregation)
const MAX_RETRIES_BEFORE_COMPONENT_GC = 7;

export interface MonitoringProps {
  url?: string;
  apiKey: string;

  // For Session and Interaction
  path?: string | null; // pathname (i.e /foo/2/bar/3)
  route?: string | null; // computed from path and params (i.e /foo/:fooId/bar/:barId)

  // Only used / should be provided to compute the route when using Monitoring without supported framework
  params?: Record<string, string>;

  // Tracking regressions across commits and branches
  commit?: string | null;
  branch?: string | null;
}

export type MonitoringWithoutRouteProps = Omit<
  MonitoringProps,
  'route' | 'path'
>;

const DEFAULT_URL = 'https://monitoring.react-scan.com/api/v1/ingest';

function noopCatch() {
  return null;
}

export const Monitoring: FC<MonitoringProps> = ({
  url,
  apiKey,
  params,
  path = null, // path passed down would be reactive
  route = null,
  commit = null,
  branch = null,
}) => {
  if (!apiKey)
    throw new Error('Please provide a valid API key for React Scan monitoring');
  url ??= DEFAULT_URL;

  Store.monitor.value ??= {
    pendingRequests: 0,
    interactions: [],
    session: getSession({ commit, branch }).catch(noopCatch),
    url,
    apiKey,
    route,
    commit,
    branch,
  };

  // When using Monitoring without framework, we need to compute the route from the path and params
  if (!route && path && params) {
    Store.monitor.value.route = computeRoute(path, params);
  } else if (IS_CLIENT) {
    Store.monitor.value.route =
      route ?? path ?? new URL(window.location.toString()).pathname; // this is inaccurate on vanilla react if the path is not provided but used for session route
  }

  useEffect(() => {
    scanMonitoring({ enabled: true });
    return initPerformanceMonitoring();
  }, []);

  return null;
};

export const scanMonitoring = (options: MonitoringOptions) => {
  setOptions(options);
  startMonitoring();
};

let flushInterval: ReturnType<typeof setInterval>;

export const startMonitoring = (): void => {
  if (!Store.monitor.value) {
    if (process.env.NODE_ENV !== 'production') {
      throw new Error(
        'Invariant: startMonitoring can never be called when monitoring is not initialized',
      );
    }
  }

  if (flushInterval) {
    clearInterval(flushInterval);
  }

  flushInterval = setInterval(() => {
    try {
      void flush();
    } catch {
      /* */
    }
  }, 2000);

  if (!window.__REACT_SCAN_EXTENSION__) {
    globalThis.__REACT_SCAN__ = {
      ReactScanInternals,
    };
  }

  const instrumentation = createInstrumentation('monitoring', {
    onCommitStart() {
      // ReactScanInternals.options.value.onCommitStart?.();
    },
    onError() {
      // todo: report to server?
    },
    isValidFiber() {
      return true;
    },
    onRender(fiber, renders) {
      updateFiberRenderData(fiber, renders);

      if (isCompositeFiber(fiber)) {
        aggregateComponentRenderToInteraction(fiber, renders);
      }
      // ReactScanInternals.options.value.onRender?.(fiber, renders);
    },
    onCommitFinish() {
      // ReactScanInternals.options.value.onCommitFinish?.();
    },
    onPostCommitFiberRoot() {
      // ...
    },
    trackChanges: false,
    forceAlwaysTrackRenders: true,
  });

  ReactScanInternals.instrumentation = instrumentation;
};

const aggregateComponentRenderToInteraction = (
  fiber: Fiber,
  renders: Array<Render>,
): void => {
  const monitor = Store.monitor.value;
  if (!monitor || !monitor.interactions || monitor.interactions.length === 0)
    return;
  const lastInteraction = monitor.interactions.at(-1); // Associate component render with last interaction
  if (!lastInteraction) return;

  const displayName = getDisplayName(fiber.type);
  if (!displayName) return; // TODO(nisarg): it may be useful to somehow report the first ancestor with a display name instead of completely ignoring

  let component = lastInteraction.components.get(displayName); // TODO(nisarg): Same names are grouped together which is wrong.

  if (!component) {
    component = {
      fibers: new Set(),
      name: displayName,
      renders: 0,
      retiresAllowed: MAX_RETRIES_BEFORE_COMPONENT_GC,
      uniqueInteractionId: lastInteraction.uniqueInteractionId,
    };
    lastInteraction.components.set(displayName, component);
  }

  if (fiber.alternate && !component.fibers.has(fiber.alternate)) {
    // then the alternate tree fiber exists in the weakset, don't double count the instance
    component.fibers.add(fiber.alternate);
  }

  const rendersCount = renders.length;
  component.renders += rendersCount;

  // We leave the times undefined to differentiate between a 0ms render and a non-profiled render.
  if (fiber.actualDuration) {
    const { selfTime, totalTime } = getTimings(fiber);
    if (!component.totalTime) component.totalTime = 0;
    if (!component.selfTime) component.selfTime = 0;
    component.totalTime += totalTime;
    component.selfTime += selfTime;
  }
};
</file>

<file path="src/core/monitor/network.ts">
import { Store } from '..';
import { GZIP_MAX_LEN, GZIP_MIN_LEN, MAX_PENDING_REQUESTS } from './constants';
import type {
  Component,
  IngestRequest,
  Interaction,
  InternalInteraction,
} from './types';
import { getSession } from './utils';

const INTERACTION_TIME_TILL_COMPLETED = 4000;

const truncate = (value: number, decimalPlaces = 4) =>
  Number(value.toFixed(decimalPlaces));

export const flush = async (): Promise<void> => {
  const monitor = Store.monitor.value;
  if (
    !monitor ||
    !navigator.onLine ||
    !monitor.url ||
    !monitor.interactions.length
  ) {
    return;
  }
  const now = performance.now();
  // We might trigger flush before the interaction is completed,
  // so we need to split them into pending and completed by an arbitrary time.
  const pendingInteractions = new Array<InternalInteraction>();
  const completedInteractions = new Array<InternalInteraction>();

  const interactions = monitor.interactions;
  for (let i = 0; i < interactions.length; i++) {
    const interaction = interactions[i];
    const timeSinceStart = now - interaction.performanceEntry.startTime;
    if (timeSinceStart <= 30000) {
      // Skip interactions older than 30 seconds to prevent memory leaks
      if (timeSinceStart <= INTERACTION_TIME_TILL_COMPLETED) {
        pendingInteractions.push(interaction);
      } else {
        completedInteractions.push(interaction);
      }
    }
  }

  if (!completedInteractions.length)
    // nothing to flush
    return;

  // idempotent
  const session = await getSession({
    commit: monitor.commit,
    branch: monitor.branch,
  }).catch(() => null);

  if (!session) return;

  const aggregatedComponents = new Array<Component>();
  const aggregatedInteractions = new Array<Interaction>();
  for (let i = 0; i < completedInteractions.length; i++) {
    const interaction = completedInteractions[i];

    // META INFORMATION IS FOR DEBUGGING THIS MUST BE REMOVED SOON
    const {
      duration,
      entries,
      id,
      inputDelay,
      latency,
      presentationDelay,
      processingDuration,
      processingEnd,
      processingStart,
      referrer,
      startTime,
      timeOrigin,
      timeSinceTabInactive,
      timestamp,
      type,
      visibilityState,
    } = interaction.performanceEntry;
    aggregatedInteractions.push({
      id: i,
      path: interaction.componentPath,
      name: interaction.componentName,
      time: truncate(duration),
      timestamp,
      type,
      // fixme: we can aggregate around url|route|commit|branch better to compress payload
      url: interaction.url,
      route: interaction.route,
      commit: interaction.commit,
      branch: interaction.branch,
      uniqueInteractionId: interaction.uniqueInteractionId,
      meta: {
        performanceEntry: {
          id,
          inputDelay: truncate(inputDelay),
          latency: truncate(latency),
          presentationDelay: truncate(presentationDelay),
          processingDuration: truncate(processingDuration),
          processingEnd,
          processingStart,
          referrer,
          startTime,
          timeOrigin,
          timeSinceTabInactive,
          visibilityState,
          duration: truncate(duration),
          entries: entries.map((entry) => {
            const {
              duration,
              entryType,
              interactionId,
              name,
              processingEnd,
              processingStart,
              startTime,
            } = entry;
            return {
              duration: truncate(duration),
              entryType,
              interactionId,
              name,
              processingEnd,
              processingStart,
              startTime,
            };
          }),
        },
      },
    });

    const components = Array.from(interaction.components.entries());
    for (let j = 0; j < components.length; j++) {
      const [name, component] = components[j];
      aggregatedComponents.push({
        name,
        instances: component.fibers.size,
        interactionId: i,
        renders: component.renders,
        selfTime:
          typeof component.selfTime === 'number'
            ? truncate(component.selfTime)
            : component.selfTime,
        totalTime:
          typeof component.totalTime === 'number'
            ? truncate(component.totalTime)
            : component.totalTime,
      });
    }
  }

  const payload: IngestRequest = {
    interactions: aggregatedInteractions,
    components: aggregatedComponents,
    session: {
      ...session,
      url: window.location.toString(),
      route: monitor.route, // this might be inaccurate but used to caculate which paths all the unique sessions are coming from without having to join on the interactions table (expensive)
      wifi: session.wifi ?? '',
    },
  };

  monitor.pendingRequests++;
  monitor.interactions = pendingInteractions;
  try {
    transport(monitor.url, payload)
      .then(() => {
        monitor.pendingRequests--;
        // there may still be renders associated with these interaction, so don't flush just yet
      })
      .catch(async () => {
        // we let the next interval handle retrying, instead of explicitly retrying
        monitor.interactions = monitor.interactions.concat(
          completedInteractions,
        );
      });
  } catch {
    /* */
  }

  // Keep only recent interactions
  monitor.interactions = pendingInteractions;
};

const CONTENT_TYPE = 'application/json';
const supportsCompression = typeof CompressionStream === 'function';

export const compress = async (payload: string): Promise<ArrayBuffer> => {
  const stream = new Blob([payload], { type: CONTENT_TYPE })
    .stream()
    .pipeThrough(new CompressionStream('gzip'));
  return new Response(stream).arrayBuffer();
};

/**
 * Modified from @palette.dev/browser:
 *
 * @see https://gist.github.com/aidenybai/473689493f2d5d01bbc52e2da5950b45#file-palette-dev-browser-dist-palette-dev-mjs-L365
 */
interface RequestHeaders {
  'Content-Type': string;
  'Content-Encoding'?: string;
  'x-api-key'?: string;
}

export const transport = async (
  initialUrl: string,
  payload: IngestRequest,
): Promise<{ ok: boolean }> => {
  const fail = { ok: false };
  const json = JSON.stringify(payload);
  // gzip may not be worth it for small payloads,
  // only use it if the payload is large enough
  const shouldCompress = json.length > GZIP_MIN_LEN;
  const body =
    shouldCompress && supportsCompression ? await compress(json) : json;

  if (!navigator.onLine) return fail;
  const headerValues: RequestHeaders = {
    'Content-Type': CONTENT_TYPE,
    'Content-Encoding': shouldCompress ? 'gzip' : undefined,
    'x-api-key': Store.monitor.value?.apiKey ?? undefined,
  };
  let url = initialUrl;
  if (shouldCompress) url += '?z=1';
  const size = typeof body === 'string' ? body.length : body.byteLength;

  return fetch(url, {
    body,
    method: 'POST',
    referrerPolicy: 'origin',
    /**
     * Outgoing requests are usually cancelled when navigating to a different page, causing a "TypeError: Failed to
     * fetch" error and sending a "network_error" client-outcome - in Chrome, the request status shows "(cancelled)".
     * The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're
     * frequently sending events right before the user is switching pages (e.g., when finishing navigation transactions).
     *
     * This is the modern alternative to the navigator.sendBeacon API.
     * @see https://javascript.info/fetch-api#keepalive
     *
     * Gotchas:
     * - `keepalive` isn't supported by Firefox
     * - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch):
     *   If the sum of contentLength and inflightKeepaliveBytes is greater than 64 kibibytes, then return a network error.
     *   We will therefore only activate the flag when we're below that limit.
     * - There is also a limit of requests that can be open at the same time, so we also limit this to 15.
     *
     * @see https://github.com/getsentry/sentry-javascript/pull/7553
     */
    keepalive:
      GZIP_MAX_LEN > size &&
      MAX_PENDING_REQUESTS > (Store.monitor.value?.pendingRequests ?? 0),
    priority: 'low',
    // mode: 'no-cors',
    headers: headerValues as unknown as HeadersInit,
  });
};
</file>

<file path="src/core/monitor/performance.ts">
import { type Fiber, getDisplayName } from 'bippy';
import { getCompositeComponentFromElement } from '~web/views/inspector/utils';
import { Store } from '..';
import type {
  PerformanceInteraction,
  PerformanceInteractionEntry,
} from './types';

interface PathFilters {
  skipProviders: boolean;
  skipHocs: boolean;
  skipContainers: boolean;
  skipMinified: boolean;
  skipUtilities: boolean;
  skipBoundaries: boolean;
}

const DEFAULT_FILTERS: PathFilters = {
  skipProviders: true,
  skipHocs: true,
  skipContainers: true,
  skipMinified: true,
  skipUtilities: true,
  skipBoundaries: true,
};

const FILTER_PATTERNS = {
  providers: [/Provider$/, /^Provider$/, /^Context$/],
  hocs: [/^with[A-Z]/, /^forward(?:Ref)?$/i, /^Forward(?:Ref)?\(/],
  containers: [/^(?:App)?Container$/, /^Root$/, /^ReactDev/],
  utilities: [
    /^Fragment$/,
    /^Suspense$/,
    /^ErrorBoundary$/,
    /^Portal$/,
    /^Consumer$/,
    /^Layout$/,
    /^Router/,
    /^Hydration/,
  ],
  boundaries: [/^Boundary$/, /Boundary$/, /^Provider$/, /Provider$/],
};

const shouldIncludeInPath = (
  name: string,
  filters: PathFilters = DEFAULT_FILTERS,
): boolean => {
  const patternsToCheck: Array<RegExp> = [];
  if (filters.skipProviders) patternsToCheck.push(...FILTER_PATTERNS.providers);
  if (filters.skipHocs) patternsToCheck.push(...FILTER_PATTERNS.hocs);
  if (filters.skipContainers)
    patternsToCheck.push(...FILTER_PATTERNS.containers);
  if (filters.skipUtilities) patternsToCheck.push(...FILTER_PATTERNS.utilities);
  if (filters.skipBoundaries)
    patternsToCheck.push(...FILTER_PATTERNS.boundaries);
  return !patternsToCheck.some((pattern) => pattern.test(name));
};

const minifiedPatterns = [
  /^[a-z]$/, // Single lowercase letter
  /^[a-z][0-9]$/, // Lowercase letter followed by number
  /^_+$/, // Just underscores
  /^[A-Za-z][_$]$/, // Letter followed by underscore or dollar
  /^[a-z]{1,2}$/, // 1-2 lowercase letters
];

const isMinified = (name: string): boolean => {
  for (let i = 0; i < minifiedPatterns.length; i++) {
    if (minifiedPatterns[i].test(name)) return true;
  }

  const hasNoVowels = !/[aeiou]/i.test(name);
  const hasMostlyNumbers = (name.match(/\d/g)?.length ?? 0) > name.length / 2;
  const isSingleWordLowerCase = /^[a-z]+$/.test(name);
  const hasRandomLookingChars = /[$_]{2,}/.test(name);

  // If more than 2 of the following are true, we consider the name minified
  return (
    Number(hasNoVowels) +
      Number(hasMostlyNumbers) +
      Number(isSingleWordLowerCase) +
      Number(hasRandomLookingChars) >=
    2
  );
};

export const getInteractionPath = (
  initialFiber: Fiber | null,
  filters: PathFilters = DEFAULT_FILTERS,
): Array<string> => {
  if (!initialFiber) return [];

  const currentName = getDisplayName(initialFiber.type);
  if (!currentName) return [];

  const stack = new Array<string>();
  let fiber = initialFiber;
  while (fiber.return) {
    const name = getCleanComponentName(fiber.type);
    if (name && !isMinified(name) && shouldIncludeInPath(name, filters) && name.toLowerCase() !== name) {
      stack.push(name);
    }
    fiber = fiber.return;
  }
  const fullPath = new Array<string>(stack.length);
  for (let i = 0; i < stack.length; i++) {
    fullPath[i] = stack[stack.length - i - 1];
  }
  return fullPath;
};

let currentMouseOver: Element;

interface FiberType {
  displayName?: string;
  name?: string;
  [key: string]: unknown;
}

const getCleanComponentName = (component: FiberType): string => {
  const name = getDisplayName(component);
  if (!name) return '';

  return name.replace(
    /^(?:Memo|Forward(?:Ref)?|With.*?)\((?<inner>.*?)\)$/,
    '$<inner>',
  );
};

// For future use, normalization of paths happens on server side now using path property of interaction
// const _normalizePath = (path: Array<string>): string => {
// 	const cleaned = path.filter(Boolean);
// 	const deduped = cleaned.filter((name, i) => name !== cleaned[i - 1]);
// 	return deduped.join('.');
// };

const handleMouseover = (event: Event) => {
  if (!(event.target instanceof Element)) return;
  currentMouseOver = event.target;
};

const getFirstNamedAncestorCompositeFiber = (element: Element) => {
  let curr: Element | null = element;
  let parentCompositeFiber: Fiber | null = null;
  while (!parentCompositeFiber && curr.parentElement) {
    curr = curr.parentElement;

    const fiber = getCompositeComponentFromElement(curr).parentCompositeFiber;

    if (!fiber) {
      continue;
    }
    if (getDisplayName(fiber.type)) {
      parentCompositeFiber = fiber;
    }
  }
  return parentCompositeFiber;
};

// fixme: compress me if this stays here for bad interaction time checks
let lastVisibilityHiddenAt: number | 'never-hidden' = 'never-hidden';

const onVisibilityChange = () => {
  if (document.hidden) {
    lastVisibilityHiddenAt = Date.now();
  }
};

const trackVisibilityChange = () => {
  document.removeEventListener('visibilitychange', onVisibilityChange);
  document.addEventListener('visibilitychange', onVisibilityChange);
};

// todo: update monitoring api to expose filters for component names
export function initPerformanceMonitoring(options?: Partial<PathFilters>) {
  const filters = { ...DEFAULT_FILTERS, ...options };
  const monitor = Store.monitor.value;
  if (!monitor) return;

  document.addEventListener('mouseover', handleMouseover);
  const disconnectPerformanceListener = setupPerformanceListener((entry) => {
    const target =
      entry.target ?? (entry.type === 'pointer' ? currentMouseOver : null);
    if (!target) {
      // most likely an invariant that we should log if its violated
      return;
    }
    const parentCompositeFiber = getFirstNamedAncestorCompositeFiber(target);
    if (!parentCompositeFiber) {
      return;
    }
    const displayName = getDisplayName(parentCompositeFiber.type);
    if (!displayName || isMinified(displayName)) {
      // invariant, we know its named based on getFirstNamedAncestorCompositeFiber implementation
      return;
    }

    const path = getInteractionPath(parentCompositeFiber, filters);

    monitor.interactions.push({
      componentName: displayName,
      componentPath: path,
      performanceEntry: entry,
      components: new Map(),
      url: window.location.toString(),
      route:
        Store.monitor.value?.route ?? new URL(window.location.href).pathname,
      commit: Store.monitor.value?.commit ?? null,
      branch: Store.monitor.value?.branch ?? null,
      uniqueInteractionId: entry.id,
    });
  });

  return () => {
    disconnectPerformanceListener();
    document.removeEventListener('mouseover', handleMouseover);
  };
}

const POINTER_EVENTS = new Set(['pointerdown', 'pointerup', 'click']);
const KEYBOARD_EVENTS = new Set(['keydown', 'keyup']);

const getInteractionType = (
  eventName: string,
): 'pointer' | 'keyboard' | null => {
  if (POINTER_EVENTS.has(eventName)) {
    return 'pointer';
  }
  if (KEYBOARD_EVENTS.has(eventName)) {
    return 'keyboard';
  }
  return null;
};

const setupPerformanceListener = (
  onEntry: (interaction: PerformanceInteraction) => void,
) => {
  trackVisibilityChange();
  const longestInteractionMap = new Map<string, PerformanceInteraction>();
  const interactionTargetMap = new Map<string, Element>();

  const processInteractionEntry = (entry: PerformanceInteractionEntry) => {
    if (!(entry.interactionId || entry.entryType === 'first-input')) return;

    if (
      entry.interactionId &&
      entry.target &&
      !interactionTargetMap.has(entry.interactionId)
    ) {
      interactionTargetMap.set(entry.interactionId, entry.target);
    }

    const existingInteraction = longestInteractionMap.get(entry.interactionId);

    if (existingInteraction) {
      if (entry.duration > existingInteraction.latency) {
        existingInteraction.entries = [entry];
        existingInteraction.latency = entry.duration;
      } else if (
        entry.duration === existingInteraction.latency &&
        entry.startTime === existingInteraction.entries[0].startTime
      ) {
        existingInteraction.entries.push(entry);
      }
    } else {
      const interactionType = getInteractionType(entry.name);
      if (!interactionType) return;

      const interaction: PerformanceInteraction = {
        id: entry.interactionId,
        latency: entry.duration,
        entries: [entry],
        target: entry.target,
        type: interactionType,
        startTime: entry.startTime,
        processingStart: entry.processingStart,
        processingEnd: entry.processingEnd,
        duration: entry.duration,
        inputDelay: entry.processingStart - entry.startTime,
        processingDuration: entry.processingEnd - entry.processingStart,
        presentationDelay:
          entry.duration - (entry.processingEnd - entry.startTime),
        timestamp: Date.now(),
        timeSinceTabInactive:
          lastVisibilityHiddenAt === 'never-hidden'
            ? 'never-hidden'
            : Date.now() - lastVisibilityHiddenAt,
        visibilityState: document.visibilityState,
        timeOrigin: performance.timeOrigin,
        referrer: document.referrer,
      };
      longestInteractionMap.set(interaction.id, interaction);

      onEntry(interaction);
    }
  };

  const po = new PerformanceObserver((list) => {
    const entries = list.getEntries();
    for (let i = 0, len = entries.length; i < len; i++) {
      const entry = entries[i];
      processInteractionEntry(entry as PerformanceInteractionEntry);
    }
  });

  try {
    po.observe({
      type: 'event',
      buffered: true,
      durationThreshold: 16,
    } as PerformanceObserverInit);
    po.observe({
      type: 'first-input',
      buffered: true,
    });
  } catch {
    /* Should collect error logs*/
  }

  return po.disconnect.bind(po);
};
</file>

<file path="src/core/monitor/types.ts">
import type { Fiber } from 'bippy';

export enum Device {
  DESKTOP = 0,
  TABLET = 1,
  MOBILE = 2,
}

export interface Session {
  id: string;
  device: Device;
  agent: string;
  wifi: string;
  cpu: number;
  gpu: string | null;
  mem: number;
  url: string;
  route: string | null;
  commit: string | null;
  branch: string | null;
}

export interface Interaction {
  id: string | number; // index of the interaction in the batch at ingest | server converts to a hashed string from route, type, name, path
  path: Array<string>; // the path of the interaction
  name: string; // name of interaction
  type: string; // type of interaction i.e pointer
  time: number; // time of interaction in ms
  timestamp: number;
  url: string;
  route: string | null; // the computed route that handles dynamic params

  // Regression tracking
  commit: string | null;
  branch: string | null;

  // clickhouse + ingest specific types
  projectId?: string;
  sessionId?: string;
  uniqueInteractionId: string;

  meta?: unknown;
}

export interface Component {
  interactionId: string | number; // grouping components by interaction
  name: string;
  renders: number; // how many times it re-rendered / instances (normalized)
  instances: number; // instances which will be used to get number of total renders by * by renders
  totalTime?: number;
  selfTime?: number;
}

export interface IngestRequest {
  interactions: Array<Interaction>;
  components: Array<Component>;
  session: Session;
}

// used internally in runtime for interaction tracking. converted to Interaction when flushed
export interface InternalInteraction {
  componentName: string;
  url: string;
  route: string | null;
  commit: string | null;
  branch: string | null;
  uniqueInteractionId: string; // uniqueInteractionId is unique to the session and provided by performance observer.
  componentPath: Array<string>;
  performanceEntry: PerformanceInteraction;
  components: Map<string, InternalComponentCollection>;
}
interface InternalComponentCollection {
  uniqueInteractionId: string;
  name: string;
  renders: number; // re-renders associated with the set of components in this collection
  totalTime?: number;
  selfTime?: number;
  fibers: Set<Fiber>; // no references will exist to this once array is cleared after flush, so we don't have to worry about memory leaks
  retiresAllowed: number; // if our server is down and we can't collect fibers/ user has no network, it will memory leak. We need to only allow a set amount of retries before it gets gcd
}

export interface PerformanceInteractionEntry extends PerformanceEntry {
  interactionId: string;
  target: Element;
  name: string;
  duration: number;
  startTime: number;
  processingStart: number;
  processingEnd: number;
  entryType: string;
}
export interface PerformanceInteraction {
  id: string;
  latency: number;
  entries: Array<PerformanceInteractionEntry>;
  target: Element;
  type: 'pointer' | 'keyboard';
  startTime: number;
  processingStart: number;
  processingEnd: number;
  duration: number;
  inputDelay: number;
  processingDuration: number;
  presentationDelay: number;
  timestamp: number;
  timeSinceTabInactive: number | 'never-hidden';
  visibilityState: DocumentVisibilityState;
  timeOrigin: number;
  referrer: string;
}
</file>

<file path="src/core/monitor/utils.ts">
import { IS_CLIENT } from '~web/utils/constants';
import { onIdle } from '~web/utils/helpers';
import { isSSR } from './constants';
import { Device, type Session } from './types';

interface NetworkInformation {
  connection?: {
    effectiveType?: string;
  };
}

interface ExtendedNavigator extends Navigator {
  deviceMemory?: number;
}

const MOBILE_PATTERN =
  /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i;

const TABLET_PATTERN = /iPad|Tablet/i;

const getDeviceType = () => {
  const userAgent = navigator.userAgent;

  if (MOBILE_PATTERN.test(userAgent)) {
    return Device.MOBILE;
  }
  if (TABLET_PATTERN.test(userAgent)) {
    return Device.TABLET;
  }
  return Device.DESKTOP;
};

/**
 * Measure layout time
 */
export const doubleRAF = (callback: (...args: unknown[]) => void) => {
  return requestAnimationFrame(requestAnimationFrame.bind(window, callback));
};

export const generateId = () => {
  const alphabet =
    'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
  let id = '';
  const randomValues = crypto.getRandomValues(new Uint8Array(21));
  for (let i = 0; i < 21; i++) {
    id += alphabet[63 & randomValues[i]];
  }
  return id;
};

/**
 * @see https://deviceandbrowserinfo.com/learning_zone/articles/webgl_renderer_values
 */
const getGpuRenderer = () => {
  if (!('chrome' in window)) return ''; // Prevent WEBGL_debug_renderer_info deprecation warnings in firefox
  const gl = document
    .createElement('canvas')

    // Get the specs for the fastest GPU available. This helps provide a better
    // picture of the device's capabilities.
    .getContext('webgl', { powerPreference: 'high-performance' });
  if (!gl) return '';
  const ext = gl.getExtension('WEBGL_debug_renderer_info');
  return ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : '';
};

/**
 * Session is a loose way to fingerprint / identify a session.
 *
 * Modified from @palette.dev/browser:
 * @see https://gist.github.com/aidenybai/473689493f2d5d01bbc52e2da5950b45#file-palette-dev-browser-dist-palette-dev-mjs-L554
 * DO NOT CALL THIS EVERYTIME
 */
let cachedSession: Session;
export const getSession = async ({
  commit = null,
  branch = null,
}: {
  commit?: string | null;
  branch?: string | null;
}) => {
  if (isSSR()) return null;
  if (cachedSession) {
    return cachedSession;
  }
  const id = generateId();
  const url = window.location.toString();
  /**
   * WiFi connection strength
   *
   * Potential outputs: slow-2g, 2g, 3g, 4g
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/effectiveType
   */
  const connection = (navigator as NetworkInformation).connection;
  const wifi = connection?.effectiveType ?? null;
  /**
   * Number of CPU threads
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/hardwareConcurrency
   */
  const cpu = navigator.hardwareConcurrency;
  /**
   * Device memory (GiB)
   *
   * Potential outputs: 0.25, 0.5, 1, 2, 4, 8
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/deviceMemory
   */
  const mem = (navigator as ExtendedNavigator).deviceMemory ?? 0;

  const gpuRendererPromise = new Promise<string | null>((resolve) => {
    onIdle(() => {
      resolve(getGpuRenderer());
    });
  });

  const session = {
    id,
    url,
    route: null,
    device: getDeviceType(),
    wifi: wifi ?? '',
    cpu,
    mem,
    gpu: await gpuRendererPromise,
    agent: navigator.userAgent,
    commit,
    branch,
    version: process.env.NPM_PACKAGE_VERSION,
  };
  cachedSession = session;
  return session;
};

export const not_globally_unique_generateId = () => {
  if (!IS_CLIENT) {
    return '0';
  }

  // @ts-expect-error
  if (window.reactScanIdCounter === undefined) {
    // @ts-expect-error
    window.reactScanIdCounter = 0;
  }
  // @ts-expect-error
  return `${++window.reactScanIdCounter}`;
};
</file>

<file path="src/core/notifications/event-tracking.ts">
import { useSyncExternalStore } from 'preact/compat';
import { not_globally_unique_generateId } from '~core/monitor/utils';
import { MAX_INTERACTION_BATCH, interactionStore } from './interaction-store';
import {
  FiberRenders,
  PerformanceEntryChannelEvent,
  TimeoutStage,
  listenForPerformanceEntryInteractions,
  listenForRenders,
  setupDetailedPointerTimingListener,
  setupPerformancePublisher,
} from './performance';
import {
  MAX_CHANNEL_SIZE,
  performanceEntryChannels,
} from './performance-store';
import { BoundedArray } from './performance-utils';
import { createStore } from '~web/utils/create-store';

let profileListeners: Array<(interaction: FinalInteraction) => void> = [];

type FinalInteraction = {
  detailedTiming: TimeoutStage;
  latency: number;
  completedAt: number;
};

export const listenForProfile = (
  listener: (interaction: FinalInteraction) => void,
) => {
  profileListeners.push(listener);

  return () => {
    profileListeners = profileListeners.filter(
      (existingListener) => existingListener !== listener,
    );
  };
};

export let interactionStatus:
  | { kind: 'started'; startedAt: number }
  | { kind: 'completed'; startedAt: number; endedAt: number }
  | { kind: 'no-interaction' } = {
  kind: 'no-interaction',
};

type NewInteractionStoreState = {
  /**
   * problem definition: we need to store bounds but how do we handle uninitialized bounds
   *
   * i guess what we said before, we just have one active bounds and that's all that matters chat
   */

  startAt: number;
  endAt: number;
};

export const interactionStatusStore: {
  state: NewInteractionStoreState | null;
  listeners: Array<(state: NewInteractionStoreState) => void>;
  addListener: (cb: (state: NewInteractionStoreState) => void) => () => void;
} = {
  state: null,
  addListener: (cb) => {
    interactionStatusStore.listeners.push(cb);
    return () => {
      interactionStatusStore.listeners =
        interactionStatusStore.listeners.filter((l) => l !== cb);
    };
  },
  listeners: [],
};

let accumulatedFiberRendersOverTask: null | FiberRenders = null;
type InteractionEvent = {
  kind: 'interaction';
  data: {
    startAt: number;
    endAt: number;
    meta: {
      detailedTiming: TimeoutStage;
      latency: number;
      kind: PerformanceEntryChannelEvent['kind'];
    };
  };
};

type LongRenderPipeline = {
  kind: 'long-render';
  data: {
    startAt: number;
    endAt: number;
    meta: {
      latency: number;
      fiberRenders: FiberRenders;
      fps: number;
    };
  };
};

export type SlowdownEvent = (InteractionEvent | LongRenderPipeline) & {
  id: string;
};

type ToolbarEventStoreState = {
  state: {
    events: Array<SlowdownEvent>;
  };
  actions: {
    addEvent: (event: SlowdownEvent) => void;
    addListener: (listener: (event: SlowdownEvent) => void) => () => void;
    clear: () => void;
  };
};

type DebugEvent = {
  kind: string;
  at: number;
  meta?: unknown;
};
export const debugEventStore = createStore<{
  state: {
    events: Array<DebugEvent>;
  };
  actions: {
    // biome-ignore lint/suspicious/noExplicitAny: debug only store
    addEvent: (event: any) => void;
    clear: () => void;
  };
}>()((set) => ({
  state: {
    events: [],
  },
  actions: {
    addEvent: (event: DebugEvent) => {
      set((store) => ({
        state: {
          events: [...store.state.events, event],
        },
      }));
    },
    clear: () => {
      set({
        state: {
          events: [],
        },
      });
    },
  },
}));

export const toolbarEventStore = createStore<ToolbarEventStoreState>()(
  (set, get) => {
    const listeners = new Set<(event: SlowdownEvent) => void>();

    return {
      state: {
        events: [],
      },

      actions: {
        addEvent: (event: SlowdownEvent) => {
          listeners.forEach((listener) => listener(event));

          const events = [...get().state.events, event];
          const applyOverlapCheckToLongRenderEvent = (
            longRenderEvent: LongRenderPipeline & { id: string },
            onOverlap: (
              overlapsWith: InteractionEvent & { id: string },
            ) => void,
          ) => {
            const overlapsWith = events.find((event) => {
              if (event.kind === 'long-render') {
                return;
              }

              if (event.id === longRenderEvent.id) {
                return;
              }

              /**
               * |---x-----------x------ (interaction)
               * |x-----------x          (long-render)
               */

              if (
                longRenderEvent.data.startAt <= event.data.startAt &&
                longRenderEvent.data.endAt <= event.data.endAt &&
                longRenderEvent.data.endAt >= event.data.startAt
              ) {
                return true;
              }

              /**
             * |x-----------x---- (interaction)
             * |--x------------x  (long-render)
             *

             */

              if (
                event.data.startAt <= longRenderEvent.data.startAt &&
                event.data.endAt >= longRenderEvent.data.startAt
              ) {
                return true;
              }

              /**
               *
               * |--x-------------x    (interaction)
               * |x------------------x (long-render)
               *
               */

              if (
                longRenderEvent.data.startAt <= event.data.startAt &&
                longRenderEvent.data.endAt >= event.data.endAt
              ) {
                return true;
              }
            }) as undefined | (InteractionEvent & { id: string }); // invariant: because we early check the typechecker does not know it must be the case that when it finds something, it will be an interaction it overlaps with

            if (overlapsWith) {
              onOverlap(overlapsWith);
            }
          };

          const toRemove = new Set<string>();

          events.forEach((event) => {
            if (event.kind === 'interaction') return;
            applyOverlapCheckToLongRenderEvent(event, () => {
              toRemove.add(event.id);
            });
          });

          const withRemovedEvents = events.filter(
            (event) => !toRemove.has(event.id),
          );

          set(() => ({
            state: {
              events: withRemovedEvents,
            },
          }));
        },

        addListener: (listener: (event: SlowdownEvent) => void) => {
          listeners.add(listener);
          return () => {
            listeners.delete(listener);
          };
        },

        clear: () => {
          set({
            state: {
              events: [],
            },
          });
        },
      },
    };
  },
);

export const useToolbarEventLog = () => {
  return useSyncExternalStore(
    toolbarEventStore.subscribe,
    toolbarEventStore.getState,
  );
};

let taskDirtyAt: null | number = null;
let taskDirtyOrigin: null | number = null;

let previousTrackCurrentMouseOverElementCallback:
  | ((e: MouseEvent) => void)
  | null = null;

let overToolbar: boolean | null;

const trackCurrentMouseOverToolbar = () => {
  const callback = (e: MouseEvent) => {
    overToolbar = e
      .composedPath()
      .map((path) => (path as Element).id)
      .filter(Boolean)
      .includes('react-scan-toolbar');
  };

  document.addEventListener('mouseover', callback);
  previousTrackCurrentMouseOverElementCallback = callback;

  return () => {
    if (previousTrackCurrentMouseOverElementCallback) {
      document.removeEventListener(
        'mouseover',
        previousTrackCurrentMouseOverElementCallback,
      );
    }
  };
};

// stops long tasks b/c backgrounded from being reported
export const startDirtyTaskTracking = () => {
  const onVisibilityChange = () => {
    taskDirtyAt = performance.now();
    taskDirtyOrigin = performance.timeOrigin;
  };

  document.addEventListener('visibilitychange', onVisibilityChange);

  return () => {
    document.removeEventListener('visibilitychange', onVisibilityChange);
  };
};

export const HIGH_SEVERITY_FPS_DROP_TIME = 150;

let framesDrawnInTheLastSecond: Array<number> = [];

export function startLongPipelineTracking() {
  let rafHandle: number;
  let timeoutHandle: ReturnType<typeof setTimeout>;

  function measure() {
    let unSub: (() => void) | null = null;
    accumulatedFiberRendersOverTask = null;
    accumulatedFiberRendersOverTask = {};
    unSub = listenForRenders(accumulatedFiberRendersOverTask);
    const startOrigin = performance.timeOrigin;
    const startTime = performance.now();
    rafHandle = requestAnimationFrame(() => {
      // very low overhead, on the order of dozens of microseconds to run
      timeoutHandle = setTimeout(() => {
        const endNow = performance.now();
        const duration = endNow - startTime;
        const endOrigin = performance.timeOrigin;
        framesDrawnInTheLastSecond.push(endNow + endOrigin);

        const framesInTheLastSecond = framesDrawnInTheLastSecond.filter(
          (frameAt) => endNow + endOrigin - frameAt <= 1000,
        );

        const fps = framesInTheLastSecond.length;
        framesDrawnInTheLastSecond = framesInTheLastSecond;

        const taskConsideredDirty =
          taskDirtyAt !== null && taskDirtyOrigin !== null
            ? endNow + endOrigin - (taskDirtyOrigin + taskDirtyAt) < 100
            : null;
        // not useful to report slowdowns caused by things like outlines (can get expensive not fully optimized)
        const wasTaskInfluencedByToolbar = overToolbar !== null && overToolbar;

        if (
          duration > HIGH_SEVERITY_FPS_DROP_TIME &&
          !taskConsideredDirty &&
          document.visibilityState === 'visible' &&
          !wasTaskInfluencedByToolbar
        ) {
          const endAt = endOrigin + endNow;
          const startAt = startTime + startOrigin;

          toolbarEventStore.getState().actions.addEvent({
            kind: 'long-render',
            id: not_globally_unique_generateId(),
            data: {
              endAt: endAt,
              startAt: startAt,
              meta: {
                // biome-ignore lint/style/noNonNullAssertion: invariant: this will exist by this point
                fiberRenders: accumulatedFiberRendersOverTask!,
                latency: duration,
                fps,
              },
            },
          });
        }

        taskDirtyAt = null;
        taskDirtyOrigin = null;

        unSub?.();
        measure();
      }, 0);
    });
    return unSub;
  }

  const measureUnSub = measure();

  return () => {
    measureUnSub();
    cancelAnimationFrame(rafHandle);
    clearTimeout(timeoutHandle);
  };
}
export const startTimingTracking = () => {
  const unSubPerformance = setupPerformancePublisher();
  const unSubMouseOver = trackCurrentMouseOverToolbar();
  const unSubDirtyTaskTracking = startDirtyTaskTracking();
  const unSubLongPipelineTracking = startLongPipelineTracking();

  const onComplete = async (
    _: string,
    finalInteraction: FinalInteraction,
    event: PerformanceEntryChannelEvent,
  ) => {
    toolbarEventStore.getState().actions.addEvent({
      kind: 'interaction',
      id: not_globally_unique_generateId(),
      data: {
        startAt: finalInteraction.detailedTiming.blockingTimeStart,
        endAt: performance.now() + performance.timeOrigin,
        meta: { ...finalInteraction, kind: event.kind }, // TODO, will need interaction specific metadata here
      },
    });

    const existingCompletedInteractions =
      performanceEntryChannels.getChannelState('recording');

    finalInteraction.detailedTiming.stopListeningForRenders();

    if (existingCompletedInteractions.length) {
      // then performance entry and our detailed timing handlers are out of sync, we disregard that entry
      // it may be possible the performance entry returned before detailed timing. If that's the case we should update
      // assumptions and deal with mapping the entry back to the detailed timing here
      performanceEntryChannels.updateChannelState(
        'recording',
        () => new BoundedArray(MAX_CHANNEL_SIZE),
      );
    }
  };
  const unSubDetailedPointerTiming = setupDetailedPointerTimingListener(
    'pointer',
    {
      onComplete,
    },
  );
  const unSubDetailedKeyboardTiming = setupDetailedPointerTimingListener(
    'keyboard',
    {
      onComplete,
    },
  );

  const unSubInteractions = listenForPerformanceEntryInteractions(
    (completedInteraction) => {
      interactionStore.setState(
        BoundedArray.fromArray(
          interactionStore.getCurrentState().concat(completedInteraction),
          MAX_INTERACTION_BATCH,
        ),
      );
    },
  );

  return () => {
    unSubMouseOver();
    unSubDirtyTaskTracking();
    unSubLongPipelineTracking();
    unSubPerformance();
    unSubDetailedPointerTiming();
    unSubInteractions();
    unSubDetailedKeyboardTiming();
  };
};
</file>

<file path="src/core/notifications/interaction-store.ts">
import { BoundedArray } from "~core/notifications/performance-utils";
import { CompletedInteraction } from "./performance";

type Subscriber<T> = (data: T) => void;

export class Store<T> {
  private subscribers: Set<Subscriber<T>> = new Set();
  private currentValue: T;

  constructor(initialValue: T) {
    this.currentValue = initialValue;
  }

  subscribe(subscriber: Subscriber<T>): () => void {
    this.subscribers.add(subscriber);

    subscriber(this.currentValue);

    return () => {
      this.subscribers.delete(subscriber);
    };
  }

  setState(data: T) {
    this.currentValue = data;
    this.subscribers.forEach((subscriber) => subscriber(data));
  }

  getCurrentState(): T {
    return this.currentValue;
  }
}
export const MAX_INTERACTION_BATCH = 150;
export const interactionStore = new Store<BoundedArray<CompletedInteraction>>(
  new BoundedArray(MAX_INTERACTION_BATCH)
);
</file>

<file path="src/core/notifications/outline-overlay.ts">
import { signal } from '@preact/signals';
import { iife } from './performance-utils';

export interface HeatmapOverlay {
  boundingRect: DOMRect;
  ms: number;
  name: string;
}

export let highlightCanvas: HTMLCanvasElement | null = null;
export let highlightCtx: CanvasRenderingContext2D | null = null;

let animationFrame: number | null = null;

export type TransitionHighlightState = {
  kind: 'transition';
  transitionTo: {
    name: string;
    rects: Array<DOMRect>;
    alpha: number;
  };
  current: {
    name: string;
    rects: Array<DOMRect>;
    alpha: number;
  } | null;
};
type HighlightState =
  | TransitionHighlightState
  | {
      kind: 'move-out';
      current: {
        name: string;
        rects: Array<DOMRect>;
        alpha: number;
      };
    }
  | {
      kind: 'idle';
      current: {
        name: string;
        rects: Array<DOMRect>;
      } | null;
    };

export const HighlightStore = signal<HighlightState>({
  kind: 'idle',
  current: null,
});

let currFrame: ReturnType<typeof requestAnimationFrame> | null = null;
export const drawHighlights = () => {
  if (currFrame) {
    cancelAnimationFrame(currFrame);
  }
  currFrame = requestAnimationFrame(() => {
    if (!highlightCanvas || !highlightCtx) {
      return;
    }

    highlightCtx.clearRect(0, 0, highlightCanvas.width, highlightCanvas.height);

    const color = 'hsl(271, 76%, 53%)';
    const state = HighlightStore.value;
    const { alpha, current } = iife(() => {
      switch (state.kind) {
        case 'transition': {
          const current =
            state.current?.alpha && state.current.alpha > 0
              ? state.current
              : state.transitionTo;
          return {
            alpha: current ? current.alpha : 0,
            current,
          };
        }
        case 'move-out': {
          return { alpha: state.current?.alpha ?? 0, current: state.current };
        }
        case 'idle': {
          return { alpha: 1, current: state.current };
        }
      }
      // exhaustive check
      state satisfies never;
    });

    current?.rects.forEach((rect) => {
      if (!highlightCtx) {
        // typescript cant tell this closure is synchronous/non-escaping
        return;
      }
      highlightCtx.shadowColor = color;
      highlightCtx.shadowBlur = 6;
      highlightCtx.strokeStyle = color;
      highlightCtx.lineWidth = 2;

      highlightCtx.globalAlpha = alpha;

      highlightCtx.beginPath();
      highlightCtx.rect(rect.left, rect.top, rect.width, rect.height);
      highlightCtx.stroke();

      highlightCtx.shadowBlur = 0;
      highlightCtx.beginPath();
      highlightCtx.rect(rect.left, rect.top, rect.width, rect.height);
      highlightCtx.stroke();
    });

    switch (state.kind) {
      case 'move-out': {
        if (state.current.alpha === 0) {
          HighlightStore.value = {
            kind: 'idle',
            current: null,
          };
          return;
        }
        if (state.current.alpha <= 0.01) {
          state.current.alpha = 0;
        }
        state.current.alpha = Math.max(0, state.current.alpha - 0.03);
        drawHighlights();
        return;
      }
      case 'transition': {
        if (state.current && state.current.alpha > 0) {
          state.current.alpha = Math.max(0, state.current.alpha - 0.03);
          drawHighlights();
          return;
        }

        // invariant, state.current.alpha === 0
        if (state.transitionTo.alpha === 1) {
          HighlightStore.value = {
            kind: 'idle',
            current: state.transitionTo,
          };
          return;
        }

        // intentionally linear
        state.transitionTo.alpha = Math.min(state.transitionTo.alpha + 0.03, 1);

        drawHighlights();
      }
      case 'idle': {
        // no-op
        return;
      }
    }
  });
};

let handleResizeListener: (() => void) | null = null;
export const createHighlightCanvas = (root: HTMLElement) => {
  highlightCanvas = document.createElement('canvas');
  highlightCtx = highlightCanvas.getContext('2d', { alpha: true });
  if (!highlightCtx) return null;

  const dpr = window.devicePixelRatio || 1;
  const { innerWidth, innerHeight } = window;

  highlightCanvas.style.width = `${innerWidth}px`;
  highlightCanvas.style.height = `${innerHeight}px`;
  highlightCanvas.width = innerWidth * dpr;
  highlightCanvas.height = innerHeight * dpr;
  highlightCanvas.style.position = 'fixed';
  highlightCanvas.style.left = '0';
  highlightCanvas.style.top = '0';
  highlightCanvas.style.pointerEvents = 'none';
  highlightCanvas.style.zIndex = '2147483600';

  // *** ADD DATA ATTRIBUTE ***
  highlightCanvas.setAttribute('data-react-scan-canvas', 'true');
  // *** END ADD ***

  highlightCtx.scale(dpr, dpr);

  root.appendChild(highlightCanvas);

  if (handleResizeListener) {
    window.removeEventListener('resize', handleResizeListener);
  }

  const handleResize = () => {
    if (!highlightCanvas || !highlightCtx) return;
    const dpr = window.devicePixelRatio || 1;
    const { innerWidth, innerHeight } = window;

    highlightCanvas.style.width = `${innerWidth}px`;
    highlightCanvas.style.height = `${innerHeight}px`;
    highlightCanvas.width = innerWidth * dpr;
    highlightCanvas.height = innerHeight * dpr;
    highlightCtx.scale(dpr, dpr);

    drawHighlights();
  };
  handleResizeListener = handleResize;

  window.addEventListener('resize', handleResize);

  HighlightStore.subscribe(() => {
    requestAnimationFrame(() => {
      drawHighlights();
    });
  });

  return cleanup;
};

export function cleanup() {
  if (animationFrame) {
    cancelAnimationFrame(animationFrame);
    animationFrame = null;
  }
  if (highlightCanvas?.parentNode) {
    highlightCanvas.parentNode.removeChild(highlightCanvas);
  }
  highlightCanvas = null;
  highlightCtx = null;
}
</file>

<file path="src/core/notifications/performance-store.ts">
import { BoundedArray } from "./performance-utils";
import { PerformanceEntryChannelEvent } from "./performance";

type UnSubscribe = () => void;
type Callback<T> = (item: T) => void;
type Updater<T> = (state: BoundedArray<T>) => BoundedArray<T>;
type ChanelName = string;

type PerformanceEntryChannelsType<T> = {
  subscribe: (to: ChanelName, cb: Callback<T>) => UnSubscribe;
  publish: (
    item: T,
    to: ChanelName,
    dropFirst: boolean,
    createIfNoChannel: boolean
  ) => void;
  channels: Record<
    ChanelName,
    { callbacks: BoundedArray<Callback<T>>; state: BoundedArray<T> }
  >;
  getAvailableChannels: () => BoundedArray<string>;
  updateChannelState: (
    channel: ChanelName,
    updater: Updater<T>,
    createIfNoChannel: boolean
  ) => void;
};

export const MAX_CHANNEL_SIZE = 50;
// a set of entities communicate to each other through channels
// the state in the channel is persisted until the receiving end consumes it
// multiple subscribes to the same channel will likely lead to unintended behavior if the subscribers are separate entities
class PerformanceEntryChannels<T> implements PerformanceEntryChannelsType<T> {
  channels: PerformanceEntryChannelsType<T>["channels"] = {};
  publish(item: T, to: ChanelName, createIfNoChannel = true) {
    const existingChannel = this.channels[to];
    if (!existingChannel) {
      if (!createIfNoChannel) {
        return;
      }
      this.channels[to] = {
        callbacks: new BoundedArray<Callback<T>>(MAX_CHANNEL_SIZE),
        state: new BoundedArray<T>(MAX_CHANNEL_SIZE),
      };
      this.channels[to].state.push(item);
      return;
    }

    existingChannel.state.push(item);
    existingChannel.callbacks.forEach((cb) => cb(item));
  }

  getAvailableChannels() {
    return BoundedArray.fromArray(Object.keys(this.channels), MAX_CHANNEL_SIZE);
  }
  subscribe(to: ChanelName, cb: Callback<T>, dropFirst: boolean = false) {
    const defer = () => {
      if (!dropFirst) {
        this.channels[to].state.forEach((item) => {
          cb(item);
        });
      }
      return () => {
        const filtered = this.channels[to].callbacks.filter(
          (subscribed) => subscribed !== cb
        );
        this.channels[to].callbacks = BoundedArray.fromArray(
          filtered,
          MAX_CHANNEL_SIZE
        );
      };
    };
    const existing = this.channels[to];
    if (!existing) {
      this.channels[to] = {
        callbacks: new BoundedArray<Callback<T>>(MAX_CHANNEL_SIZE),
        state: new BoundedArray<T>(MAX_CHANNEL_SIZE),
      };
      this.channels[to].callbacks.push(cb);
      return defer();
    }

    existing.callbacks.push(cb);
    return defer();
  }
  updateChannelState(
    channel: ChanelName,
    updater: Updater<T>,
    createIfNoChannel = true
  ) {
    const existingChannel = this.channels[channel];
    if (!existingChannel) {
      if (!createIfNoChannel) {
        return;
      }

      const state = new BoundedArray<T>(MAX_CHANNEL_SIZE);
      const newChannel = {
        callbacks: new BoundedArray<Callback<T>>(MAX_CHANNEL_SIZE),
        state,
      };

      this.channels[channel] = newChannel;
      newChannel.state = updater(state);
      return;
    }

    existingChannel.state = updater(existingChannel.state);
  }

  getChannelState(channel: ChanelName) {
    return (
      this.channels[channel].state ?? new BoundedArray<T>(MAX_CHANNEL_SIZE)
    );
  }
}
// todo: discriminated union the events when we start using multiple channels
// we used to use multiple channels, but now we only use 1. This is still a useful abstraction incase we ever need more channels again
export const performanceEntryChannels =
  new PerformanceEntryChannels<PerformanceEntryChannelEvent>();
</file>

<file path="src/core/notifications/performance-utils.ts">
import { Fiber } from 'bippy';
export const getChildrenFromFiberLL = (fiber: Fiber) => {
  const children: Array<Fiber> = [];

  let curr: typeof fiber.child = fiber.child;

  while (curr) {
    children.push(curr);

    curr = curr.sibling;
  }

  return children;
};

type Node = Map<
  Fiber,
  {
    children: Array<Fiber>;
    parent: Fiber | null;
    isRoot: boolean;
    isSVG: boolean;
  }
>;

export const createChildrenAdjacencyList = (root: Fiber, limit: number) => {
  const tree: Node = new Map([]);

  const queue: Array<[node: Fiber, parent: Fiber | null]> = [];
  const visited = new Set<Fiber>();

  queue.push([root, root.return]);
  let traversed = 1;

  while (queue.length) {
    if (traversed >= limit) {
      return tree;
    }
    // biome-ignore lint/style/noNonNullAssertion: invariant
    const [node, parent] = queue.pop()!;
    const children = getChildrenFromFiberLL(node);

    tree.set(node, {
      children: [],
      parent,
      isRoot: node === root,
      isSVG: node.type === 'svg',
    });

    for (const child of children) {
      traversed += 1;
      // this isn't needed since the fiber tree is a TREE, not a graph, but it makes me feel safer
      if (visited.has(child)) {
        continue;
      }
      visited.add(child);
      tree.get(node)?.children.push(child);
      queue.push([child, node]);
    }
  }
  return tree;
};

const isProduction: boolean = process.env.NODE_ENV === 'production';
const prefix: string = 'Invariant failed';

// FIX ME THIS IS PRODUCTION INVARIANT LOL
export function devInvariant(
  condition: unknown,
  message?: string | (() => string),
): asserts condition {
  if (condition) {
    return;
  }

  if (isProduction) {
    throw new Error(prefix);
  }

  const provided: string | undefined =
    typeof message === 'function' ? message() : message;

  const value: string = provided ? `${prefix}: ${provided}` : prefix;
  throw new Error(value);
}

const THROW_INVARIANTS = false;

export const invariantError = (message: string | undefined) => {
  if (THROW_INVARIANTS) {
    throw new Error(message);
  }
};

export const iife = <T>(fn: () => T): T => fn();

export class BoundedArray<T> extends Array<T> {
  constructor(private capacity: number = 25) {
    super();
  }

  push(...items: T[]): number {
    const result = super.push(...items);
    while (this.length > this.capacity) {
      this.shift();
    }
    return result;
  }
  // do not couple capacity with a default param, it must be explicit
  static fromArray<T>(array: Array<T>, capacity: number) {
    const arr = new BoundedArray<T>(capacity);
    arr.push(...array);
    return arr;
  }
}
</file>

<file path="src/core/notifications/performance.ts">
import {
  Fiber,
  getDisplayName,
  getTimings,
  isHostFiber,
  traverseFiber,
} from 'bippy';
import { Store } from '../..';

import {
  BoundedArray,
  createChildrenAdjacencyList,
  invariantError,
} from '~core/notifications/performance-utils';
import {
  SectionData,
  collectInspectorDataWithoutCounts,
} from '~web/views/inspector/timeline/utils';
import {
  getFiberFromElement,
  getParentCompositeFiber,
} from '~web/views/inspector/utils';
import { performanceEntryChannels } from './performance-store';
import type {
  PerformanceInteraction,
  PerformanceInteractionEntry,
} from './types';
import { not_globally_unique_generateId } from '~core/monitor/utils';
import { getInteractionPath } from '~core/monitor/performance';

const getFirstNameFromAncestor = (
  fiber: Fiber,
  accept: (name: string) => boolean = () => true,
) => {
  let curr: Fiber | null = fiber;

  while (curr) {
    const currName = getDisplayName(curr.type);
    if (currName && accept(currName)) {
      return currName;
    }

    curr = curr.return;
  }
  return null;
};

let unsubscribeTrackVisibilityChange: (() => void) | undefined;
// fixme: compress me if this stays here for bad interaction time checks
let lastVisibilityHiddenAt: number | 'never-hidden' = 'never-hidden';

const trackVisibilityChange = () => {
  unsubscribeTrackVisibilityChange?.();
  const onVisibilityChange = () => {
    if (document.hidden) {
      lastVisibilityHiddenAt = Date.now();
    }
  };
  document.addEventListener('visibilitychange', onVisibilityChange);

  unsubscribeTrackVisibilityChange = () => {
    document.removeEventListener('visibilitychange', onVisibilityChange);
  };
};
export type FiberRenders = Record<
  string,
  {
    renderCount: number;
    parents: Set<string>;
    selfTime: number;
    totalTime: number;
    nodeInfo: Array<{
      selfTime: number;
      element: Element;
      name: string;
    }>;
    changes: ReturnType<typeof collectInspectorDataWithoutCounts>;
  }
>;

/**
 * we need to fix:
 * - if there's a tab switch during a task being tracked, then u disregard that task (i hope this doesn't make tab switches hard to debug that cause slowdowns, ug i suppose it probably would, right? Depends how the browser queues it but i suppose u can think of a scenario. It would be most optimal to subtract the timing but not sure how reliable that would be)
 * - we need to see why the tracking is just off
 * - we need to correctly implement the precise activation this time
 */

type InteractionStartStage = {
  kind: 'interaction-start';
  interactionType: 'pointer' | 'keyboard';
  interactionUUID: string;
  interactionStartDetail: number;
  blockingTimeStart: number;
  componentPath: Array<string>;
  componentName: string;
  childrenTree: Record<
    string,
    { children: Array<string>; firstNamedAncestor: string; isRoot: boolean }
  >;
  fiberRenders: FiberRenders;
  stopListeningForRenders: () => void;
};

type JSEndStage = Omit<InteractionStartStage, 'kind'> & {
  kind: 'js-end-stage';
  jsEndDetail: number;
};

type RAFStage = Omit<JSEndStage, 'kind'> & {
  kind: 'raf-stage';
  rafStart: number;
};

export type TimeoutStage = Omit<RAFStage, 'kind'> & {
  kind: 'timeout-stage';
  commitEnd: number;
  blockingTimeEnd: number;
};

export type PerformanceEntryChannelEvent =
  | {
      kind: 'entry-received';
      entry: PerformanceInteraction;
    }
  | {
      kind: 'auto-complete-race';
      interactionUUID: string;
      detailedTiming: TimeoutStage;
    };

export type CompletedInteraction = {
  detailedTiming: TimeoutStage;
  latency: number;
  completedAt: number;
  flushNeeded: boolean;
};

type UnInitializedStage = {
  kind: 'uninitialized-stage';
  // todo: no longer a uuid
  interactionUUID: string;
  interactionType: 'pointer' | 'keyboard';
};

type CurrentInteraction = {
  kind: 'pointer' | 'keyboard';
  interactionUUID: string;
  pointerUpStart: number;
  // needed for when inputs that can be clicked and trigger on change (like checkboxes)
  clickChangeStart: number | null;
  clickHandlerMicroTaskEnd: number | null;
  rafStart: number | null;
  commmitEnd: number | null;
  timeorigin: number;

  // for now i don't trust performance now timing for UTC time...
  blockingTimeStart: number;
  blockingTimeEnd: number | null;
  fiberRenders: Map<
    string,
    {
      renderCount: number;
      parents: Set<string>;
      selfTime: number;
    }
  >;
  componentPath: Array<string>;
  componentName: string;
  childrenTree: Record<
    string,
    { children: Array<string>; firstNamedAncestor: string; isRoot: boolean }
  >;
};

export let currentInteractions: Array<CurrentInteraction> = [];
export const fastHash = (str: string): string => {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash; // Convert to 32-bit integer
  }
  return hash.toString(36);
};
const getInteractionType = (
  eventName: string,
): 'pointer' | 'keyboard' | null => {
  // todo: track pointer down, but tends to not house expensive logic so not very high priority
  if (['pointerup', 'click'].includes(eventName)) {
    return 'pointer';
  }
  if (eventName.includes('key')) {
  }
  if (['keydown', 'keyup'].includes(eventName)) {
    return 'keyboard';
  }
  return null;
};
// biome-ignore lint/suspicious/noExplicitAny: shut up biome
export const getInteractionId = (interaction: any) => {
  return `${interaction.performanceEntry.type}::${normalizePath(interaction.componentPath)}::${interaction.url}`;
};
export function normalizePath(path: string[]): string {
  const cleaned = path.filter(Boolean);

  const deduped = cleaned.filter((name, i) => name !== cleaned[i - 1]);

  return deduped.join('.');
}
let onEntryAnimationId: number | null = null;
const setupPerformanceListener = (
  onEntry: (interaction: PerformanceInteraction) => void,
) => {
  trackVisibilityChange();
  const interactionMap = new Map<string, PerformanceInteraction>();
  const interactionTargetMap = new Map<string, Element>();

  const processInteractionEntry = (entry: PerformanceInteractionEntry) => {
    if (!entry.interactionId) return;

    if (
      entry.interactionId &&
      entry.target &&
      !interactionTargetMap.has(entry.interactionId)
    ) {
      interactionTargetMap.set(entry.interactionId, entry.target);
    }
    if (entry.target) {
      let current: Element | null = entry.target;
      while (current) {
        if (
          current.id === 'react-scan-toolbar-root' ||
          current.id === 'react-scan-root'
        ) {
          return;
        }
        current = current.parentElement;
      }
    }

    const existingInteraction = interactionMap.get(entry.interactionId);

    if (existingInteraction) {
      if (entry.duration > existingInteraction.latency) {
        existingInteraction.entries = [entry];
        existingInteraction.latency = entry.duration;
      } else if (
        entry.duration === existingInteraction.latency &&
        entry.startTime === existingInteraction.entries[0].startTime
      ) {
        existingInteraction.entries.push(entry);
      }
    } else {
      const interactionType = getInteractionType(entry.name);
      if (!interactionType) {
        return;
      }

      const interaction: PerformanceInteraction = {
        id: entry.interactionId,
        latency: entry.duration,
        entries: [entry],
        target: entry.target,
        type: interactionType,
        startTime: entry.startTime,
        endTime: Date.now(),
        processingStart: entry.processingStart,
        processingEnd: entry.processingEnd,
        duration: entry.duration,
        inputDelay: entry.processingStart - entry.startTime,
        processingDuration: entry.processingEnd - entry.processingStart,
        presentationDelay:
          entry.duration - (entry.processingEnd - entry.startTime),
        // componentPath:
        timestamp: Date.now(),
        timeSinceTabInactive:
          lastVisibilityHiddenAt === 'never-hidden'
            ? 'never-hidden'
            : Date.now() - lastVisibilityHiddenAt,
        visibilityState: document.visibilityState,
        timeOrigin: performance.timeOrigin,
        referrer: document.referrer,
      };
      //
      interactionMap.set(interaction.id, interaction);

      /**
       * This seems odd, but it gives us determinism that we will receive an entry AFTER our detailed timing collection
       * runs because browser semantics (raf(() => setTimeout) will always run before a doubleRaf)
       *
       * this also handles the case where multiple entries are dispatched for semantically the same interaction,
       * they will get merged into a single interaction, where the largest latency is recorded, which is what
       * we are interested in this application
       */

      if (!onEntryAnimationId) {
        onEntryAnimationId = requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            // biome-ignore lint/style/noNonNullAssertion: invariant
            onEntry(interactionMap.get(interaction.id)!);
            onEntryAnimationId = null;
          });
        });
      }
    }
  };

  const po = new PerformanceObserver((list) => {
    const entries = list.getEntries();
    for (let i = 0, len = entries.length; i < len; i++) {
      const entry = entries[i];
      processInteractionEntry(entry as PerformanceInteractionEntry);
    }
  });

  try {
    po.observe({
      type: 'event',
      buffered: true,
      durationThreshold: 16,
    } as PerformanceObserverInit);
    po.observe({
      type: 'first-input',
      buffered: true,
    });
  } catch {
    /* Should collect error logs*/
  }

  return () => po.disconnect();
};

export const setupPerformancePublisher = () => {
  return setupPerformanceListener((entry) => {
    performanceEntryChannels.publish(
      {
        kind: 'entry-received',
        entry,
      },
      'recording',
    );
  });
};

// we should actually only feed it the information it needs to complete so we can support safari
type Task = {
  completeInteraction: (
    entry: PerformanceEntryChannelEvent,
  ) => CompletedInteraction;
  startDateTime: number;
  endDateTime: number;
  type: 'keyboard' | 'pointer';
  interactionUUID: string;
};
export const MAX_INTERACTION_TASKS = 25;

let tasks = new BoundedArray<Task>(MAX_INTERACTION_TASKS);

const getAssociatedDetailedTimingInteraction = (
  entry: PerformanceInteraction,
  activeTasks: Array<Task>,
) => {
  let closestTask: Task | null = null;
  for (const task of activeTasks) {
    if (task.type !== entry.type) {
      continue;
    }

    if (closestTask === null) {
      closestTask = task;
      continue;
    }

    const getAbsoluteDiff = (task: Task, entry: PerformanceInteraction) =>
      Math.abs(task.startDateTime) - (entry.startTime + entry.timeOrigin);

    if (getAbsoluteDiff(task, entry) < getAbsoluteDiff(closestTask, entry)) {
      closestTask = task;
    }
  }

  return closestTask;
};

// this would be cool if it listened for merge, so it had to be after
export const listenForPerformanceEntryInteractions = (
  onComplete: (completedInteraction: CompletedInteraction) => void,
) => {
  // we make the assumption that the detailed timing will be ready before the performance timing
  const unsubscribe = performanceEntryChannels.subscribe(
    'recording',
    (event) => {
      const associatedDetailedInteraction =
        event.kind === 'auto-complete-race'
          ? tasks.find((task) => task.interactionUUID === event.interactionUUID)
          : getAssociatedDetailedTimingInteraction(event.entry, tasks);

      // REMINDME: this likely means we clicked a non interactable thing but our handler still ran
      // so we shouldn't treat this as an invariant, but instead use it to verify if we clicked
      // something interactable
      if (!associatedDetailedInteraction) {
        return;
      }

      const completedInteraction =
        associatedDetailedInteraction.completeInteraction(event);
      onComplete(completedInteraction);
    },
  );

  return unsubscribe;
};

type ShouldContinue = boolean;
const trackDetailedTiming = ({
  onMicroTask,
  onRAF,
  onTimeout,
  abort,
}: {
  onMicroTask: () => ShouldContinue;
  onRAF: () => ShouldContinue;
  onTimeout: () => void;
  abort?: () => boolean;
}) => {
  queueMicrotask(() => {
    if (abort?.() === true) {
      return;
    }

    if (!onMicroTask()) {
      return;
    }
    requestAnimationFrame(() => {
      if (abort?.() === true) {
        return;
      }
      if (!onRAF()) {
        return;
      }
      setTimeout(() => {
        if (abort?.() === true) {
          return;
        }
        onTimeout();
      }, 0);
    });
  });
};

const getTargetInteractionDetails = (target: Element) => {
  const associatedFiber = getFiberFromElement(target);
  if (!associatedFiber) {
    return;
  }

  // TODO: if element is minified, squash upwards till first non minified ancestor, and set name as ChildOf(<parent-name>)
  let componentName = associatedFiber
    ? getDisplayName(associatedFiber?.type)
    : 'N/A';

  if (!componentName) {
    componentName =
      getFirstNameFromAncestor(associatedFiber, (name) => name.length > 2) ??
      'N/A';
  }

  if (!componentName) {
    return;
  }

  const componentPath = getInteractionPath(associatedFiber);

  // const childrenTree = collectFiberSubtree(associatedFiber, 20); // this can be expensive if not limited

  // const firstChildSvg = Object.entries(childrenTree).find(([name, {isSvg  }]) => isSvg)

  // const firstSvg =
  //   associatedFiber.type === "svg"
  //     ? getFirstNameFromAncestor(associatedFiber)
  //     : Object.entries(childrenTree).find(([name, {isSvg  }]) => isSvg)

  // lowkey i have an idea
  return {
    componentPath,
    childrenTree: {},
    componentName,
  };
};

type LastInteractionRef = {
  current: (
    | InteractionStartStage
    | JSEndStage
    | RAFStage
    | TimeoutStage
    | UnInitializedStage
  ) & { stageStart: number };
};

/**
 *
 * handles tracking event timings for arbitrarily overlapping handlers with cancel logic
 */
export const setupDetailedPointerTimingListener = (
  kind: 'pointer' | 'keyboard',
  options: {
    onStart?: (interactionUUID: string) => void;
    onComplete?: (
      interactionUUID: string,
      finalInteraction: {
        detailedTiming: TimeoutStage;
        latency: number;
        completedAt: number;
        flushNeeded: boolean;
      },
      entry: PerformanceEntryChannelEvent,
    ) => void;
    onError?: (interactionUUID: string) => void;
  },
) => {
  let instrumentationIdInControl: string | null = null;

  const getEvent = (
    info: { phase: 'start' } | { phase: 'end'; target: Element },
  ) => {
    switch (kind) {
      case 'pointer': {
        if (info.phase === 'start') {
          return 'pointerup';
        }
        if (
          info.target instanceof HTMLInputElement ||
          info.target instanceof HTMLSelectElement
        ) {
          return 'change';
        }
        return 'click';
      }
      case 'keyboard': {
        if (info.phase === 'start') {
          return 'keydown';
        }

        return 'change';
      }
    }
  };

  const lastInteractionRef: LastInteractionRef = {
    current: {
      kind: 'uninitialized-stage',
      interactionUUID: not_globally_unique_generateId(), // the first interaction uses this
      stageStart: Date.now(),
      interactionType: kind,
    },
  };

  const onInteractionStart = (e: Event) => {
    const path = e.composedPath();
    if (
      path.some(
        (el) => el instanceof Element && el.id === 'react-scan-toolbar-root',
      )
    ) {
      return;
    }
    if (Date.now() - lastInteractionRef.current.stageStart > 2000) {
      lastInteractionRef.current = {
        kind: 'uninitialized-stage',
        interactionUUID: not_globally_unique_generateId(),
        stageStart: Date.now(),
        interactionType: kind,
      };
    }

    if (lastInteractionRef.current.kind !== 'uninitialized-stage') {
      return;
    }

    const pointerUpStart = performance.now();

    options?.onStart?.(lastInteractionRef.current.interactionUUID);
    const details = getTargetInteractionDetails(e.target as HTMLElement);

    if (!details) {
      options?.onError?.(lastInteractionRef.current.interactionUUID);
      return;
    }

    const fiberRenders: InteractionStartStage['fiberRenders'] = {};
    const stopListeningForRenders = listenForRenders(fiberRenders);
    lastInteractionRef.current = {
      ...lastInteractionRef.current,
      interactionType: kind,
      blockingTimeStart: Date.now(),
      childrenTree: details.childrenTree,
      componentName: details.componentName,
      componentPath: details.componentPath,
      fiberRenders,
      kind: 'interaction-start',
      interactionStartDetail: pointerUpStart,
      stopListeningForRenders,
    };

    const event = getEvent({ phase: 'end', target: e.target as Element });
    // biome-ignore lint/suspicious/noExplicitAny: shut up biome
    document.addEventListener(event, onLastJS as any, {
      once: true,
    });

    // this is an edge case where a click event is not fired after a pointerdown
    // im not sure why this happens, but it seems to only happen on non intractable elements
    // it causes the event handler to stay alive until a future interaction, which can break timing (looks super long)
    // or invariants (the start metadata was removed, so now its an end metadata with no start)
    requestAnimationFrame(() => {
      // biome-ignore lint/suspicious/noExplicitAny: shut up biome
      document.removeEventListener(event as any, onLastJS as any);
    });
  };

  document.addEventListener(
    getEvent({ phase: 'start' }),
    // biome-ignore lint/suspicious/noExplicitAny: shut up biome
    onInteractionStart as any,
    {
      capture: true,
    },
  );

  /**
   *
   * TODO: IF WE DETECT RENDERS DURING THIS PERIOD WE CAN INCLUDE THAT IN THE RESULT AND THEN BACK THAT OUT OF COMPUTED STYLE TIME AND ADD IT BACK INTO JS TIME
   */
  const onLastJS = (
    e: { target: Element },
    instrumentationId: string,
    abort: () => boolean,
  ) => {
    if (
      lastInteractionRef.current.kind !== 'interaction-start' &&
      instrumentationId === instrumentationIdInControl
    ) {
      if (kind === 'pointer' && e.target instanceof HTMLSelectElement) {
        lastInteractionRef.current = {
          kind: 'uninitialized-stage',
          interactionUUID: not_globally_unique_generateId(),
          stageStart: Date.now(),
          interactionType: kind,
        };
        return;
      }

      options?.onError?.(lastInteractionRef.current.interactionUUID);
      lastInteractionRef.current = {
        kind: 'uninitialized-stage',
        interactionUUID: not_globally_unique_generateId(),
        stageStart: Date.now(),
        interactionType: kind,
      };
      invariantError('pointer -> click');
      return;
    }

    instrumentationIdInControl = instrumentationId;

    trackDetailedTiming({
      abort,
      onMicroTask: () => {
        if (lastInteractionRef.current.kind === 'uninitialized-stage') {
          return false;
        }

        lastInteractionRef.current = {
          ...lastInteractionRef.current,
          kind: 'js-end-stage',
          jsEndDetail: performance.now(),
        };
        return true;
      },
      onRAF: () => {
        if (
          lastInteractionRef.current.kind !== 'js-end-stage' &&
          lastInteractionRef.current.kind !== 'raf-stage'
        ) {
          options?.onError?.(lastInteractionRef.current.interactionUUID);
          invariantError('bad transition to raf');
          lastInteractionRef.current = {
            kind: 'uninitialized-stage',
            interactionUUID: not_globally_unique_generateId(),
            stageStart: Date.now(),
            interactionType: kind,
          };
          return false;
        }

        lastInteractionRef.current = {
          ...lastInteractionRef.current,
          kind: 'raf-stage',
          rafStart: performance.now(),
        };

        return true;
      },
      onTimeout: () => {
        if (lastInteractionRef.current.kind !== 'raf-stage') {
          options?.onError?.(lastInteractionRef.current.interactionUUID);
          lastInteractionRef.current = {
            kind: 'uninitialized-stage',
            interactionUUID: not_globally_unique_generateId(),
            stageStart: Date.now(),
            interactionType: kind,
          };
          invariantError('raf->timeout');
          return;
        }
        const now = Date.now();
        const timeoutStage: TimeoutStage = Object.freeze({
          ...lastInteractionRef.current,
          kind: 'timeout-stage',
          blockingTimeEnd: now,
          commitEnd: performance.now(),
        });

        lastInteractionRef.current = {
          kind: 'uninitialized-stage',
          interactionUUID: not_globally_unique_generateId(),
          stageStart: now,
          interactionType: kind,
        };
        let completed = false;
        const completeInteraction = (event: PerformanceEntryChannelEvent) => {
          completed = true;

          const latency =
            event.kind === 'auto-complete-race'
              ? event.detailedTiming.commitEnd -
                event.detailedTiming.interactionStartDetail
              : event.entry.latency;
          const finalInteraction = {
            detailedTiming: timeoutStage,
            latency,
            completedAt: Date.now(),
            flushNeeded: true,
          };

          options?.onComplete?.(
            timeoutStage.interactionUUID,
            finalInteraction,
            event,
          );
          const newTasks = tasks.filter(
            (task) => task.interactionUUID !== timeoutStage.interactionUUID,
          );
          tasks = BoundedArray.fromArray(newTasks, MAX_INTERACTION_TASKS);

          return finalInteraction;
        };

        const task = {
          completeInteraction,
          endDateTime: Date.now(),
          startDateTime: timeoutStage.blockingTimeStart,
          type: kind,
          interactionUUID: timeoutStage.interactionUUID,
        };
        tasks.push(task);

        if (!isPerformanceEventAvailable()) {
          const newTasks = tasks.filter(
            (task) => task.interactionUUID !== timeoutStage.interactionUUID,
          );
          tasks = BoundedArray.fromArray(newTasks, MAX_INTERACTION_TASKS);
          completeInteraction({
            kind: 'auto-complete-race',
            // redundant
            detailedTiming: timeoutStage,
            interactionUUID: timeoutStage.interactionUUID,
          });
        } else {
          setTimeout(() => {
            if (completed) {
              return;
            }
            completeInteraction({
              kind: 'auto-complete-race',
              // redundant
              detailedTiming: timeoutStage,
              interactionUUID: timeoutStage.interactionUUID,
            });
            const newTasks = tasks.filter(
              (task) => task.interactionUUID !== timeoutStage.interactionUUID,
            );
            tasks = BoundedArray.fromArray(newTasks, MAX_INTERACTION_TASKS);
            // this means the max frame presentation delta we can observe is 300ms, but this should catch >99% of cases, the trade off is to not accidentally miss slowdowns if the user quickly clicked something else while this race was happening
          }, 1000);
        }
      },
    });
  };

  const onKeyPress = (e: { target: Element }) => {
    const id = not_globally_unique_generateId();
    onLastJS(e, id, () => id !== instrumentationIdInControl);
  };

  if (kind === 'keyboard') {
    // biome-ignore lint/suspicious/noExplicitAny: shut up biome
    document.addEventListener('keypress', onKeyPress as any);
  }

  return () => {
    document.removeEventListener(
      getEvent({ phase: 'start' }),
      // biome-ignore lint/suspicious/noExplicitAny: shut up biome
      onInteractionStart as any,
      {
        capture: true,
      },
    );
    // biome-ignore lint/suspicious/noExplicitAny: shut up biome
    document.removeEventListener('keypress', onKeyPress as any);
  };
};

// unused, but will be soon for monitoring
export const collectFiberSubtree = (
  fiber: Fiber,
  limit: number,
): Record<
  string,
  {
    children: Array<string>;
    firstNamedAncestor: string;
    isRoot: boolean;
    isSvg: boolean;
  }
> => {
  const adjacencyList = createChildrenAdjacencyList(fiber, limit).entries();
  const fiberToNames = Array.from(adjacencyList).map(
    ([fiber, { children, parent, isRoot, isSVG }]) => [
      getDisplayName(fiber.type) ?? 'N/A',
      {
        children: children.map((fiber) => getDisplayName(fiber.type) ?? 'N/A'),
        firstNamedAncestor: parent
          ? (getFirstNameFromAncestor(parent) ?? 'No Parent')
          : 'No Parent',
        isRoot,
        isSVG,
      },
    ],
  );

  return Object.fromEntries(fiberToNames);
};

const getHostFromFiber = (fiber: Fiber) => {
  return traverseFiber(fiber, (node) => {
    // shouldn't be too slow
    if (isHostFiber(node)) {
      return true;
    }
  })?.stateNode;
};

const isPerformanceEventAvailable = () => {
  return 'PerformanceEventTiming' in globalThis;
};

export const listenForRenders = (
  fiberRenders: InteractionStartStage['fiberRenders'],
) => {
  const listener = (fiber: Fiber) => {
    const displayName = getDisplayName(fiber.type);
    if (!displayName) {
      return;
    }
    const existing = fiberRenders[displayName];
    if (!existing) {
      const parents = new Set<string>();
      const res = fiber.return && getParentCompositeFiber(fiber.return);
      const parentCompositeName = res && getDisplayName(res[0]);
      if (parentCompositeName) {
        parents.add(parentCompositeName);
      }
      const { selfTime, totalTime } = getTimings(fiber);

      const newChanges = collectInspectorDataWithoutCounts(fiber);
      const emptySection: SectionData = {
        current: [],
        changes: new Set<string | number>(),
        changesCounts: new Map<string | number, number>(),
      };
      const changes = {
        fiberProps: newChanges.fiberProps || emptySection,
        fiberState: newChanges.fiberState || emptySection,
        fiberContext: newChanges.fiberContext || emptySection,
      };
      fiberRenders[displayName] = {
        renderCount: 1,
        parents: parents,
        selfTime,
        totalTime,
        nodeInfo: [
          {
            element: getHostFromFiber(fiber),
            name: getDisplayName(fiber.type) ?? 'Unknown',
            selfTime: getTimings(fiber).selfTime,
          },
        ],
        changes,
      };

      return;
    }
    const parentType = getParentCompositeFiber(fiber)?.[0]?.type;
    if (parentType) {
      const res = fiber.return && getParentCompositeFiber(fiber.return);
      const parentCompositeName = res && getDisplayName(res[0]);
      if (parentCompositeName) {
        existing.parents.add(parentCompositeName);
      }
    }
    const { selfTime, totalTime } = getTimings(fiber);

    const newChanges = collectInspectorDataWithoutCounts(fiber);

    if (!newChanges) return;

    const emptySection: SectionData = {
      current: [],
      changes: new Set<string | number>(),
      changesCounts: new Map<string | number, number>(),
    };

    existing.changes = {
      fiberProps: mergeSectionData(
        existing.changes?.fiberProps || emptySection,
        newChanges.fiberProps || emptySection,
      ),
      fiberState: mergeSectionData(
        existing.changes?.fiberState || emptySection,
        newChanges.fiberState || emptySection,
      ),
      fiberContext: mergeSectionData(
        existing.changes?.fiberContext || emptySection,
        newChanges.fiberContext || emptySection,
      ),
    };

    existing.renderCount += 1;
    existing.selfTime += selfTime;
    existing.totalTime += totalTime;
    existing.nodeInfo.push({
      element: getHostFromFiber(fiber),
      name: getDisplayName(fiber.type) ?? 'Unknown',
      selfTime: getTimings(fiber).selfTime,
    });
  };
  Store.interactionListeningForRenders = listener;

  return () => {
    if (Store.interactionListeningForRenders === listener) {
      Store.interactionListeningForRenders = null;
    }
  };
};

const mergeSectionData = (
  existing: SectionData,
  newData: SectionData,
): SectionData => {
  const mergedSection: SectionData = {
    current: [...existing.current],
    changes: new Set<string | number>(),
    changesCounts: new Map<string | number, number>(),
  };

  for (const value of newData.current) {
    if (!mergedSection.current.some((item) => item.name === value.name)) {
      mergedSection.current.push(value);
    }
  }

  for (const change of newData.changes) {
    if (typeof change === 'string' || typeof change === 'number') {
      mergedSection.changes.add(change);
      const existingCount = existing.changesCounts.get(change) || 0;
      const newCount = newData.changesCounts.get(change) || 0;
      mergedSection.changesCounts.set(change, existingCount + newCount);
    }
  }

  return mergedSection;
};
</file>

<file path="src/core/notifications/types.ts">
export interface PerformanceInteractionEntry extends PerformanceEntry {
  interactionId: string;
  target: Element;
  name: string;
  duration: number;
  startTime: number;
  processingStart: number;
  processingEnd: number;
  entryType: string;
}
export interface PerformanceInteraction {
  id: string;
  latency: number;
  entries: Array<PerformanceInteractionEntry>;
  target: Element | null;
  type: "pointer" | "keyboard";
  startTime: number;
  endTime: number;
  processingStart: number;
  processingEnd: number;
  duration: number;
  inputDelay: number;
  processingDuration: number;
  presentationDelay: number;
  timestamp: number;
  timeSinceTabInactive: number | "never-hidden";
  visibilityState: DocumentVisibilityState;
  timeOrigin: number;
  referrer: string;
  detailedTiming?: {
    jsHandlersTime: number; // pointerup -> click
    prePaintTime: number; // click -> RAF
    paintTime: number; // RAF -> setTimeout
    compositorTime: number; // remaining duration
  };
}
</file>

<file path="src/core/fast-serialize.test.ts">
import { describe, expect, it } from 'vitest';
import { fastSerialize } from '~core/instrumentation';

describe('fastSerialize', () => {
  it('serializes null', () => {
    expect(fastSerialize(null)).toBe('null');
  });

  it('serializes undefined', () => {
    expect(fastSerialize(undefined)).toBe('undefined');
  });

  it('serializes strings', () => {
    expect(fastSerialize('hello')).toBe('hello');
    expect(fastSerialize('')).toBe('');
  });

  it('serializes numbers', () => {
    expect(fastSerialize(42)).toBe('42');
    expect(fastSerialize(0)).toBe('0');
    expect(fastSerialize(Number.NaN)).toBe('NaN');
  });

  it('serializes booleans', () => {
    expect(fastSerialize(true)).toBe('true');
    expect(fastSerialize(false)).toBe('false');
  });

  it('serializes functions', () => {
    const testFunc = (_x: 2) => 3;
    expect(fastSerialize(testFunc)).toBe('(_x) => 3');
  });

  it('serializes arrays', () => {
    expect(fastSerialize([])).toBe('[]');
    expect(fastSerialize([1, 2, 3])).toBe('[3]');
  });

  it('serializes plain objects', () => {
    expect(fastSerialize({})).toBe('{}');
    expect(fastSerialize({ a: 1, b: 2 })).toBe('{2}');
  });

  it('serializes deeply nested objects with depth limit', () => {
    const nested = { a: { b: { c: 1 } } };
    expect(fastSerialize(nested, 0)).toBe('{1}');
    expect(fastSerialize(nested, -1)).toBe('');
  });

  it('serializes objects with custom constructors', () => {
    class CustomClass {}
    const instance = new CustomClass();
    expect(fastSerialize(instance)).toBe('CustomClass{}');
  });

  it('serializes unknown objects gracefully', () => {
    const date = new Date();
    const serialized = fastSerialize(date);
    expect(serialized.includes('Date')).toBe(true);
  });
});
</file>

<file path="src/core/index.ts">
import { type Signal, signal } from '@preact/signals';
import {
  type Fiber,
  type FiberRoot,
  detectReactBuildType,
  getRDTHook,
  getType,
  isInstrumentationActive,
} from 'bippy';
import type { ComponentType } from 'preact';
import type { ReactNode } from 'preact/compat';
import type { RenderData } from 'src/core/utils';
import { initReactScanInstrumentation } from 'src/new-outlines';
import styles from '~web/assets/css/styles.css';
import { createToolbar } from '~web/toolbar';
import { IS_CLIENT } from '~web/utils/constants';
import { readLocalStorage, saveLocalStorage } from '~web/utils/helpers';
import type { Outline } from '~web/utils/outline';
import type { States } from '~web/views/inspector/utils';
import type {
  ChangeReason,
  Render,
  createInstrumentation,
} from './instrumentation';
import type { InternalInteraction } from './monitor/types';
import type { getSession } from './monitor/utils';
import { startTimingTracking } from './notifications/event-tracking';
import { createHighlightCanvas } from './notifications/outline-overlay';
import packageJson from '../../package.json';
// --- Import html-to-image ---
import * as htmlToImage from '../html-to-image';
import type { Options as HtmlToImageOptions } from '../html-to-image';
import { getPixelRatio } from '../html-to-image/util';
// --- END: Ensure necessary imports ---

// --- START: Helper function to load image data URLs ---
const loadImage = (url: string): Promise<HTMLImageElement> => {
  return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = (err) => {
          console.error(`[React Scan Iframe] Failed to load image data URL: ${url.substring(0,100)}...`);
          reject(err);
      };
      img.src = url;
  });
};
// --- END: Helper function ---


// --- START: Helper function to find visible fixed/sticky elements ---
interface FixedStickyElementInfo {
  element: HTMLElement;
  rect: DOMRect; // Viewport relative position
}

const findVisibleFixedStickyElements = (): FixedStickyElementInfo[] => {
  const elements: FixedStickyElementInfo[] = [];
  // Query all elements - consider performance implications if the DOM is huge.
  // Optimizations could involve querying only elements potentially having fixed/sticky styles
  // or listening to specific mutation observers, but querySelectorAll is simpler for now.
  const allElementsNodeList = document.querySelectorAll('*');
  const viewportWidth = document.documentElement.clientWidth;
  const viewportHeight = document.documentElement.clientHeight;

  // Correct: Convert NodeList to Array before iterating with for...of
  const allElementsArray = Array.from(allElementsNodeList);

  for (const element of allElementsArray) { // Iterate over the converted array
      if (!(element instanceof HTMLElement)) continue;

      const style = window.getComputedStyle(element);
      const position = style.position;
      const isFixedOrSticky = position === 'fixed' || position === 'sticky';

      if (!isFixedOrSticky) continue;

      const rect = element.getBoundingClientRect();

      // Basic visibility checks
      const isVisible =
          style.display !== 'none' &&
          style.visibility !== 'hidden' &&
          style.opacity !== '0' &&
          rect.width > 0 &&
          rect.height > 0;

      if (!isVisible) continue;

      // Check if it overlaps with the viewport
      const isInViewport =
          rect.bottom > 0 &&
          rect.right > 0 &&
          rect.top < viewportHeight &&
          rect.left < viewportWidth;

      if (isInViewport) {
          elements.push({ element, rect });
      }
  }
  return elements;
};
// --- END: Helper function ---


// --- Global State and Types (Original - unchanged) ---
let rootContainer: HTMLDivElement | null = null;
let shadowRoot: ShadowRoot | null = null;

interface RootContainer {
  rootContainer: HTMLDivElement;
  shadowRoot: ShadowRoot;
}

const initRootContainer = (): RootContainer => {
  if (rootContainer && shadowRoot) {
    return { rootContainer, shadowRoot };
  }

  rootContainer = document.createElement('div');
  rootContainer.id = 'react-scan-root'; // Keep this ID for potential filtering

  shadowRoot = rootContainer.attachShadow({ mode: 'open' });

  rootContainer.style.setProperty('display', 'none', 'important');

  const cssStyles = document.createElement('style');
  cssStyles.textContent = styles;

  shadowRoot.appendChild(cssStyles);

  document.documentElement.appendChild(rootContainer);

  return { rootContainer, shadowRoot };
};

export interface Options {
  enabled?: boolean;
  dangerouslyForceRunInProduction?: boolean;
  log?: boolean;
  showToolbar?: boolean;
  animationSpeed?: 'slow' | 'fast' | 'off';
  trackUnnecessaryRenders?: boolean;
  showFPS?: boolean;
  showNotificationCount?: boolean;
  _debug?: 'verbose' | false;
  onCommitStart?: () => void;
  onRender?: (fiber: Fiber, renders: Array<Render>) => void;
  onCommitFinish?: () => void;
  onPaintStart?: (outlines: Array<Outline>) => void;
  onPaintFinish?: (outlines: Array<Outline>) => void;
}

export type MonitoringOptions = Pick<
  Options,
  | 'enabled'
  | 'onCommitStart'
  | 'onCommitFinish'
  | 'onPaintStart'
  | 'onPaintFinish'
  | 'onRender'
>;

interface Monitor {
  pendingRequests: number;
  interactions: Array<InternalInteraction>;
  session: ReturnType<typeof getSession>;
  url: string | null;
  route: string | null;
  apiKey: string | null;
  commit: string | null;
  branch: string | null;
}

export interface StoreType {
  inspectState: Signal<States>;
  wasDetailsOpen: Signal<boolean>;
  lastReportTime: Signal<number>;
  isInIframe: Signal<boolean>;
  monitor: Signal<Monitor | null>;
  fiberRoots: WeakSet<Fiber>; // Changed from Set to WeakSet
  reportData: Map<number, RenderData>;
  legacyReportData: Map<string, RenderData>; // Consider removing if legacy not needed
  changesListeners: Map<number, Array<ChangesListener>>;
  interactionListeningForRenders:
    | ((fiber: Fiber, renders: Array<Render>) => void)
    | null;
}

export type OutlineKey = `${string}-${string}`;

export interface Internals {
  instrumentation: ReturnType<typeof createInstrumentation> | null;
  componentAllowList: WeakMap<ComponentType<unknown>, Options> | null;
  options: Signal<Options>;
  scheduledOutlines: Map<Fiber, Outline>;
  activeOutlines: Map<OutlineKey, Outline>;
  onRender: ((fiber: Fiber, renders: Array<Render>) => void) | null;
  Store: StoreType;
  version: string;
}

export type FunctionalComponentStateChange = {
  type: ChangeReason.FunctionalState;
  value: unknown;
  prevValue?: unknown;
  count?: number | undefined;
  name: string;
};
export type ClassComponentStateChange = {
  type: ChangeReason.ClassState;
  value: unknown;
  prevValue?: unknown;
  count?: number | undefined;
  name: 'state';
};

export type StateChange =
  | FunctionalComponentStateChange
  | ClassComponentStateChange;
export type PropsChange = {
  type: ChangeReason.Props;
  name: string;
  value: unknown;
  prevValue?: unknown;
  count?: number | undefined;
};
export type ContextChange = {
  type: ChangeReason.Context;
  name: string;
  value: unknown;
  prevValue?: unknown;
  count?: number | undefined;
  contextType: number;
};

export type Change = StateChange | PropsChange | ContextChange;

export type ChangesPayload = {
  propsChanges: Array<PropsChange>;
  stateChanges: Array<
    FunctionalComponentStateChange | ClassComponentStateChange
  >;
  contextChanges: Array<ContextChange>;
};
export type ChangesListener = (changes: ChangesPayload) => void;

export const Store: StoreType = {
  wasDetailsOpen: signal(true),
  isInIframe: signal(IS_CLIENT && window.self !== window.top),
  inspectState: signal<States>({
    kind: 'uninitialized',
  }),
  monitor: signal<Monitor | null>(null),
  fiberRoots: new WeakSet<Fiber>(), // Use WeakSet
  reportData: new Map<number, RenderData>(),
  legacyReportData: new Map<string, RenderData>(),
  lastReportTime: signal(0),
  interactionListeningForRenders: null,
  changesListeners: new Map(),
};

export const ReactScanInternals: Internals = {
  instrumentation: null,
  componentAllowList: null,
  options: signal({
    enabled: true,
    log: false,
    showToolbar: true,
    animationSpeed: 'fast',
    dangerouslyForceRunInProduction: false,
    showFPS: true,
    showNotificationCount: true,
  }),
  onRender: null,
  scheduledOutlines: new Map(),
  activeOutlines: new Map(),
  Store,
  version: packageJson.version,
};

if (IS_CLIENT && window.__REACT_SCAN_EXTENSION__) {
  window.__REACT_SCAN_VERSION__ = ReactScanInternals.version;
}

export type LocalStorageOptions = Omit<
  Options,
  | 'onCommitStart'
  | 'onRender'
  | 'onCommitFinish'
  | 'onPaintStart'
  | 'onPaintFinish'
>;

// --- START: MODIFIED CODE for postMessage Communication ---

/**
 * Scans the iframe's DOM for all elements with the 'data-sourcefile' attribute
 * and returns a list of unique file paths found.
 * @returns {string[]} An array of unique source file paths.
 */
const findAllSourceFiles = (): string[] => {
    if (!IS_CLIENT) return [];
    const fileSet = new Set<string>();
    const elementsWithSourceFile = document.querySelectorAll('[data-sourcefile]');
    elementsWithSourceFile.forEach((element) => {
        const sourceFile = (element as HTMLElement).dataset.sourcefile;
        if (sourceFile) {
            fileSet.add(sourceFile);
        }
    });
    return Array.from(fileSet);
};


/**
 * Handles incoming messages from the parent window.
 * Handles requests for file lists, iframe URL, and page screenshots.
 * @param {MessageEvent} event - The message event object.
 */
const handleParentMessage = async (event: MessageEvent) => {
    const PARENT_ORIGIN = '*'; // WARNING: Use specific origin in production!

    if (PARENT_ORIGIN !== '*' && event.origin !== PARENT_ORIGIN) {
        console.warn(`[React Scan Iframe] Ignoring message from untrusted origin: ${event.origin}`);
        return;
    }

    const request = event.data;

    if (!request || !request.type) {
        console.warn('[React Scan Iframe] Received invalid message:', event.data);
        return;
    }

    // --- Handle File List Request ---
    if (request.type === 'REQUEST_FILE_LIST') {
        console.log('[React Scan Iframe] Received REQUEST_FILE_LIST from parent.');
        const files = findAllSourceFiles();
        window.parent.postMessage({
            type: 'FILE_LIST_RESPONSE',
            payload: { files: files },
            requestId: request.requestId,
        }, PARENT_ORIGIN);
        console.log('[React Scan Iframe] Sent FILE_LIST_RESPONSE to parent:', files);
    }
    // --- Handle URL Request ---
    else if (request.type === 'REQUEST_IFRAME_URL') {
        console.log('[React Scan Iframe] Received REQUEST_IFRAME_URL from parent.');
        const currentUrl = window.location.href;
        window.parent.postMessage({
            type: 'IFRAME_URL_RESPONSE',
            payload: { url: currentUrl },
            requestId: request.requestId,
        }, PARENT_ORIGIN);
        console.log('[React Scan Iframe] Sent IFRAME_URL_RESPONSE to parent:', currentUrl);
    }
    // --- START: Handle Screenshot Request (Adjust Fixed Elements & Crop) ---
    else if (request.type === 'REQUEST_PAGE_SCREENSHOT') {
      // console.log('[React Scan Iframe] Received REQUEST_PAGE_SCREENSHOT (Visible + Fixed/Sticky + DPR) from parent.');
      try {
          const body = document.body;
          const documentElement = document.documentElement;

          // 1. Get viewport dimensions, scroll offsets, and pixel ratio
          const viewportWidth = documentElement.clientWidth;
          const viewportHeight = documentElement.clientHeight;
          const scrollLeft = documentElement.scrollLeft || body.scrollLeft;
          const scrollTop = documentElement.scrollTop || body.scrollTop;
          const pixelRatio = getPixelRatio(); // Get device pixel ratio

          // console.log(`[React Scan Iframe] Capture details: VpW=${viewportWidth}, VpH=${viewportHeight}, ScrollX=${scrollLeft}, ScrollY=${scrollTop}, DPR=${pixelRatio}`);

          // 2. Capture the main scrollable content (background layer) with pixel ratio
          const mainContentOptions: HtmlToImageOptions = {
              width: viewportWidth,
              height: viewportHeight,
              pixelRatio: pixelRatio, // Apply pixel ratio
              backgroundColor: '#ffffff',
              style: {
                  transform: `translate(-${scrollLeft}px, -${scrollTop}px)`,
                  width: `${Math.max(body.scrollWidth, documentElement.scrollWidth)}px`,
                  height: `${Math.max(body.scrollHeight, documentElement.scrollHeight)}px`,
                  margin: '0', padding: '0',
              },
          };
          const mainContentDataUrl = await htmlToImage.toPng(body, mainContentOptions);

          // 3. Identify visible fixed/sticky elements
          const fixedStickyElements = findVisibleFixedStickyElements();

          // 4. Capture each fixed/sticky element individually with pixel ratio
          const fixedStickyCaptures = await Promise.allSettled(
              fixedStickyElements.map(async ({ element, rect }) => {
                  try {
                      const elementOptions: HtmlToImageOptions = {
                          width: Math.ceil(rect.width),
                          height: Math.ceil(rect.height),
                          pixelRatio: pixelRatio, // Apply pixel ratio
                          backgroundColor: undefined, // Transparent background
                          style: { margin: '0', padding: '0' }
                      };
                      const dataUrl = await htmlToImage.toPng(element, elementOptions);
                      return { element, rect, dataUrl };
                  } catch (captureError) {
                      console.warn(`[React Scan Iframe] Failed to capture fixed/sticky element:`, element, captureError);
                      return null;
                  }
              })
          );

          // 5. Combine captures onto a final canvas (scaled by pixel ratio)
          const finalCanvas = document.createElement('canvas');
          // Set canvas physical dimensions (higher resolution)
          finalCanvas.width = viewportWidth * pixelRatio;
          finalCanvas.height = viewportHeight * pixelRatio;
          const ctx = finalCanvas.getContext('2d');

          if (!ctx) {
              throw new Error("Failed to get 2D context for final canvas");
          }

          // Draw the main content first (drawImage scales based on source image dimensions)
          try {
              const mainImage = await loadImage(mainContentDataUrl);
               // Ensure drawing covers the full scaled canvas
              ctx.drawImage(mainImage, 0, 0, finalCanvas.width, finalCanvas.height);
          } catch (e) {
               console.error("[React Scan Iframe] Failed to load main content image", e);
               ctx.fillStyle = '#cccccc'; // Example fallback
               ctx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
          }

          // Draw fixed/sticky elements on top, scaling positions and dimensions
          for (const result of fixedStickyCaptures) {
              if (result.status === 'fulfilled' && result.value) {
                  const { rect, dataUrl } = result.value;
                  try {
                      const fixedStickyImage = await loadImage(dataUrl);
                      // Scale draw position and size by pixelRatio
                      ctx.drawImage(
                          fixedStickyImage,
                          rect.left * pixelRatio,    // Scaled X position
                          rect.top * pixelRatio,     // Scaled Y position
                          rect.width * pixelRatio,   // Scaled width
                          rect.height * pixelRatio   // Scaled height
                      );
                  } catch (e) {
                      console.warn(`[React Scan Iframe] Failed to load or draw fixed/sticky image:`, result.value.element, e);
                  }
              }
          }

          // 6. Get final data URL (now high-resolution) and send response
          const finalDataUrl = finalCanvas.toDataURL('image/png');
          window.parent.postMessage({
              type: 'PAGE_SCREENSHOT_RESPONSE',
              payload: { dataUrl: finalDataUrl },
              requestId: request.requestId,
          }, PARENT_ORIGIN);
          // console.log('[React Scan Iframe] Sent PAGE_SCREENSHOT_RESPONSE (Visible + Fixed/Sticky + DPR) to parent.');

      } catch (error) {
          console.error('[React Scan Iframe] Error capturing composite page screenshot:', error);
          let errorMessage = 'Failed to capture composite page screenshot.';
          if (error instanceof Error) {
              errorMessage += ` Reason: ${error.message}`;
          }
          window.parent.postMessage({
              type: 'PAGE_SCREENSHOT_RESPONSE',
              error: errorMessage,
              requestId: request.requestId,
          }, PARENT_ORIGIN);
      }
  }
    // --- END: Handle Screenshot Request (Adjust Fixed Elements & Crop) ---
};


let messageListenerAdded = false;

const addMessageListener = () => {
     if (!IS_CLIENT || messageListenerAdded) {
        return;
    }
    window.addEventListener('message', handleParentMessage);
    messageListenerAdded = true;
    console.log('[React Scan Iframe] Message listener added.');
};

// --- END: MODIFIED CODE for postMessage Communication ---

// --- Original Option Handling, Initialization, Exports (Unchanged) ---
// ... (keep the rest of the file as it was previously, including start(), scan(), setOptions(), etc.) ...

function isOptionKey(key: string): key is keyof Options {
  // Use a more robust check if default options change
  const defaultKeys = Object.keys(ReactScanInternals.options.value);
  return defaultKeys.includes(key);
}


const validateOptions = (options: Partial<Options>): Partial<Options> => {
  const errors: Array<string> = [];
  const validOptions: Partial<Options> = {};

  for (const key in options) {
    if (!isOptionKey(key)) {
        if(ReactScanInternals.options.value._debug) {
           console.warn(`[React Scan] Unknown option provided during validation: "${key}"`);
        }
        continue; // Skip unknown keys strictly
    }


    const value = options[key];
    switch (key) {
      case 'enabled':
      case 'log':
      case 'showToolbar':
      case 'showNotificationCount':
      case 'dangerouslyForceRunInProduction':
      case 'trackUnnecessaryRenders': // Added this
      case 'showFPS':
        if (typeof value !== 'boolean') {
          errors.push(`- ${key} must be a boolean. Got "${value}"`);
        } else {
          validOptions[key] = value;
        }
        break;
      case 'animationSpeed':
        if (!['slow', 'fast', 'off'].includes(value as string)) {
          errors.push(
            `- Invalid animation speed "${value}". Using default "fast"`,
          );
          // Don't set invalid value
        } else {
          validOptions[key] = value as 'slow' | 'fast' | 'off';
        }
        break;
      case '_debug': // Added this
         if (value !== 'verbose' && value !== false && value !== undefined) {
             errors.push(`- _debug must be 'verbose' or false. Got "${value}"`);
         } else {
             validOptions[key] = value;
         }
         break;
      case 'onCommitStart':
      case 'onCommitFinish':
      case 'onPaintStart':
      case 'onPaintFinish':
      case 'onRender': // Keep validation for potential future use or logging
        if (value !== undefined && typeof value !== 'function') { // Allow undefined
          errors.push(`- ${key} must be a function or undefined. Got "${value}"`);
        } else {
           // Cast to avoid type errors if these are used later
          validOptions[key] = value as any;
        }
        break;
      default:
        // This case should ideally not be reached due to isOptionKey check
         if(ReactScanInternals.options.value._debug) {
           console.warn(`[React Scan] Unknown option slipped through validation: "${key}"`);
        }
    }
  }


  if (errors.length > 0) {
    console.warn(`[React Scan] Invalid options detected:\n${errors.join('\n')}`);
  }

  return validOptions;
};

export const getReport = (type?: ComponentType<unknown>) => {
  if (type) {
    // Check both maps? Or just legacy? Assuming legacy for now.
    for (const reportData of Array.from(Store.legacyReportData.values())) {
      if (reportData.type === type) {
        return reportData;
      }
    }
    // Check the new map by iterating if needed, but needs a way to map type to ID
    // Example (might be slow):
    // for (const [id, reportData] of Store.reportData.entries()) {
    //    // Need a way to get fiber from ID or type from ID
    // }
    return null;
  }
  // Return both maps or a combined representation? Returning legacy for now.
  return Store.legacyReportData;
};

export const setOptions = (userOptions: Partial<Options>) => {
  const validOptions = validateOptions(userOptions);

  if (Object.keys(validOptions).length === 0 && !userOptions.hasOwnProperty('enabled')) { // Check enabled specifically if it's the only key
      // No valid options to set, maybe log in debug mode
       if(ReactScanInternals.options.value._debug === 'verbose') {
          console.log('[React Scan] setOptions called with no valid options or only invalid options.', userOptions);
       }
      return ReactScanInternals.options.value; // Return current options
  }

  const currentOptions = ReactScanInternals.options.value;
  const showToolbarChanged = validOptions.hasOwnProperty('showToolbar') && validOptions.showToolbar !== currentOptions.showToolbar;
  const enabledChanged = validOptions.hasOwnProperty('enabled') && validOptions.enabled !== currentOptions.enabled;


  const newOptions = {
    ...currentOptions,
    ...validOptions,
  };

  const { instrumentation } = ReactScanInternals;
  if (instrumentation && validOptions.hasOwnProperty('enabled')) {
    instrumentation.isPaused.value = validOptions.enabled === false;
  }

  ReactScanInternals.options.value = newOptions;

  // Save options only if they are not the defaults or have changed
  // This prevents unnecessary localStorage writes on initial load if options are default
  // Add a check to see if the new options differ from stored ones before saving?
  // Or just save whenever setOptions is called with valid changes.
  try {
       const storableOptions: Partial<LocalStorageOptions> = {};
       for (const key in newOptions) {
           if (key !== 'onCommitStart' && key !== 'onRender' && key !== 'onCommitFinish' && key !== 'onPaintStart' && key !== 'onPaintFinish') {
            // @ts-expect-error
               storableOptions[key as keyof LocalStorageOptions] = newOptions[key as keyof LocalStorageOptions];
           }
       }
      saveLocalStorage('react-scan-options', storableOptions);
  } catch(e) {
      console.error("[React Scan] Failed to save options to localStorage", e);
  }


  // Re-initialize toolbar *only* if showToolbar explicitly changed
  // or if enabled changed from false to true and showToolbar is true
  if (showToolbarChanged || (enabledChanged && newOptions.enabled === true && newOptions.showToolbar === true)) {
    initToolbar(!!newOptions.showToolbar);
  } else if (enabledChanged && newOptions.enabled === false) {
      // If disabled, ensure toolbar is removed/cleaned up
      initToolbar(false);
  }


  return newOptions;
};

export const getOptions = () => ReactScanInternals.options;

let isProduction: boolean | null = null;
let rdtHook: ReturnType<typeof getRDTHook>;
export const getIsProduction = () => {
  if (isProduction !== null) {
    return isProduction;
  }
   if (!IS_CLIENT) return false; // Cannot determine on server

  try {
      rdtHook ??= getRDTHook();
      if (!rdtHook || !rdtHook.renderers) {
           console.warn("[React Scan] React DevTools hook not found or has no renderers. Assuming development build.");
           isProduction = false;
           return isProduction;
      }
      isProduction = false; // Default to false
      for (const renderer of rdtHook.renderers.values()) {
        const buildType = detectReactBuildType(renderer);
        if (buildType === 'production') {
          isProduction = true;
          break; // Found a production build, no need to check further
        }
      }
  } catch(e) {
      console.error("[React Scan] Error detecting React build type:", e);
      isProduction = false; // Assume dev on error
  }
  return isProduction;
};


export const start = () => {
  try {
    if (!IS_CLIENT) {
      return;
    }

    // Add the listener regardless of production status or other options
    addMessageListener();


    // Send load success message *after* listener is added, if in an iframe
    if (Store.isInIframe.value) {
        const PARENT_ORIGIN = '*'; // WARNING: Use specific origin in production!
        window.parent.postMessage({
            type: 'IFRAME_LOAD_SUCCESS',
            payload: {} // No specific payload needed for now
        }, PARENT_ORIGIN);
        console.log('[React Scan Iframe] Sent IFRAME_LOAD_SUCCESS to parent.');
    }

    const isProd = getIsProduction(); // Determine production status

    if (
      isProd &&
      !ReactScanInternals.options.value.dangerouslyForceRunInProduction
    ) {
      console.log('[React Scan] Production environment detected. React Scan disabled unless dangerouslyForceRunInProduction is set.');
      // Return here *after* adding the listener if we don't force run in prod
      return;
    }

    // Load stored options *after* the production check
    const localStorageOptions =
      readLocalStorage<LocalStorageOptions>('react-scan-options');

    let initialOptions = { ...ReactScanInternals.options.value };
    if (localStorageOptions) {
      const validLocalOptions = validateOptions(localStorageOptions);
      initialOptions = { ...initialOptions, ...validLocalOptions };
    }
    // Update the signal *once* after merging defaults and stored options
    ReactScanInternals.options.value = initialOptions;

    const options = initialOptions; // Use the merged options

    // Initialize React instrumentation if enabled
    if (options.enabled !== false) {
      initReactScanInstrumentation(() => {
        // Callback for when instrumentation is active
        initToolbar(!!options.showToolbar);
      });
    } else if (options.showToolbar === true) {
        // If scanning is disabled but toolbar is shown, init toolbar without instrumentation callback
        initToolbar(true);
    }

    // Original check for instrumentation activation delay - keep this
    if (!Store.monitor.value && IS_CLIENT) {
      setTimeout(() => {
        if (isInstrumentationActive()) return;
        console.error(
          '[React Scan] Failed to load React instrumentation. This can happen if React runs before React Scan is imported, or if React DevTools are disabled or interfering. Ensure React Scan is imported early.'
        );
      }, 5000);
    }
  } catch (e) {
    console.error('[React Scan] Error during start():', e);
  }
};


const initToolbar = (showToolbar: boolean) => {
  try {
      window.reactScanCleanupListeners?.(); // Cleanup previous listeners if any

      const windowToolbarContainer = document.getElementById('react-scan-toolbar-root');
      if (windowToolbarContainer) {
          windowToolbarContainer.remove();
          // Clear the reference in case it was cached elsewhere, though direct ID access is safer
          // window.__REACT_SCAN_TOOLBAR_CONTAINER__ = undefined;
      }


      if (!showToolbar) {
         window.reactScanCleanupListeners = undefined; // Ensure no listeners if toolbar hidden
         return; // Don't create toolbar if not needed
      }


      // Create toolbar only if shown
      const { shadowRoot } = initRootContainer(); // Ensure root container exists
      createToolbar(shadowRoot); // Render toolbar into shadow DOM

      // Start necessary listeners only when toolbar is shown
      const cleanupTimingTracking = startTimingTracking();
      const cleanupOutlineCanvas = createNotificationsOutlineCanvas();

      window.reactScanCleanupListeners = () => {
        cleanupTimingTracking();
        cleanupOutlineCanvas?.();
        // Optionally remove the toolbar container on cleanup?
        // document.getElementById('react-scan-toolbar-root')?.remove();
      };

  } catch (e) {
       console.error("[React Scan] Error initializing toolbar:", e);
       window.reactScanCleanupListeners = undefined; // Clear listeners on error
  }
};


const createNotificationsOutlineCanvas = () => {
  try {
    // Ensure it runs in the client context
    if (!IS_CLIENT) return undefined;
    const highlightRoot = document.documentElement;
    // Cleanup existing canvas before creating a new one
    const existingCanvas = highlightRoot.querySelector('canvas[style*="z-index: 2147483600"]');
    existingCanvas?.remove();

    return createHighlightCanvas(highlightRoot);
  } catch (e) {
    console.error('[React Scan] Failed to create notifications outline canvas:', e);
    return undefined; // Return undefined if creation fails
  }
};


export const scan = (options: Options = {}) => {
  setOptions(options); // Update and save options
  addMessageListener(); // Ensure listener is always added (idempotent)

  // Start instrumentation/UI based on the *updated* options
  const currentOptions = ReactScanInternals.options.value;
  if (currentOptions.enabled !== false || currentOptions.showToolbar === true) {
     start();
  } else {
      // If options explicitly disable and hide toolbar, ensure cleanup
      initToolbar(false);
      // Consider stopping instrumentation if it was running?
      // ReactScanInternals.instrumentation?.isPaused.value = true;
  }
};


export const useScan = (options: Options = {}) => {
  // This hook implies usage within a React component, likely client-side
  if (!IS_CLIENT) return; // Basic guard

  // Use effect to apply options only once on mount/options change?
  // Or just call scan directly? Calling directly might be simpler.
  scan(options); // Apply options and start/stop as needed

  // Hooks usually don't return anything for side effects like this.
  // Could return status or methods if needed later.
};


export const onRender = (
  type: unknown,
  _onRender: (fiber: Fiber, renders: Array<Render>) => void,
) => {
  // Ensure type is valid for comparison (function or class component type)
   if (!type || (typeof type !== 'function' && typeof type !== 'object')) {
      console.warn("[React Scan] Invalid type provided to onRender. Expected component type.", type);
      return;
   }


  const prevOnRender = ReactScanInternals.onRender;
  ReactScanInternals.onRender = (fiber: Fiber, renders: Array<Render>) => {
    // Call previous listener first if it exists
    prevOnRender?.(fiber, renders);
    // Use bippy's getType for consistent comparison, comparing against the provided type
    if (getType(fiber.type) === type) {
      try {
          _onRender(fiber, renders);
      } catch (e) {
          console.error("[React Scan] Error in onRender callback for type:", type, e);
      }
    }
  };
};


export const ignoredProps = new WeakSet<
  Exclude<ReactNode, undefined | null | string | number | boolean | bigint>
>();

export const ignoreScan = (node: ReactNode) => {
  // Ensure node is an object (like a React element) before adding
  if (node && typeof node === 'object') {
    ignoredProps.add(node);
  }
};


// Ensure addMessageListener is called when the module loads in a client environment
if (IS_CLIENT) {
    addMessageListener();
    // Optionally trigger start() based on some initial condition or stored options?
    // Example: Start if previously enabled and not in production (unless forced)
    // const storedOpts = readLocalStorage<LocalStorageOptions>('react-scan-options');
    // if (storedOpts?.enabled !== false && (!getIsProduction() || storedOpts?.dangerouslyForceRunInProduction)) {
    //    start();
    // }
    // Or simply rely on explicit `scan()` call by the user.
}
</file>

<file path="src/core/instrumentation.ts">
import { type Signal, signal } from '@preact/signals';
import {
  ClassComponentTag,
  type Fiber,
  type FiberRoot,
  ForwardRefTag,
  FunctionComponentTag,
  MemoComponentTag,
  type MemoizedState,
  SimpleMemoComponentTag,
  didFiberCommit,
  getDisplayName,
  getMutatedHostFibers,
  getTimings,
  getType,
  hasMemoCache,
  instrument,
  traverseContexts,
  traverseProps,
  traverseRenderedFibers,
} from 'bippy';
import { isValidElement } from 'preact';
import { isEqual } from '~core/utils';
import {
  RENDER_PHASE_STRING_TO_ENUM,
  type RenderPhase,
} from '~web/utils/outline';
import {
  collectContextChanges,
  collectPropsChanges,
  collectStateChanges,
} from '~web/views/inspector/timeline/utils';
import {
  type Change,
  type ContextChange,
  ReactScanInternals,
  type StateChange,
} from './index';

let fps = 0;
let lastTime = performance.now();
let frameCount = 0;
let initedFps = false;

const updateFPS = () => {
  frameCount++;
  const now = performance.now();
  if (now - lastTime >= 1000) {
    fps = frameCount;
    frameCount = 0;
    lastTime = now;
  }
  requestAnimationFrame(updateFPS);
};

export const getFPS = () => {
  if (!initedFps) {
    initedFps = true;
    updateFPS();
    fps = 60;
  }

  return fps;
};

export const isElementVisible = (el: Element) => {
  const style = window.getComputedStyle(el);
  return (
    style.display !== 'none' &&
    style.visibility !== 'hidden' &&
    style.contentVisibility !== 'hidden' &&
    style.opacity !== '0'
  );
};

export const isValueUnstable = (prevValue: unknown, nextValue: unknown) => {
  const prevValueString = fastSerialize(prevValue);
  const nextValueString = fastSerialize(nextValue);
  return (
    prevValueString === nextValueString &&
    unstableTypes.includes(typeof prevValue) &&
    unstableTypes.includes(typeof nextValue)
  );
};

export const isElementInViewport = (
  el: Element,
  rect = el.getBoundingClientRect(),
) => {
  const isVisible =
    rect.bottom > 0 &&
    rect.right > 0 &&
    rect.top < window.innerHeight &&
    rect.left < window.innerWidth;

  return isVisible && rect.width && rect.height;
};

export const enum ChangeReason {
  Props = 0b001,
  FunctionalState = 0b010,
  ClassState = 0b011,
  Context = 0b100,
}

export interface AggregatedChange {
  type: number; // union of AggregatedChangeReason
  unstable: boolean;
}

export interface Render {
  phase: RenderPhase;
  componentName: string | null;
  time: number | null;
  count: number;
  forget: boolean;
  changes: Array<Change>;
  unnecessary: boolean | null;
  didCommit: boolean;
  fps: number;
}

const unstableTypes = ['function', 'object'];

const cache = new WeakMap<object, string>();

export function fastSerialize(value: unknown, depth = 0): string {
  if (depth < 0) return '';

  switch (typeof value) {
    case 'function':
      return value.toString();
    case 'string':
      return value;
    case 'number':
    case 'boolean':
    case 'undefined':
      return String(value);
    case 'object':
      break;
    default:
      return String(value);
  }

  if (value === null) return 'null';

  if (cache.has(value)) {
    const cached = cache.get(value);
    if (cached !== undefined) {
      return cached;
    }
  }

  if (Array.isArray(value)) {
    const str = value.length ? `[${value.length}]` : '[]';
    cache.set(value, str);
    return str;
  }

  if (isValidElement(value)) {
    const type = getDisplayName(value.type) ?? '';
    const propCount = value.props ? Object.keys(value.props).length : 0;
    const str = `<${type} ${propCount}>`;
    cache.set(value, str);
    return str;
  }

  if (Object.getPrototypeOf(value) === Object.prototype) {
    const keys = Object.keys(value);
    const str = keys.length ? `{${keys.length}}` : '{}';
    cache.set(value, str);
    return str;
  }

  const ctor =
    value && typeof value === 'object' ? value.constructor : undefined;
  if (ctor && typeof ctor === 'function' && ctor.name) {
    const str = `${ctor.name}{}`;
    cache.set(value, str);
    return str;
  }

  const tagString = Object.prototype.toString.call(value).slice(8, -1);
  const str = `${tagString}{}`;
  cache.set(value, str);
  return str;
}

export const getPropsChanges = (fiber: Fiber) => {
  const changes: Array<Change> = [];

  const prevProps = fiber.alternate?.memoizedProps || {};
  const nextProps = fiber.memoizedProps || {};

  const allKeys = new Set([
    ...Object.keys(prevProps),
    ...Object.keys(nextProps),
  ]);
  for (const propName in allKeys) {
    // const prevValue = prevProps?.[propName];
    const nextValue = nextProps?.[propName];

    const change: Change = {
      type: ChangeReason.Props,
      name: propName,
      value: nextValue,
    };
    changes.push(change);
  }

  return changes;
};

export const getStateChanges = (fiber: Fiber): StateChange[] => {
  if (!fiber) return [];
  const changes: StateChange[] = [];

  if (
    fiber.tag === FunctionComponentTag ||
    fiber.tag === ForwardRefTag ||
    fiber.tag === SimpleMemoComponentTag ||
    fiber.tag === MemoComponentTag
  ) {
    let memoizedState: MemoizedState | null = fiber.memoizedState;
    let prevState: MemoizedState | null | undefined =
      fiber.alternate?.memoizedState;
    let index = 0;

    while (memoizedState) {
      if (memoizedState.queue && memoizedState.memoizedState !== undefined) {
        const change: StateChange = {
          type: ChangeReason.FunctionalState,
          name: index.toString(),
          value: memoizedState.memoizedState,
          prevValue: prevState?.memoizedState,
        };
        if (!isEqual(change.prevValue, change.value)) {
          changes.push(change);
        }
      }
      memoizedState = memoizedState.next;
      prevState = prevState?.next;
      index++;
    }

    return changes;
  }

  if (fiber.tag === ClassComponentTag) {
    // when we have class component fiber, memoizedState is the component state
    const change: StateChange = {
      type: ChangeReason.ClassState,
      name: 'state',
      value: fiber.memoizedState,
      prevValue: fiber.alternate?.memoizedState,
    };
    if (!isEqual(change.prevValue, change.value)) {
      changes.push(change);
    }
    return changes;
  }

  return changes;
};
interface ContextFiber {
  context: unknown; // refers to Context<T>;
  memoizedValue: unknown;
}

let lastContextId = 0;
const contextIdMap = new WeakMap<ContextFiber, number>();
const getContextId = (contextFiber: ContextFiber) => {
  const existing = contextIdMap.get(contextFiber);
  if (existing) {
    return existing;
  }
  lastContextId++;
  contextIdMap.set(contextFiber, lastContextId);
  return lastContextId;
};

function getContextChangesTraversal(
  this: Array<Change>,
  nextValue: ContextFiber | null | undefined,
  prevValue: ContextFiber | null | undefined,
): void {
  if (!nextValue || !prevValue) return;
  // const prevMemoizedValue = prevValue.memoizedValue;
  const nextMemoizedValue = nextValue.memoizedValue;

  const change: ContextChange = {
    type: ChangeReason.Context,
    name:
      (nextValue.context as { displayName: string | undefined }).displayName ??
      'Context.Provider',
    value: nextMemoizedValue,
    contextType: getContextId(nextValue.context as ContextFiber),

    // unstable: false,
  };
  this.push(change);

  // const prevValueString = fastSerialize(prevMemoizedValue);
  // const nextValueString = fastSerialize(nextMemoizedValue);

  // if (
  //   unstableTypes.includes(typeof prevMemoizedValue) &&
  //   unstableTypes.includes(typeof nextMemoizedValue) &&
  //   prevValueString === nextValueString
  // ) {
  //   change.unstable = true;
  // }
}

export const getContextChanges = (fiber: Fiber) => {
  const changes: Array<ContextChange> = [];

  // Alexis: we use bind functions so that the compiler doesn't produce
  // any closures
  traverseContexts(fiber, getContextChangesTraversal.bind(changes));

  return changes;
};

type OnRenderHandler = (fiber: Fiber, renders: Array<Render>) => void;
type OnCommitStartHandler = () => void;
type OnCommitFinishHandler = () => void;
type OnErrorHandler = (error: unknown) => void;
type IsValidFiberHandler = (fiber: Fiber) => boolean;
type OnActiveHandler = () => void;

interface InstrumentationConfig {
  onCommitStart: OnCommitStartHandler;
  isValidFiber: IsValidFiberHandler;
  onRender: OnRenderHandler;
  onCommitFinish: OnCommitFinishHandler;
  onError: OnErrorHandler;
  onActive?: OnActiveHandler;
  onPostCommitFiberRoot: () => void;
  // monitoring does not need to track changes, and it adds overhead to leave it on
  trackChanges: boolean;
  // allows monitoring to continue tracking renders even if react scan dev mode is disabled
  forceAlwaysTrackRenders?: boolean;
}

interface InstrumentationInstance {
  key: string;
  config: InstrumentationConfig;
  instrumentation: Instrumentation;
}

interface Instrumentation {
  isPaused: Signal<boolean>;
  fiberRoots: WeakSet<FiberRoot>;
}

const instrumentationInstances = new Map<string, InstrumentationInstance>();
let inited = false;

const getAllInstances = () => Array.from(instrumentationInstances.values());

interface IsRenderUnnecessaryState {
  isRequiredChange: boolean;
}

function isRenderUnnecessaryTraversal(
  this: IsRenderUnnecessaryState,
  _propsName: string,
  prevValue: unknown,
  nextValue: unknown,
): void {
  if (
    !isEqual(prevValue, nextValue) &&
    !isValueUnstable(prevValue, nextValue)
  ) {
    this.isRequiredChange = true;
  }
}

// FIXME: calculation is slow
export const isRenderUnnecessary = (fiber: Fiber) => {
  if (!didFiberCommit(fiber)) return true;

  const mutatedHostFibers = getMutatedHostFibers(fiber);
  for (const mutatedHostFiber of mutatedHostFibers) {
    const state: IsRenderUnnecessaryState = {
      isRequiredChange: false,
    };
    traverseProps(mutatedHostFiber, isRenderUnnecessaryTraversal.bind(state));
    if (state.isRequiredChange) return false;
  }
  return true;
};

// // re-implement this in new-outlines
// const shouldRunUnnecessaryRenderCheck = () => {
//   // yes, this can be condensed into one conditional, but ifs are easier to reason/build on than long boolean expressions
//   if (!ReactScanInternals.options.value.trackUnnecessaryRenders) {
//     return false;
//   }

//   // only run unnecessaryRenderCheck when monitoring is active in production if the user set dangerouslyForceRunInProduction
//   if (
//     getIsProduction() &&
//     Store.monitor.value &&
//     ReactScanInternals.options.value.dangerouslyForceRunInProduction &&
//     ReactScanInternals.options.value.trackUnnecessaryRenders
//   ) {
//     return true;
//   }

//   if (getIsProduction() && Store.monitor.value) {
//     return false;
//   }

//   return ReactScanInternals.options.value.trackUnnecessaryRenders;
// };

const TRACK_UNNECESSARY_RENDERS = false;

export interface RenderData {
  selfTime: number;
  totalTime: number;
  renderCount: number;
  lastRenderTimestamp: number;
}

export interface OldRenderData {
  count: number;
  time: number;
  renders: Array<Render>;
  displayName: string | null;
  // biome-ignore lint/suspicious/noExplicitAny: temporary type hack cause im lazy
  type: any;
  // biome-ignore lint/suspicious/noExplicitAny: temporary type hack cause im lazy
  changes?: any;
}

const RENDER_DEBOUNCE_MS = 16;

export const renderDataMap = new WeakMap<object, RenderData>();

const trackRender = (
  type: unknown,
  fiberSelfTime: number,
  fiberTotalTime: number,
  hasChanges: boolean,
  hasDomMutations: boolean,
) => {
  const currentTimestamp = Date.now();
  const existingData = renderDataMap.get(type as object);

  if (
    (hasChanges || hasDomMutations) &&
    (!existingData ||
      currentTimestamp - (existingData.lastRenderTimestamp || 0) >
        RENDER_DEBOUNCE_MS)
  ) {
    const renderData: RenderData = existingData || {
      selfTime: 0,
      totalTime: 0,
      renderCount: 0,
      lastRenderTimestamp: currentTimestamp,
    };

    renderData.renderCount = (renderData.renderCount || 0) + 1;
    renderData.selfTime = fiberSelfTime || 0;
    renderData.totalTime = fiberTotalTime || 0;
    renderData.lastRenderTimestamp = currentTimestamp;

    renderDataMap.set(type as object, { ...renderData });
  }
};

export const createInstrumentation = (
  instanceKey: string,
  config: InstrumentationConfig,
) => {
  const instrumentation: Instrumentation = {
    // this will typically be false, but in cases where a user provides showToolbar: true, this will be true
    isPaused: signal(!ReactScanInternals.options.value.enabled),
    fiberRoots: new WeakSet<FiberRoot>(),
  };
  instrumentationInstances.set(instanceKey, {
    key: instanceKey,
    config,
    instrumentation,
  });
  if (!inited) {
    inited = true;

    instrument({
      name: 'react-scan',
      onActive: config.onActive,
      onCommitFiberRoot(_rendererID, root) {
        instrumentation.fiberRoots.add(root);
        // for now we always track everything for notifications, it may be worth it to make this configurable
        // if (
        //   ReactScanInternals.instrumentation?.isPaused.value &&
        //   (Store.inspectState.value.kind === "inspect-off" ||
        //     Store.inspectState.value.kind === "uninitialized") &&
        //   !config.forceAlwaysTrackRenders
        // ) {
        //   return;
        // }
        const allInstances = getAllInstances();
        for (const instance of allInstances) {
          instance.config.onCommitStart();
        }

        traverseRenderedFibers(
          root.current,
          (fiber: Fiber, phase: 'mount' | 'update' | 'unmount') => {
            const type = getType(fiber.type);
            if (!type) return null;

            const allInstances = getAllInstances();
            const validInstancesIndicies: Array<number> = [];
            for (let i = 0, len = allInstances.length; i < len; i++) {
              const instance = allInstances[i];
              if (!instance.config.isValidFiber(fiber)) continue;
              validInstancesIndicies.push(i);
            }
            if (!validInstancesIndicies.length) return null;

            const changes: Array<Change> = [];

            if (allInstances.some((instance) => instance.config.trackChanges)) {
              const changesProps = collectPropsChanges(fiber).changes;
              const changesState = collectStateChanges(fiber).changes;
              const changesContext = collectContextChanges(fiber).changes;

              changes.push.apply(
                null,
                changesProps.map(
                  (change) =>
                    ({
                      type: ChangeReason.Props,
                      name: change.name,
                      value: change.value,
                    }) as Change,
                ),
              );

              for (const change of changesState) {
                if (fiber.tag === ClassComponentTag) {
                  changes.push({
                    type: ChangeReason.ClassState,
                    name: change.name.toString(),
                    value: change.value,
                  } as Change);
                } else {
                  changes.push({
                    type: ChangeReason.FunctionalState,
                    name: change.name.toString(),
                    value: change.value,
                  } as Change);
                }
              }

              changes.push.apply(
                null,
                changesContext.map(
                  (change) =>
                    ({
                      type: ChangeReason.Context,
                      name: change.name,
                      value: change.value,
                      contextType: Number(change.contextType),
                    }) as Change,
                ),
              );
            }

            const { selfTime: fiberSelfTime, totalTime: fiberTotalTime } =
              getTimings(fiber);

            const fps = getFPS();
            const render: Render = {
              phase: RENDER_PHASE_STRING_TO_ENUM[phase],
              componentName: getDisplayName(type),
              count: 1,
              changes,
              time: fiberSelfTime,
              forget: hasMemoCache(fiber),
              // todo: allow this to be toggle-able through toolbar
              // todo: performance optimization: if the last fiber measure was very off screen, do not run isRenderUnnecessary
              unnecessary: TRACK_UNNECESSARY_RENDERS
                ? isRenderUnnecessary(fiber)
                : null,
              didCommit: didFiberCommit(fiber),
              fps,
            };

            // First, determine if this is a real render we should track
            const hasChanges = changes.length > 0;
            const hasDomMutations = getMutatedHostFibers(fiber).length > 0;

            if (phase === 'update') {
              trackRender(
                type,
                fiberSelfTime,
                fiberTotalTime,
                hasChanges,
                hasDomMutations,
              );
            }

            for (let i = 0, len = validInstancesIndicies.length; i < len; i++) {
              const index = validInstancesIndicies[i];
              const instance = allInstances[index];
              instance.config.onRender(fiber, [render]);
            }
          },
        );

        for (const instance of allInstances) {
          instance.config.onCommitFinish();
        }
      },
      onPostCommitFiberRoot() {
        const allInstances = getAllInstances();
        for (const instance of allInstances) {
          instance.config.onPostCommitFiberRoot();
        }
      },
    });
  }
  return instrumentation;
};
</file>

<file path="src/core/utils.ts">
// @ts-nocheck
import { type Fiber, getType } from 'bippy';
// import type { ComponentType } from 'preact';
import { ReactScanInternals } from '~core/index';
import type { AggregatedRender } from '~web/utils/outline';
import type { AggregatedChange, Render } from './instrumentation';

export const aggregateChanges = (
  changes: Array<Change>,
  prevAggregatedChange?: AggregatedChange,
) => {
  const newChange = {
    type: prevAggregatedChange?.type ?? 0,
    unstable: prevAggregatedChange?.unstable ?? false,
  };
  for (const change of changes) {
    newChange.type |= change.type;
    newChange.unstable = newChange.unstable || (change.unstable ?? false);
  }

  return newChange;
};

export const joinAggregations = ({
  from,
  to,
}: {
  from: AggregatedRender;
  to: AggregatedRender;
}) => {
  to.changes.type |= from.changes.type;
  to.changes.unstable = to.changes.unstable || from.changes.unstable;
  to.aggregatedCount += 1;
  to.didCommit = to.didCommit || from.didCommit;
  to.forget = to.forget || from.forget;
  to.fps = to.fps + from.fps;
  to.phase |= from.phase;
  to.time = (to.time ?? 0) + (from.time ?? 0);

  to.unnecessary = to.unnecessary || from.unnecessary;
};

export const aggregateRender = (
  newRender: Render,
  prevAggregated: AggregatedRender,
) => {
  prevAggregated.changes = aggregateChanges(
    newRender.changes,
    prevAggregated.changes,
  );
  prevAggregated.aggregatedCount += 1;
  prevAggregated.didCommit = prevAggregated.didCommit || newRender.didCommit;
  prevAggregated.forget = prevAggregated.forget || newRender.forget;
  prevAggregated.fps = prevAggregated.fps + newRender.fps;
  prevAggregated.phase |= newRender.phase;
  prevAggregated.time = (prevAggregated.time ?? 0) + (newRender.time ?? 0);

  prevAggregated.unnecessary =
    prevAggregated.unnecessary || newRender.unnecessary;
};

function descending(a: number, b: number): number {
  return b - a;
}

interface ComponentData {
  name: string;
  forget: boolean;
  time: number;
}

function getComponentGroupNames(group: ComponentData[]): string {
  let result = group[0].name;

  const len = group.length;
  const max = Math.min(4, len);

  for (let i = 1; i < max; i++) {
    result += `, ${group[i].name}`;
  }

  return result;
}

function getComponentGroupTotalTime(group: ComponentData[]): number {
  let result = group[0].time;

  for (let i = 1, len = group.length; i < len; i++) {
    result += group[i].time;
  }

  return result;
}

function componentGroupHasForget(group: ComponentData[]): boolean {
  for (let i = 0, len = group.length; i < len; i++) {
    if (group[i].forget) {
      return true;
    }
  }
  return false;
}

export const getLabelText = (
  groupedAggregatedRenders: Array<AggregatedRender>,
) => {
  let labelText = '';

  const componentsByCount = new Map<
    number,
    Array<{ name: string; forget: boolean; time: number }>
  >();

  for (const aggregatedRender of groupedAggregatedRenders) {
    const { forget, time, aggregatedCount, name } = aggregatedRender;
    if (!componentsByCount.has(aggregatedCount)) {
      componentsByCount.set(aggregatedCount, []);
    }
    const components = componentsByCount.get(aggregatedCount);
    if (components) {
      components.push({ name, forget, time: time ?? 0 });
    }
  }

  const sortedCounts = Array.from(componentsByCount.keys()).sort(descending);

  const parts: Array<string> = [];
  let cumulativeTime = 0;
  for (const count of sortedCounts) {
    const componentGroup = componentsByCount.get(count);
    if (!componentGroup) continue;

    let text = getComponentGroupNames(componentGroup);
    const totalTime = getComponentGroupTotalTime(componentGroup);
    const hasForget = componentGroupHasForget(componentGroup);

    cumulativeTime += totalTime;

    if (componentGroup.length > 4) {
      text += '';
    }

    if (count > 1) {
      text += `  ${count}`;
    }

    if (hasForget) {
      text = `${text}`;
    }

    parts.push(text);
  }

  labelText = parts.join(', ');

  if (!labelText.length) return null;

  if (labelText.length > 40) {
    labelText = `${labelText.slice(0, 40)}`;
  }

  if (cumulativeTime >= 0.01) {
    labelText += ` (${Number(cumulativeTime.toFixed(2))}ms)`;
  }

  return labelText;
};

export const updateFiberRenderData = (fiber: Fiber, renders: Array<Render>) => {
  ReactScanInternals.options.value.onRender?.(fiber, renders);
  const type = getType(fiber.type) || fiber.type;
  if (type && (typeof type === 'function' || typeof type === 'object')) {
    const renderData = (type.renderData || {
      count: 0,
      time: 0,
      renders: [],
    }) as RenderData;
    const firstRender = renders[0];
    renderData.count += firstRender.count;
    renderData.time += firstRender.time ?? 0;
    renderData.renders.push(firstRender);
    type.renderData = renderData;
  }
};

export interface RenderData {
  count: number;
  time: number;
  renders: Array<Render>;
  displayName: string | null;
  type: unknown;
  changes?: Array<RenderChange>;
}

export function isEqual(a: unknown, b: unknown): boolean {
  return a === b || (a !== a && b !== b);
}

export const playNotificationSound = (audioContext: AudioContext) => {
  const oscillator = audioContext.createOscillator();
  const gainNode = audioContext.createGain();

  oscillator.connect(gainNode);
  gainNode.connect(audioContext.destination);

  const options = {
    type: 'sine' as OscillatorType,
    freq: [
      392,
      //  523.25,
      600,
      //  659.25
    ],
    duration: 0.3,
    gain: 0.12,
  };

  const frequencies = options.freq;
  const timePerNote = options.duration / frequencies.length;

  frequencies.forEach((freq, i) => {
    oscillator.frequency.setValueAtTime(
      freq,
      audioContext.currentTime + i * timePerNote,
    );
  });

  oscillator.type = options.type;
  gainNode.gain.setValueAtTime(options.gain, audioContext.currentTime);

  gainNode.gain.setTargetAtTime(
    0,
    audioContext.currentTime + options.duration * 0.7,
    0.05,
  );

  oscillator.start();
  oscillator.stop(audioContext.currentTime + options.duration);
};
</file>

<file path="src/html-to-image/apply-style.ts">
import type { Options } from './types'

export function applyStyle<T extends HTMLElement>(
  node: T,
  options: Options,
): T {
  const { style } = node

  if (options.backgroundColor) {
    style.backgroundColor = options.backgroundColor
  }

  if (options.width) {
    style.width = `${options.width}px`
  }

  if (options.height) {
    style.height = `${options.height}px`
  }

  const manual = options.style
  if (manual != null) {
    Object.keys(manual).forEach((key: any) => {
      style[key] = manual[key] as string
    })
  }

  return node
}
</file>

<file path="src/html-to-image/clone-node.ts">
import type { Options } from './types'
import { clonePseudoElements } from './clone-pseudos'
import {
  createImage,
  toArray,
  isInstanceOfElement,
  getStyleProperties,
} from './util'
import { getMimeType } from './mimes'
import { resourceToDataURL } from './dataurl'

async function cloneCanvasElement(canvas: HTMLCanvasElement) {
  const dataURL = canvas.toDataURL()
  if (dataURL === 'data:,') {
    return canvas.cloneNode(false) as HTMLCanvasElement
  }
  return createImage(dataURL)
}

async function cloneVideoElement(video: HTMLVideoElement, options: Options) {
  if (video.currentSrc) {
    const canvas = document.createElement('canvas')
    const ctx = canvas.getContext('2d')
    canvas.width = video.clientWidth
    canvas.height = video.clientHeight
    ctx?.drawImage(video, 0, 0, canvas.width, canvas.height)
    const dataURL = canvas.toDataURL()
    return createImage(dataURL)
  }

  const poster = video.poster
  const contentType = getMimeType(poster)
  const dataURL = await resourceToDataURL(poster, contentType, options)
  return createImage(dataURL)
}

async function cloneIFrameElement(iframe: HTMLIFrameElement, options: Options) {
  try {
    if (iframe?.contentDocument?.body) {
      return (await cloneNode(
        iframe.contentDocument.body,
        options,
        true,
      )) as HTMLBodyElement
    }
  } catch {
    // Failed to clone iframe
  }

  return iframe.cloneNode(false) as HTMLIFrameElement
}

async function cloneSingleNode<T extends HTMLElement>(
  node: T,
  options: Options,
): Promise<HTMLElement> {
  if (isInstanceOfElement(node, HTMLCanvasElement)) {
    return cloneCanvasElement(node)
  }

  if (isInstanceOfElement(node, HTMLVideoElement)) {
    return cloneVideoElement(node, options)
  }

  if (isInstanceOfElement(node, HTMLIFrameElement)) {
    return cloneIFrameElement(node, options)
  }

  return node.cloneNode(isSVGElement(node)) as T
}

const isSlotElement = (node: HTMLElement): node is HTMLSlotElement =>
  node.tagName != null && node.tagName.toUpperCase() === 'SLOT'

const isSVGElement = (node: HTMLElement): node is HTMLSlotElement =>
  node.tagName != null && node.tagName.toUpperCase() === 'SVG'

async function cloneChildren<T extends HTMLElement>(
  nativeNode: T,
  clonedNode: T,
  options: Options,
): Promise<T> {
  if (isSVGElement(clonedNode)) {
    return clonedNode
  }

  let children: T[] = []

  if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {
    children = toArray<T>(nativeNode.assignedNodes())
  } else if (
    isInstanceOfElement(nativeNode, HTMLIFrameElement) &&
    nativeNode.contentDocument?.body
  ) {
    children = toArray<T>(nativeNode.contentDocument.body.childNodes)
  } else {
    children = toArray<T>((nativeNode.shadowRoot ?? nativeNode).childNodes)
  }

  if (
    children.length === 0 ||
    isInstanceOfElement(nativeNode, HTMLVideoElement)
  ) {
    return clonedNode
  }

  await children.reduce(
    (deferred, child) =>
      deferred
        .then(() => cloneNode(child, options))
        .then((clonedChild: HTMLElement | null) => {
          if (clonedChild) {
            clonedNode.appendChild(clonedChild)
          }
        }),
    Promise.resolve(),
  )

  return clonedNode
}

function cloneCSSStyle<T extends HTMLElement>(
  nativeNode: T,
  clonedNode: T,
  options: Options,
) {
  const targetStyle = clonedNode.style
  if (!targetStyle) {
    return
  }

  const sourceStyle = window.getComputedStyle(nativeNode)
  if (sourceStyle.cssText) {
    targetStyle.cssText = sourceStyle.cssText
    targetStyle.transformOrigin = sourceStyle.transformOrigin
  } else {
    getStyleProperties(options).forEach((name) => {
      let value = sourceStyle.getPropertyValue(name)
      if (name === 'font-size' && value.endsWith('px')) {
        const reducedFont =
          Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1
        value = `${reducedFont}px`
      }

      if (
        isInstanceOfElement(nativeNode, HTMLIFrameElement) &&
        name === 'display' &&
        value === 'inline'
      ) {
        value = 'block'
      }

      if (name === 'd' && clonedNode.getAttribute('d')) {
        value = `path(${clonedNode.getAttribute('d')})`
      }

      targetStyle.setProperty(
        name,
        value,
        sourceStyle.getPropertyPriority(name),
      )
    })
  }
}

function cloneInputValue<T extends HTMLElement>(nativeNode: T, clonedNode: T) {
  if (isInstanceOfElement(nativeNode, HTMLTextAreaElement)) {
    clonedNode.innerHTML = nativeNode.value
  }

  if (isInstanceOfElement(nativeNode, HTMLInputElement)) {
    clonedNode.setAttribute('value', nativeNode.value)
  }
}

function cloneSelectValue<T extends HTMLElement>(nativeNode: T, clonedNode: T) {
  if (isInstanceOfElement(nativeNode, HTMLSelectElement)) {
    const clonedSelect = clonedNode as any as HTMLSelectElement
    const selectedOption = Array.from(clonedSelect.children).find(
      (child) => nativeNode.value === child.getAttribute('value'),
    )

    if (selectedOption) {
      selectedOption.setAttribute('selected', '')
    }
  }
}

function decorate<T extends HTMLElement>(
  nativeNode: T,
  clonedNode: T,
  options: Options,
): T {
  if (isInstanceOfElement(clonedNode, Element)) {
    cloneCSSStyle(nativeNode, clonedNode, options)
    clonePseudoElements(nativeNode, clonedNode, options)
    cloneInputValue(nativeNode, clonedNode)
    cloneSelectValue(nativeNode, clonedNode)
  }

  return clonedNode
}

async function ensureSVGSymbols<T extends HTMLElement>(
  clone: T,
  options: Options,
) {
  const uses = clone.querySelectorAll ? clone.querySelectorAll('use') : []
  if (uses.length === 0) {
    return clone
  }

  const processedDefs: { [key: string]: HTMLElement } = {}
  for (let i = 0; i < uses.length; i++) {
    const use = uses[i]
    const id = use.getAttribute('xlink:href')
    if (id) {
      const exist = clone.querySelector(id)
      const definition = document.querySelector(id) as HTMLElement
      if (!exist && definition && !processedDefs[id]) {
        // eslint-disable-next-line no-await-in-loop
        processedDefs[id] = (await cloneNode(definition, options, true))!
      }
    }
  }

  const nodes = Object.values(processedDefs)
  if (nodes.length) {
    const ns = 'http://www.w3.org/1999/xhtml'
    const svg = document.createElementNS(ns, 'svg')
    svg.setAttribute('xmlns', ns)
    svg.style.position = 'absolute'
    svg.style.width = '0'
    svg.style.height = '0'
    svg.style.overflow = 'hidden'
    svg.style.display = 'none'

    const defs = document.createElementNS(ns, 'defs')
    svg.appendChild(defs)

    for (let i = 0; i < nodes.length; i++) {
      defs.appendChild(nodes[i])
    }

    clone.appendChild(svg)
  }

  return clone
}

export async function cloneNode<T extends HTMLElement>(
  node: T,
  options: Options,
  isRoot?: boolean,
): Promise<T | null> {
  if (!isRoot && options.filter && !options.filter(node)) {
    return null
  }

  return Promise.resolve(node)
    .then((clonedNode) => cloneSingleNode(clonedNode, options) as Promise<T>)
    .then((clonedNode) => cloneChildren(node, clonedNode, options))
    .then((clonedNode) => decorate(node, clonedNode, options))
    .then((clonedNode) => ensureSVGSymbols(clonedNode, options))
}
</file>

<file path="src/html-to-image/clone-pseudos.ts">
import type { Options } from './types'
import { uuid, getStyleProperties } from './util'

type Pseudo = ':before' | ':after'

function formatCSSText(style: CSSStyleDeclaration) {
  const content = style.getPropertyValue('content')
  return `${style.cssText} content: '${content.replace(/'|"/g, '')}';`
}

function formatCSSProperties(style: CSSStyleDeclaration, options: Options) {
  return getStyleProperties(options)
    .map((name) => {
      const value = style.getPropertyValue(name)
      const priority = style.getPropertyPriority(name)

      return `${name}: ${value}${priority ? ' !important' : ''};`
    })
    .join(' ')
}

function getPseudoElementStyle(
  className: string,
  pseudo: Pseudo,
  style: CSSStyleDeclaration,
  options: Options,
): Text {
  const selector = `.${className}:${pseudo}`
  const cssText = style.cssText
    ? formatCSSText(style)
    : formatCSSProperties(style, options)

  return document.createTextNode(`${selector}{${cssText}}`)
}

function clonePseudoElement<T extends HTMLElement>(
  nativeNode: T,
  clonedNode: T,
  pseudo: Pseudo,
  options: Options,
) {
  const style = window.getComputedStyle(nativeNode, pseudo)
  const content = style.getPropertyValue('content')
  if (content === '' || content === 'none') {
    return
  }

  const className = uuid()
  try {
    clonedNode.className = `${clonedNode.className} ${className}`
  } catch (err) {
    return
  }

  const styleElement = document.createElement('style')
  styleElement.appendChild(
    getPseudoElementStyle(className, pseudo, style, options),
  )
  clonedNode.appendChild(styleElement)
}

export function clonePseudoElements<T extends HTMLElement>(
  nativeNode: T,
  clonedNode: T,
  options: Options,
) {
  clonePseudoElement(nativeNode, clonedNode, ':before', options)
  clonePseudoElement(nativeNode, clonedNode, ':after', options)
}
</file>

<file path="src/html-to-image/dataurl.ts">
import { Options } from './types'

function getContentFromDataUrl(dataURL: string) {
  return dataURL.split(/,/)[1]
}

export function isDataUrl(url: string) {
  return url.search(/^(data:)/) !== -1
}

export function makeDataUrl(content: string, mimeType: string) {
  return `data:${mimeType};base64,${content}`
}

export async function fetchAsDataURL<T>(
  url: string,
  init: RequestInit | undefined,
  process: (data: { result: string; res: Response }) => T,
): Promise<T> {
  const res = await fetch(url, init)
  if (res.status === 404) {
    throw new Error(`Resource "${res.url}" not found`)
  }
  const blob = await res.blob()
  return new Promise<T>((resolve, reject) => {
    const reader = new FileReader()
    reader.onerror = reject
    reader.onloadend = () => {
      try {
        resolve(process({ res, result: reader.result as string }))
      } catch (error) {
        reject(error)
      }
    }

    reader.readAsDataURL(blob)
  })
}

const cache: { [url: string]: string } = {}

function getCacheKey(
  url: string,
  contentType: string | undefined,
  includeQueryParams: boolean | undefined,
) {
  let key = url.replace(/\?.*/, '')

  if (includeQueryParams) {
    key = url
  }

  // font resource
  if (/ttf|otf|eot|woff2?/i.test(key)) {
    key = key.replace(/.*\//, '')
  }

  return contentType ? `[${contentType}]${key}` : key
}

export async function resourceToDataURL(
  resourceUrl: string,
  contentType: string | undefined,
  options: Options,
) {
  const cacheKey = getCacheKey(
    resourceUrl,
    contentType,
    options.includeQueryParams,
  )

  if (cache[cacheKey] != null) {
    return cache[cacheKey]
  }

  // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache
  if (options.cacheBust) {
    // eslint-disable-next-line no-param-reassign
    resourceUrl += (/\?/.test(resourceUrl) ? '&' : '?') + new Date().getTime()
  }

  let dataURL: string
  try {
    const content = await fetchAsDataURL(
      resourceUrl,
      options.fetchRequestInit,
      ({ res, result }) => {
        if (!contentType) {
          // eslint-disable-next-line no-param-reassign
          contentType = res.headers.get('Content-Type') || ''
        }
        return getContentFromDataUrl(result)
      },
    )
    dataURL = makeDataUrl(content, contentType!)
  } catch (error: any) {
    dataURL = options.imagePlaceholder || ''

    let msg = `Failed to fetch resource: ${resourceUrl}`
    if (error) {
      msg = typeof error === 'string' ? error : error.message
    }

    if (msg) {
      console.warn(msg)
    }
  }

  cache[cacheKey] = dataURL
  return dataURL
}
</file>

<file path="src/html-to-image/embed-images.ts">
import { Options } from './types'
import { embedResources } from './embed-resources'
import { toArray, isInstanceOfElement } from './util'
import { isDataUrl, resourceToDataURL } from './dataurl'
import { getMimeType } from './mimes'

async function embedProp(
  propName: string,
  node: HTMLElement,
  options: Options,
) {
  const propValue = node.style?.getPropertyValue(propName)
  if (propValue) {
    const cssString = await embedResources(propValue, null, options)
    node.style.setProperty(
      propName,
      cssString,
      node.style.getPropertyPriority(propName),
    )
    return true
  }
  return false
}

async function embedBackground<T extends HTMLElement>(
  clonedNode: T,
  options: Options,
) {
  ;(await embedProp('background', clonedNode, options)) ||
    (await embedProp('background-image', clonedNode, options))
  ;(await embedProp('mask', clonedNode, options)) ||
    (await embedProp('-webkit-mask', clonedNode, options)) ||
    (await embedProp('mask-image', clonedNode, options)) ||
    (await embedProp('-webkit-mask-image', clonedNode, options))
}

async function embedImageNode<T extends HTMLElement | SVGImageElement>(
  clonedNode: T,
  options: Options,
) {
  const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement);

  if (
    !(isImageElement && !isDataUrl(clonedNode.src)) &&
    !(
      isInstanceOfElement(clonedNode, SVGImageElement) &&
      !isDataUrl(clonedNode.href.baseVal)
    )
  ) {
    return;
  }

  const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal;

  // resourceToDataURL handles initial fetch errors and returns a fallback
  const dataURL = await resourceToDataURL(url, getMimeType(url), options);

  // Wait for the browser to process the assigned dataURL (or fallback)
  await new Promise((resolve, reject) => { // Keep reject for custom handler flexibility
    clonedNode.onload = resolve;
    clonedNode.onerror = options.onImageErrorHandler
      ? (...attributes) => { // If user provided a handler
          try {
            // Let the custom handler decide whether to resolve or reject
             Promise.resolve(options.onImageErrorHandler!(...attributes))
                .then(resolve) // Resolve if the handler resolves/returns non-promise
                .catch(reject); // Reject if the handler throws/rejects
          } catch (error) {
            console.error("[html-to-image] Error in custom onImageErrorHandler:", error);
            // If the handler itself throws, reject to signal the handler failed
            reject(error);
          }
        }
      : () => { // <-- Default case: Changed from reject to resolve
          console.warn(`[html-to-image] Failed to load image data URL (or placeholder) for: ${url}. Proceeding anyway.`);
          resolve(undefined); // Resolve to allow the process to continue
        };

    // Assign the dataURL (could be original or fallback)
    const image = clonedNode as HTMLImageElement;
    if (image.decode) {
       // Use decode for potentially better performance/control, but still resolve on error
       image.decode().then(resolve).catch(() => {
           console.warn(`[html-to-image] Image decode() failed for: ${url}. Proceeding anyway.`);
           resolve(undefined); // Resolve even if decode fails
       });
    }

    if (image.loading === 'lazy') {
      image.loading = 'eager';
    }

    if (isImageElement) {
      clonedNode.srcset = ''; // Clear srcset as we are using src
      clonedNode.src = dataURL;
    } else {
      clonedNode.href.baseVal = dataURL;
    }

    // Safety timeout in case load/error/decode events never fire
    const safetyTimeout = setTimeout(() => {
        console.warn(`[html-to-image] Image load timeout for ${url}. Proceeding.`);
        // Ensure listeners are removed before resolving to avoid potential double resolves
        clonedNode.removeEventListener('load', clearSafetyTimeout);
        clonedNode.removeEventListener('error', clearSafetyTimeout);
        resolve(undefined);
    }, 5000); // 5-second timeout

    const clearSafetyTimeout = () => clearTimeout(safetyTimeout);
    clonedNode.addEventListener('load', clearSafetyTimeout, { once: true });
    clonedNode.addEventListener('error', clearSafetyTimeout, { once: true });
    // No need to add listener for decode, its promise handles completion/error

  }); // End of Promise
} // End of embedImageNode

async function embedChildren<T extends HTMLElement>(
  clonedNode: T,
  options: Options,
) {
  const children = toArray<HTMLElement>(clonedNode.childNodes)
  const deferreds = children.map((child) => embedImages(child, options))
  await Promise.all(deferreds).then(() => clonedNode)
}

export async function embedImages<T extends HTMLElement>(
  clonedNode: T,
  options: Options,
) {
  if (isInstanceOfElement(clonedNode, Element)) {
    await embedBackground(clonedNode, options)
    await embedImageNode(clonedNode, options)
    await embedChildren(clonedNode, options)
  }
}
</file>

<file path="src/html-to-image/embed-resources.ts">
import { Options } from './types'
import { resolveUrl } from './util'
import { getMimeType } from './mimes'
import { isDataUrl, makeDataUrl, resourceToDataURL } from './dataurl'

const URL_REGEX = /url\((['"]?)([^'"]+?)\1\)/g
const URL_WITH_FORMAT_REGEX = /url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g
const FONT_SRC_REGEX = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g

function toRegex(url: string): RegExp {
  // eslint-disable-next-line no-useless-escape
  const escaped = url.replace(/([.*+?^${}()|\[\]\/\\])/g, '\\$1')
  return new RegExp(`(url\\(['"]?)(${escaped})(['"]?\\))`, 'g')
}

export function parseURLs(cssText: string): string[] {
  const urls: string[] = []

  cssText.replace(URL_REGEX, (raw, quotation, url) => {
    urls.push(url)
    return raw
  })

  return urls.filter((url) => !isDataUrl(url))
}

export async function embed(
  cssText: string,
  resourceURL: string,
  baseURL: string | null,
  options: Options,
  getContentFromUrl?: (url: string) => Promise<string>,
): Promise<string> {
  try {
    const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL
    const contentType = getMimeType(resourceURL)
    let dataURL: string
    if (getContentFromUrl) {
      const content = await getContentFromUrl(resolvedURL)
      dataURL = makeDataUrl(content, contentType)
    } else {
      dataURL = await resourceToDataURL(resolvedURL, contentType, options)
    }
    return cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`)
  } catch (error) {
    // pass
  }
  return cssText
}

function filterPreferredFontFormat(
  str: string,
  { preferredFontFormat }: Options,
): string {
  return !preferredFontFormat
    ? str
    : str.replace(FONT_SRC_REGEX, (match: string) => {
        // eslint-disable-next-line no-constant-condition
        while (true) {
          const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || []
          if (!format) {
            return ''
          }

          if (format === preferredFontFormat) {
            return `src: ${src};`
          }
        }
      })
}

export function shouldEmbed(url: string): boolean {
  return url.search(URL_REGEX) !== -1
}

export async function embedResources(
  cssText: string,
  baseUrl: string | null,
  options: Options,
): Promise<string> {
  if (!shouldEmbed(cssText)) {
    return cssText
  }

  const filteredCSSText = filterPreferredFontFormat(cssText, options)
  const urls = parseURLs(filteredCSSText)
  return urls.reduce(
    (deferred, url) =>
      deferred.then((css) => embed(css, url, baseUrl, options)),
    Promise.resolve(filteredCSSText),
  )
}
</file>

<file path="src/html-to-image/embed-webfonts.ts">
import type { Options } from './types'
import { toArray } from './util'
import { fetchAsDataURL } from './dataurl'
import { shouldEmbed, embedResources } from './embed-resources'

interface Metadata {
  url: string
  cssText: string
}

const cssFetchCache: { [href: string]: Metadata } = {}

async function fetchCSS(url: string) {
  let cache = cssFetchCache[url]
  if (cache != null) {
    return cache
  }

  const res = await fetch(url)
  const cssText = await res.text()
  cache = { url, cssText }

  cssFetchCache[url] = cache

  return cache
}

async function embedFonts(data: Metadata, options: Options): Promise<string> {
  let cssText = data.cssText
  const regexUrl = /url\(["']?([^"')]+)["']?\)/g
  const fontLocs = cssText.match(/url\([^)]+\)/g) || []
  const loadFonts = fontLocs.map(async (loc: string) => {
    let url = loc.replace(regexUrl, '$1')
    if (!url.startsWith('https://')) {
      url = new URL(url, data.url).href
    }

    return fetchAsDataURL<[string, string]>(
      url,
      options.fetchRequestInit,
      ({ result }) => {
        cssText = cssText.replace(loc, `url(${result})`)
        return [loc, result]
      },
    )
  })

  return Promise.all(loadFonts).then(() => cssText)
}

function parseCSS(source: string) {
  if (source == null) {
    return []
  }

  const result: string[] = []
  const commentsRegex = /(\/\*[\s\S]*?\*\/)/gi
  // strip out comments
  let cssText = source.replace(commentsRegex, '')

  // eslint-disable-next-line prefer-regex-literals
  const keyframesRegex = new RegExp(
    '((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})',
    'gi',
  )

  // eslint-disable-next-line no-constant-condition
  while (true) {
    const matches = keyframesRegex.exec(cssText)
    if (matches === null) {
      break
    }
    result.push(matches[0])
  }
  cssText = cssText.replace(keyframesRegex, '')

  const importRegex = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi
  // to match css & media queries together
  const combinedCSSRegex =
    '((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]' +
    '*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})'
  // unified regex
  const unifiedRegex = new RegExp(combinedCSSRegex, 'gi')

  // eslint-disable-next-line no-constant-condition
  while (true) {
    let matches = importRegex.exec(cssText)
    if (matches === null) {
      matches = unifiedRegex.exec(cssText)
      if (matches === null) {
        break
      } else {
        importRegex.lastIndex = unifiedRegex.lastIndex
      }
    } else {
      unifiedRegex.lastIndex = importRegex.lastIndex
    }
    result.push(matches[0])
  }

  return result
}

async function getCSSRules(
  styleSheets: CSSStyleSheet[],
  options: Options,
): Promise<CSSStyleRule[]> {
  const ret: CSSStyleRule[] = []
  const deferreds: Promise<number | void>[] = []

  // First loop inlines imports
  styleSheets.forEach((sheet) => {
    if ('cssRules' in sheet) {
      try {
        toArray<CSSRule>(sheet.cssRules || []).forEach((item, index) => {
          if (item.type === CSSRule.IMPORT_RULE) {
            let importIndex = index + 1
            const url = (item as CSSImportRule).href
            const deferred = fetchCSS(url)
              .then((metadata) => embedFonts(metadata, options))
              .then((cssText) =>
                parseCSS(cssText).forEach((rule) => {
                  try {
                    sheet.insertRule(
                      rule,
                      rule.startsWith('@import')
                        ? (importIndex += 1)
                        : sheet.cssRules.length,
                    )
                  } catch (error) {
                    console.error('Error inserting rule from remote css', {
                      rule,
                      error,
                    })
                  }
                }),
              )
              .catch((e) => {
                console.error('Error loading remote css', e.toString())
              })

            deferreds.push(deferred)
          }
        })
      } catch (e) {
        const inline =
          styleSheets.find((a) => a.href == null) || document.styleSheets[0]
        if (sheet.href != null) {
          deferreds.push(
            fetchCSS(sheet.href)
              .then((metadata) => embedFonts(metadata, options))
              .then((cssText) =>
                parseCSS(cssText).forEach((rule) => {
                  inline.insertRule(rule, inline.cssRules.length)
                }),
              )
              .catch((err: unknown) => {
                console.error('Error loading remote stylesheet', err)
              }),
          )
        }
        console.error('Error inlining remote css file', e)
      }
    }
  })

  return Promise.all(deferreds).then(() => {
    // Second loop parses rules
    styleSheets.forEach((sheet) => {
      if ('cssRules' in sheet) {
        try {
          toArray<CSSStyleRule>(sheet.cssRules || []).forEach((item) => {
            ret.push(item)
          })
        } catch (e) {
          console.error(`Error while reading CSS rules from ${sheet.href}`, e)
        }
      }
    })

    return ret
  })
}

function getWebFontRules(cssRules: CSSStyleRule[]): CSSStyleRule[] {
  return cssRules
    .filter((rule) => rule.type === CSSRule.FONT_FACE_RULE)
    .filter((rule) => shouldEmbed(rule.style.getPropertyValue('src')))
}

async function parseWebFontRules<T extends HTMLElement>(
  node: T,
  options: Options,
) {
  if (node.ownerDocument == null) {
    throw new Error('Provided element is not within a Document')
  }

  const styleSheets = toArray<CSSStyleSheet>(node.ownerDocument.styleSheets)
  const cssRules = await getCSSRules(styleSheets, options)

  return getWebFontRules(cssRules)
}

function normalizeFontFamily(font: string) {
  return font.trim().replace(/["']/g, '')
}

function getUsedFonts(node: HTMLElement) {
  const fonts = new Set<string>()
  function traverse(node: HTMLElement) {
    const fontFamily =
      node.style.fontFamily || getComputedStyle(node).fontFamily
    fontFamily.split(',').forEach((font) => {
      fonts.add(normalizeFontFamily(font))
    })

    Array.from(node.children).forEach((child) => {
      if (child instanceof HTMLElement) {
        traverse(child)
      }
    })
  }
  traverse(node)
  return fonts
}

export async function getWebFontCSS<T extends HTMLElement>(
  node: T,
  options: Options,
): Promise<string> {
  const rules = await parseWebFontRules(node, options)
  const usedFonts = getUsedFonts(node)
  const cssTexts = await Promise.all(
    rules
      .filter((rule) =>
        usedFonts.has(normalizeFontFamily(rule.style.fontFamily)),
      )
      .map((rule) => {
        const baseUrl = rule.parentStyleSheet
          ? rule.parentStyleSheet.href
          : null
        return embedResources(rule.cssText, baseUrl, options)
      }),
  )

  return cssTexts.join('\n')
}

export async function embedWebFonts<T extends HTMLElement>(
  clonedNode: T,
  options: Options,
) {
  const cssText =
    options.fontEmbedCSS != null
      ? options.fontEmbedCSS
      : options.skipFonts
      ? null
      : await getWebFontCSS(clonedNode, options)

  if (cssText) {
    const styleNode = document.createElement('style')
    const sytleContent = document.createTextNode(cssText)

    styleNode.appendChild(sytleContent)

    if (clonedNode.firstChild) {
      clonedNode.insertBefore(styleNode, clonedNode.firstChild)
    } else {
      clonedNode.appendChild(styleNode)
    }
  }
}
</file>

<file path="src/html-to-image/index.ts">
import { Options } from './types'
import { cloneNode } from './clone-node'
import { embedImages } from './embed-images'
import { applyStyle } from './apply-style'
import { embedWebFonts, getWebFontCSS } from './embed-webfonts'
import {
  getImageSize,
  getPixelRatio,
  createImage,
  canvasToBlob,
  nodeToDataURL,
  checkCanvasDimensions,
} from './util'

export { Options } from './types'

export async function toSvg<T extends HTMLElement>(
  node: T,
  options: Options = {},
): Promise<string> {
  const { width, height } = getImageSize(node, options)
  const clonedNode = (await cloneNode(node, options, true)) as HTMLElement
  await embedWebFonts(clonedNode, options)
  await embedImages(clonedNode, options)
  applyStyle(clonedNode, options)
  const datauri = await nodeToDataURL(clonedNode, width, height)
  return datauri
}

export async function toCanvas<T extends HTMLElement>(
  node: T,
  options: Options = {},
): Promise<HTMLCanvasElement> {
  const { width, height } = getImageSize(node, options)
  const svg = await toSvg(node, options)
  const img = await createImage(svg)

  const canvas = document.createElement('canvas')
  const context = canvas.getContext('2d')!
  const ratio = options.pixelRatio || getPixelRatio()
  const canvasWidth = options.canvasWidth || width
  const canvasHeight = options.canvasHeight || height

  canvas.width = canvasWidth * ratio
  canvas.height = canvasHeight * ratio

  if (!options.skipAutoScale) {
    checkCanvasDimensions(canvas)
  }
  canvas.style.width = `${canvasWidth}`
  canvas.style.height = `${canvasHeight}`

  if (options.backgroundColor) {
    context.fillStyle = options.backgroundColor
    context.fillRect(0, 0, canvas.width, canvas.height)
  }

  context.drawImage(img, 0, 0, canvas.width, canvas.height)

  return canvas
}

export async function toPixelData<T extends HTMLElement>(
  node: T,
  options: Options = {},
): Promise<Uint8ClampedArray> {
  const { width, height } = getImageSize(node, options)
  const canvas = await toCanvas(node, options)
  const ctx = canvas.getContext('2d')!
  return ctx.getImageData(0, 0, width, height).data
}

export async function toPng<T extends HTMLElement>(
  node: T,
  options: Options = {},
): Promise<string> {
  const canvas = await toCanvas(node, options)
  return canvas.toDataURL()
}

export async function toJpeg<T extends HTMLElement>(
  node: T,
  options: Options = {},
): Promise<string> {
  const canvas = await toCanvas(node, options)
  return canvas.toDataURL('image/jpeg', options.quality || 1)
}

export async function toBlob<T extends HTMLElement>(
  node: T,
  options: Options = {},
): Promise<Blob | null> {
  const canvas = await toCanvas(node, options)
  const blob = await canvasToBlob(canvas)
  return blob
}

export async function getFontEmbedCSS<T extends HTMLElement>(
  node: T,
  options: Options = {},
): Promise<string> {
  return getWebFontCSS(node, options)
}
</file>

<file path="src/html-to-image/mimes.ts">
const WOFF = 'application/font-woff'
const JPEG = 'image/jpeg'
const mimes: { [key: string]: string } = {
  woff: WOFF,
  woff2: WOFF,
  ttf: 'application/font-truetype',
  eot: 'application/vnd.ms-fontobject',
  png: 'image/png',
  jpg: JPEG,
  jpeg: JPEG,
  gif: 'image/gif',
  tiff: 'image/tiff',
  svg: 'image/svg+xml',
  webp: 'image/webp',
}

function getExtension(url: string): string {
  const match = /\.([^./]*?)$/g.exec(url)
  return match ? match[1] : ''
}

export function getMimeType(url: string): string {
  const extension = getExtension(url).toLowerCase()
  return mimes[extension] || ''
}
</file>

<file path="src/html-to-image/types.ts">
export interface Options {
  /**
   * Width in pixels to be applied to node before rendering.
   */
  width?: number
  /**
   * Height in pixels to be applied to node before rendering.
   */
  height?: number
  /**
   * A string value for the background color, any valid CSS color value.
   */
  backgroundColor?: string
  /**
   * Width in pixels to be applied to canvas on export.
   */
  canvasWidth?: number
  /**
   * Height in pixels to be applied to canvas on export.
   */
  canvasHeight?: number
  /**
   * An object whose properties to be copied to node's style before rendering.
   */
  style?: Partial<CSSStyleDeclaration>
  /**
   * An array of style properties to be copied to node's style before rendering.
   * For performance-critical scenarios, users may want to specify only the
   * required properties instead of all styles.
   */
  includeStyleProperties?: string[]
  /**
   * A function taking DOM node as argument. Should return `true` if passed
   * node should be included in the output. Excluding node means excluding
   * it's children as well.
   */
  filter?: (domNode: HTMLElement) => boolean
  /**
   * A number between `0` and `1` indicating image quality (e.g. 0.92 => 92%)
   * of the JPEG image.
   */
  quality?: number
  /**
   * Set to `true` to append the current time as a query string to URL
   * requests to enable cache busting.
   */
  cacheBust?: boolean
  /**
   * Set false to use all URL as cache key.
   * Default: false | undefined - which strips away the query parameters
   */
  includeQueryParams?: boolean
  /**
   * A data URL for a placeholder image that will be used when fetching
   * an image fails. Defaults to an empty string and will render empty
   * areas for failed images.
   */
  imagePlaceholder?: string
  /**
   * The pixel ratio of captured image. Defalut is the actual pixel ratio of
   * the device. Set 1 to use as initial-scale 1 for the image
   */
  pixelRatio?: number
  /**
   * Option to skip the fonts download and embed.
   */
  skipFonts?: boolean
  /**
   * The preferred font format. If specified all other font formats are ignored.
   */
  preferredFontFormat?:
    | 'woff'
    | 'woff2'
    | 'truetype'
    | 'opentype'
    | 'embedded-opentype'
    | 'svg'
    | string
  /**
   * A CSS string to specify for font embeds. If specified only this CSS will
   * be present in the resulting image. Use with `getFontEmbedCSS()` to
   * create embed CSS for use across multiple calls to library functions.
   */
  fontEmbedCSS?: string
  /**
   * A boolean to turn off auto scaling for truly massive images..
   */
  skipAutoScale?: boolean
  /**
   * A string indicating the image format. The default type is image/png; that type is also used if the given type isn't supported.
   */
  type?: string

  /**
   *
   *the second parameter of  window.fetch (Promise<Response> fetch(input[, init]))
   *
   */
  fetchRequestInit?: RequestInit
  /**
   * An event handler for the error event when any image in html has problem with loading.
   */
  onImageErrorHandler?: OnErrorEventHandler
}
</file>

<file path="src/html-to-image/util.ts">
import type { Options } from './types'

export function resolveUrl(url: string, baseUrl: string | null): string {
  // url is absolute already
  if (url.match(/^[a-z]+:\/\//i)) {
    return url
  }

  // url is absolute already, without protocol
  if (url.match(/^\/\//)) {
    return window.location.protocol + url
  }

  // dataURI, mailto:, tel:, etc.
  if (url.match(/^[a-z]+:/i)) {
    return url
  }

  const doc = document.implementation.createHTMLDocument()
  const base = doc.createElement('base')
  const a = doc.createElement('a')

  doc.head.appendChild(base)
  doc.body.appendChild(a)

  if (baseUrl) {
    base.href = baseUrl
  }

  a.href = url

  return a.href
}

export const uuid = (() => {
  // generate uuid for className of pseudo elements.
  // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.
  let counter = 0

  // ref: http://stackoverflow.com/a/6248722/2519373
  const random = () =>
    // eslint-disable-next-line no-bitwise
    `0000${((Math.random() * 36 ** 4) << 0).toString(36)}`.slice(-4)

  return () => {
    counter += 1
    return `u${random()}${counter}`
  }
})()

export function delay<T>(ms: number) {
  return (args: T) =>
    new Promise<T>((resolve) => {
      setTimeout(() => resolve(args), ms)
    })
}

export function toArray<T>(arrayLike: any): T[] {
  const arr: T[] = []

  for (let i = 0, l = arrayLike.length; i < l; i++) {
    arr.push(arrayLike[i])
  }

  return arr
}

let styleProps: string[] | null = null
export function getStyleProperties(options: Options = {}): string[] {
  if (styleProps) {
    return styleProps
  }

  if (options.includeStyleProperties) {
    styleProps = options.includeStyleProperties
    return styleProps
  }

  styleProps = toArray(window.getComputedStyle(document.documentElement))

  return styleProps
}

function px(node: HTMLElement, styleProperty: string) {
  const win = node.ownerDocument.defaultView || window
  const val = win.getComputedStyle(node).getPropertyValue(styleProperty)
  return val ? parseFloat(val.replace('px', '')) : 0
}

function getNodeWidth(node: HTMLElement) {
  const leftBorder = px(node, 'border-left-width')
  const rightBorder = px(node, 'border-right-width')
  return node.clientWidth + leftBorder + rightBorder
}

function getNodeHeight(node: HTMLElement) {
  const topBorder = px(node, 'border-top-width')
  const bottomBorder = px(node, 'border-bottom-width')
  return node.clientHeight + topBorder + bottomBorder
}

export function getImageSize(targetNode: HTMLElement, options: Options = {}) {
  const width = options.width || getNodeWidth(targetNode)
  const height = options.height || getNodeHeight(targetNode)

  return { width, height }
}

export function getPixelRatio() {
  let ratio

  let FINAL_PROCESS
  try {
    FINAL_PROCESS = process
  } catch (e) {
    // pass
  }

  const val =
    FINAL_PROCESS && FINAL_PROCESS.env
      ? FINAL_PROCESS.env.devicePixelRatio
      : null
  if (val) {
    ratio = parseInt(val, 10)
    if (Number.isNaN(ratio)) {
      ratio = 1
    }
  }
  return ratio || window.devicePixelRatio || 1
}

// @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size
const canvasDimensionLimit = 16384

export function checkCanvasDimensions(canvas: HTMLCanvasElement) {
  if (
    canvas.width > canvasDimensionLimit ||
    canvas.height > canvasDimensionLimit
  ) {
    if (
      canvas.width > canvasDimensionLimit &&
      canvas.height > canvasDimensionLimit
    ) {
      if (canvas.width > canvas.height) {
        canvas.height *= canvasDimensionLimit / canvas.width
        canvas.width = canvasDimensionLimit
      } else {
        canvas.width *= canvasDimensionLimit / canvas.height
        canvas.height = canvasDimensionLimit
      }
    } else if (canvas.width > canvasDimensionLimit) {
      canvas.height *= canvasDimensionLimit / canvas.width
      canvas.width = canvasDimensionLimit
    } else {
      canvas.width *= canvasDimensionLimit / canvas.height
      canvas.height = canvasDimensionLimit
    }
  }
}

export function canvasToBlob(
  canvas: HTMLCanvasElement,
  options: Options = {},
): Promise<Blob | null> {
  if (canvas.toBlob) {
    return new Promise((resolve) => {
      canvas.toBlob(
        resolve,
        options.type ? options.type : 'image/png',
        options.quality ? options.quality : 1,
      )
    })
  }

  return new Promise((resolve) => {
    const binaryString = window.atob(
      canvas
        .toDataURL(
          options.type ? options.type : undefined,
          options.quality ? options.quality : undefined,
        )
        .split(',')[1],
    )
    const len = binaryString.length
    const binaryArray = new Uint8Array(len)

    for (let i = 0; i < len; i += 1) {
      binaryArray[i] = binaryString.charCodeAt(i)
    }

    resolve(
      new Blob([binaryArray], {
        type: options.type ? options.type : 'image/png',
      }),
    )
  })
}

export function createImage(url: string): Promise<HTMLImageElement> {
  return new Promise((resolve, reject) => {
    const img = new Image()
    img.onload = () => {
      img.decode().then(() => {
        requestAnimationFrame(() => resolve(img))
      })
    }
    img.onerror = reject
    img.crossOrigin = 'anonymous'
    img.decoding = 'async'
    img.src = url
  })
}

export async function svgToDataURL(svg: SVGElement): Promise<string> {
  return Promise.resolve()
    .then(() => new XMLSerializer().serializeToString(svg))
    .then(encodeURIComponent)
    .then((html) => `data:image/svg+xml;charset=utf-8,${html}`)
}

export async function nodeToDataURL(
  node: HTMLElement,
  width: number,
  height: number,
): Promise<string> {
  const xmlns = 'http://www.w3.org/2000/svg'
  const svg = document.createElementNS(xmlns, 'svg')
  const foreignObject = document.createElementNS(xmlns, 'foreignObject')

  svg.setAttribute('width', `${width}`)
  svg.setAttribute('height', `${height}`)
  svg.setAttribute('viewBox', `0 0 ${width} ${height}`)

  foreignObject.setAttribute('width', '100%')
  foreignObject.setAttribute('height', '100%')
  foreignObject.setAttribute('x', '0')
  foreignObject.setAttribute('y', '0')
  foreignObject.setAttribute('externalResourcesRequired', 'true')

  svg.appendChild(foreignObject)
  foreignObject.appendChild(node)
  return svgToDataURL(svg)
}

export const isInstanceOfElement = <
  T extends typeof Element | typeof HTMLElement | typeof SVGImageElement,
>(
  node: Element | HTMLElement | SVGImageElement,
  instance: T,
): node is T['prototype'] => {
  if (node instanceof instance) return true

  const nodePrototype = Object.getPrototypeOf(node)

  if (nodePrototype === null) return false

  return (
    nodePrototype.constructor.name === instance.name ||
    isInstanceOfElement(nodePrototype, instance)
  )
}
</file>

<file path="src/new-outlines/canvas.ts">
import type { ActiveOutline, OutlineData } from './types';

export const OUTLINE_ARRAY_SIZE = 7;
const MONO_FONT =
  'Menlo,Consolas,Monaco,Liberation Mono,Lucida Console,monospace';

const INTERPOLATION_SPEED = 0.1;
const lerp = (start: number, end: number) => {
  return Math.floor(start + (end - start) * INTERPOLATION_SPEED);
};

const MAX_PARTS_LENGTH = 4;
const MAX_LABEL_LENGTH = 40;
const TOTAL_FRAMES = 45;

const PRIMARY_COLOR = '115,97,230';
// const SECONDARY_COLOR = '128,128,128';

function sortEntry(prev: [number, string[]], next: [number, string[]]): number {
  return next[0] - prev[0];
}

function getSortedEntries(
  countByNames: Map<number, string[]>,
): [number, string[]][] {
  const entries = [...countByNames.entries()];
  return entries.sort(sortEntry);
}

function getLabelTextPart([count, names]: [number, string[]]): string {
  let part = `${names.slice(0, MAX_PARTS_LENGTH).join(', ')} ${count}`;
  if (part.length > MAX_LABEL_LENGTH) {
    part = `${part.slice(0, MAX_LABEL_LENGTH)}`;
  }
  return part;
}

export const getLabelText = (outlines: ActiveOutline[]): string => {
  const nameByCount = new Map<string, number>();
  for (const { name, count } of outlines) {
    nameByCount.set(name, (nameByCount.get(name) || 0) + count);
  }

  const countByNames = new Map<number, string[]>();
  for (const [name, count] of nameByCount) {
    const names = countByNames.get(count);
    if (names) {
      names.push(name);
    } else {
      countByNames.set(count, [name]);
    }
  }

  // TODO(Alexis): Optimize
  const partsEntries = getSortedEntries(countByNames);
  let labelText = getLabelTextPart(partsEntries[0]);
  for (let i = 1, len = partsEntries.length; i < len; i++) {
    labelText += ', ' + getLabelTextPart(partsEntries[i]);
  }

  if (labelText.length > MAX_LABEL_LENGTH) {
    return `${labelText.slice(0, MAX_LABEL_LENGTH)}`;
  }

  return labelText;
};

export const getAreaFromOutlines = (outlines: ActiveOutline[]) => {
  let area = 0;
  for (const outline of outlines) {
    area += outline.width * outline.height;
  }
  return area;
};

export const updateOutlines = (
  activeOutlines: Map<string, ActiveOutline>,
  outlines: OutlineData[],
) => {
  for (const { id, name, count, x, y, width, height, didCommit } of outlines) {
    const outline: ActiveOutline = {
      id,
      name,
      count,
      x,
      y,
      width,
      height,
      frame: 0,
      targetX: x,
      targetY: y,
      targetWidth: width,
      targetHeight: height,
      didCommit,
    };
    const key = String(outline.id);

    const existingOutline = activeOutlines.get(key);
    if (existingOutline) {
      existingOutline.count++;
      existingOutline.frame = 0;
      existingOutline.targetX = x;
      existingOutline.targetY = y;
      existingOutline.targetWidth = width;
      existingOutline.targetHeight = height;
      existingOutline.didCommit = didCommit;
    } else {
      activeOutlines.set(key, outline);
    }
  }
};

export const updateScroll = (
  activeOutlines: Map<string, ActiveOutline>,
  deltaX: number,
  deltaY: number,
) => {
  for (const outline of activeOutlines.values()) {
    const newX = outline.x - deltaX;
    const newY = outline.y - deltaY;
    outline.targetX = newX;
    outline.targetY = newY;
  }
};

export const initCanvas = (
  canvas: HTMLCanvasElement | OffscreenCanvas,
  dpr: number,
) => {
  const ctx = canvas.getContext('2d', { alpha: true }) as
    | CanvasRenderingContext2D
    | OffscreenCanvasRenderingContext2D;
  if (ctx) {
    ctx.scale(dpr, dpr);
  }
  return ctx;
};

export const drawCanvas = (
  ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,
  canvas: HTMLCanvasElement | OffscreenCanvas,
  dpr: number,
  activeOutlines: Map<string, ActiveOutline>,
) => {
  ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);

  const groupedOutlinesMap = new Map<string, ActiveOutline[]>();
  const rectMap = new Map<
    string,
    {
      x: number;
      y: number;
      width: number;
      height: number;
      alpha: number;
    }
  >();

  for (const outline of activeOutlines.values()) {
    const {
      x,
      y,
      width,
      height,
      targetX,
      targetY,
      targetWidth,
      targetHeight,
      frame,
    } = outline;
    if (targetX !== x) {
      outline.x = lerp(x, targetX);
    }
    if (targetY !== y) {
      outline.y = lerp(y, targetY);
    }

    if (targetWidth !== width) {
      outline.width = lerp(width, targetWidth);
    }
    if (targetHeight !== height) {
      outline.height = lerp(height, targetHeight);
    }

    const labelKey = `${targetX ?? x},${targetY ?? y}`;
    const rectKey = `${labelKey},${targetWidth ?? width},${targetHeight ?? height}`;

    const outlines = groupedOutlinesMap.get(labelKey);
    if (outlines) {
      outlines.push(outline);
    } else {
      groupedOutlinesMap.set(labelKey, [outline]);
    }

    const alpha = 1 - frame / TOTAL_FRAMES;
    outline.frame++;

    const rect = rectMap.get(rectKey) || {
      x,
      y,
      width,
      height,
      alpha,
    };
    if (alpha > rect.alpha) {
      rect.alpha = alpha;
    }
    rectMap.set(rectKey, rect);
  }

  for (const { x, y, width, height, alpha } of rectMap.values()) {
    ctx.strokeStyle = `rgba(${PRIMARY_COLOR},${alpha})`;
    ctx.lineWidth = 1;

    ctx.beginPath();
    ctx.rect(x, y, width, height);
    ctx.stroke();
    ctx.fillStyle = `rgba(${PRIMARY_COLOR},${alpha * 0.1})`;
    ctx.fill();
  }

  ctx.font = `11px ${MONO_FONT}`;

  const labelMap = new Map<
    string,
    {
      text: string;
      width: number;
      height: number;
      alpha: number;
      x: number;
      y: number;
      outlines: ActiveOutline[];
    }
  >();

  ctx.textRendering = 'optimizeSpeed';

  // TODO(Alexis): optimizable?
  for (const outlines of groupedOutlinesMap.values()) {
    const first = outlines[0];
    const { x, y, frame } = first;
    const alpha = 1 - frame / TOTAL_FRAMES;
    const text = getLabelText(outlines);
    const { width } = ctx.measureText(text);
    const height = 11;
    labelMap.set(`${x},${y},${width},${text}`, {
      text,
      width,
      height,
      alpha,
      x,
      y,
      outlines,
    });

    let labelY: number = y - height - 4;

    if (labelY < 0) {
      labelY = 0;
    }

    if (frame > TOTAL_FRAMES) {
      for (const outline of outlines) {
        activeOutlines.delete(String(outline.id));
      }
    }
  }

  // TODO(Alexis): optimize
  const sortedLabels = Array.from(labelMap.entries()).sort(
    ([_, a], [__, b]) => {
      return getAreaFromOutlines(b.outlines) - getAreaFromOutlines(a.outlines);
    },
  );

  for (const [labelKey, label] of sortedLabels) {
    if (!labelMap.has(labelKey)) continue;

    for (const [otherKey, otherLabel] of labelMap.entries()) {
      if (labelKey === otherKey) continue;

      const { x, y, width, height } = label;
      const {
        x: otherX,
        y: otherY,
        width: otherWidth,
        height: otherHeight,
      } = otherLabel;

      if (
        x + width > otherX &&
        otherX + otherWidth > x &&
        y + height > otherY &&
        otherY + otherHeight > y
      ) {
        label.text = getLabelText(label.outlines.concat(otherLabel.outlines));
        label.width = ctx.measureText(label.text).width;
        labelMap.delete(otherKey);
      }
    }
  }

  for (const label of labelMap.values()) {
    const { x, y, alpha, width, height, text } = label;

    let labelY = y - height - 4;

    if (labelY < 0) {
      labelY = 0;
    }

    ctx.fillStyle = `rgba(${PRIMARY_COLOR},${alpha})`;
    ctx.fillRect(x, labelY, width + 4, height + 4);

    ctx.fillStyle = `rgba(255,255,255,${alpha})`;
    ctx.fillText(text, x + 2, labelY + height);
  }

  return activeOutlines.size > 0;
};
</file>

<file path="src/new-outlines/index.ts">
import {
  type Fiber,
  didFiberCommit,
  getDisplayName,
  getFiberId,
  getNearestHostFibers,
  getTimings,
  getType,
  isCompositeFiber,
} from 'bippy';
import {
  Change,
  ContextChange,
  PropsChange,
  ReactScanInternals,
  Store,
  ignoredProps,
} from '~core/index';
import {
  ChangeReason,
  createInstrumentation,
  getContextChanges,
  getStateChanges,
  OldRenderData,
} from '~core/instrumentation';
import { log, logIntro } from '~web/utils/log';
import { inspectorUpdateSignal } from '~web/views/inspector/states';
import {
  OUTLINE_ARRAY_SIZE,
  drawCanvas,
  initCanvas,
  updateOutlines,
  updateScroll,
} from './canvas';
import type { ActiveOutline, BlueprintOutline, OutlineData } from './types';
import { getChangedPropsDetailed } from '~web/views/inspector/utils';

// The worker code will be replaced at build time
const workerCode = '__WORKER_CODE__';

let worker: Worker | null = null;
let canvas: HTMLCanvasElement | null = null;
let ctx: CanvasRenderingContext2D | null = null;
let dpr = 1;
let animationFrameId: number | null = null;
const activeOutlines = new Map<string, ActiveOutline>();

const blueprintMap = new Map<Fiber, BlueprintOutline>();
const blueprintMapKeys = new Set<Fiber>();

export const outlineFiber = (fiber: Fiber) => {
  if (!isCompositeFiber(fiber)) return;
  const name =
    typeof fiber.type === 'string' ? fiber.type : getDisplayName(fiber);
  if (!name) return;
  const blueprint = blueprintMap.get(fiber);
  const nearestFibers = getNearestHostFibers(fiber);
  const didCommit = didFiberCommit(fiber);

  if (!blueprint) {
    blueprintMap.set(fiber, {
      name,
      count: 1,
      elements: nearestFibers.map((fiber) => fiber.stateNode),
      didCommit: didCommit ? 1 : 0,
    });
    blueprintMapKeys.add(fiber);
  } else {
    blueprint.count++;
  }
};

const mergeRects = (rects: DOMRect[]) => {
  const firstRect = rects[0];
  if (rects.length === 1) return firstRect;

  let minX: number | undefined;
  let minY: number | undefined;
  let maxX: number | undefined;
  let maxY: number | undefined;

  for (let i = 0, len = rects.length; i < len; i++) {
    const rect = rects[i];
    minX = minX == null ? rect.x : Math.min(minX, rect.x);
    minY = minY == null ? rect.y : Math.min(minY, rect.y);
    maxX =
      maxX == null ? rect.x + rect.width : Math.max(maxX, rect.x + rect.width);
    maxY =
      maxY == null
        ? rect.y + rect.height
        : Math.max(maxY, rect.y + rect.height);
  }

  if (minX == null || minY == null || maxX == null || maxY == null) {
    return rects[0];
  }

  return new DOMRect(minX, minY, maxX - minX, maxY - minY);
};

interface IntersectionState {
  resolveNext: ((value: IntersectionObserverEntry[]) => void) | null;
  seenElements: Set<Element>;
  uniqueElements: Set<Element>;
  done: boolean;
}

function onIntersect(
  this: IntersectionState,
  entries: IntersectionObserverEntry[],
  observer: IntersectionObserver,
) {
  const newEntries: IntersectionObserverEntry[] = [];

  for (const entry of entries) {
    const element = entry.target;
    if (!this.seenElements.has(element)) {
      this.seenElements.add(element);
      newEntries.push(entry);
    }
  }

  if (newEntries.length > 0 && this.resolveNext) {
    this.resolveNext(newEntries);
    this.resolveNext = null;
  }

  if (this.seenElements.size === this.uniqueElements.size) {
    observer.disconnect();
    this.done = true;
    if (this.resolveNext) {
      this.resolveNext([]);
    }
  }
}

export const getBatchedRectMap = async function* (
  elements: Element[],
): AsyncGenerator<IntersectionObserverEntry[], void, unknown> {
  const state: IntersectionState = {
    uniqueElements: new Set(elements),
    seenElements: new Set(),
    resolveNext: null,
    done: false,
  };
  const observer = new IntersectionObserver(onIntersect.bind(state));

  for (const element of state.uniqueElements) {
    observer.observe(element);
  }

  while (!state.done) {
    const entries = await new Promise<IntersectionObserverEntry[]>(
      (resolve) => {
        state.resolveNext = resolve;
      },
    );
    if (entries.length > 0) {
      yield entries;
    }
  }
};

const SupportedArrayBuffer =
  typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : ArrayBuffer;

export const flushOutlines = async () => {
  const elements: Element[] = [];

  for (const fiber of blueprintMapKeys) {
    const blueprint = blueprintMap.get(fiber);
    if (!blueprint) continue;
    for (let i = 0; i < blueprint.elements.length; i++) {
      if (!(blueprint.elements[i] instanceof Element)) {
        // TODO: filter this at the root
        continue;
      }
      elements.push(blueprint.elements[i]);
    }
  }

  const rectsMap = new Map<Element, DOMRect>();

  // TODO(Alexis): too complex, needs breakdown
  for await (const entries of getBatchedRectMap(elements)) {
    for (const entry of entries) {
      const element = entry.target;
      const rect = entry.intersectionRect;
      if (entry.isIntersecting && rect.width && rect.height) {
        rectsMap.set(element, rect);
      }
    }

    const blueprints: BlueprintOutline[] = [];
    const blueprintRects: DOMRect[] = [];
    const blueprintIds: number[] = [];

    for (const fiber of blueprintMapKeys) {
      const blueprint = blueprintMap.get(fiber);
      if (!blueprint) continue;

      const rects: DOMRect[] = [];
      for (let i = 0; i < blueprint.elements.length; i++) {
        const element = blueprint.elements[i];
        const rect = rectsMap.get(element);
        if (!rect) continue;
        rects.push(rect);
      }

      if (!rects.length) continue;

      blueprints.push(blueprint);
      blueprintRects.push(mergeRects(rects));
      blueprintIds.push(getFiberId(fiber));
    }

    if (blueprints.length > 0) {
      const arrayBuffer = new SupportedArrayBuffer(
        blueprints.length * OUTLINE_ARRAY_SIZE * 4,
      );
      const sharedView = new Float32Array(arrayBuffer);
      const blueprintNames = new Array(blueprints.length);
      let outlineData: OutlineData[] | undefined;

      for (let i = 0, len = blueprints.length; i < len; i++) {
        const blueprint = blueprints[i];
        const id = blueprintIds[i];
        const { x, y, width, height } = blueprintRects[i];
        const { count, name, didCommit } = blueprint;

        if (worker) {
          const scaledIndex = i * OUTLINE_ARRAY_SIZE;
          sharedView[scaledIndex] = id;
          sharedView[scaledIndex + 1] = count;
          sharedView[scaledIndex + 2] = x;
          sharedView[scaledIndex + 3] = y;
          sharedView[scaledIndex + 4] = width;
          sharedView[scaledIndex + 5] = height;
          sharedView[scaledIndex + 6] = didCommit;
          blueprintNames[i] = name;
        } else {
          outlineData ||= new Array(blueprints.length);
          outlineData[i] = {
            id,
            name,
            count,
            x,
            y,
            width,
            height,
            didCommit: didCommit as 0 | 1,
          };
        }
      }

      if (worker) {
        worker.postMessage({
          type: 'draw-outlines',
          data: arrayBuffer,
          names: blueprintNames,
        });
      } else if (canvas && ctx && outlineData) {
        updateOutlines(activeOutlines, outlineData);
        if (!animationFrameId) {
          animationFrameId = requestAnimationFrame(draw);
        }
      }
    }
  }

  for (const fiber of blueprintMapKeys) {
    blueprintMap.delete(fiber);
    blueprintMapKeys.delete(fiber);
  }
};

const draw = () => {
  if (!ctx || !canvas) return;

  const shouldContinue = drawCanvas(ctx, canvas, dpr, activeOutlines);

  if (shouldContinue) {
    animationFrameId = requestAnimationFrame(draw);
  } else {
    animationFrameId = null;
  }
};

const IS_OFFSCREEN_CANVAS_WORKER_SUPPORTED =
  typeof OffscreenCanvas !== 'undefined' && typeof Worker !== 'undefined';

const getDpr = () => {
  return Math.min(window.devicePixelRatio || 1, 2);
};

export const getCanvasEl = () => {
  cleanup();
  const host = document.createElement('div');
  host.setAttribute('data-react-scan', 'true');
  const shadowRoot = host.attachShadow({ mode: 'open' });

  const canvasEl = document.createElement('canvas');
  canvasEl.style.position = 'fixed';
  canvasEl.style.top = '0';
  canvasEl.style.left = '0';
  canvasEl.style.pointerEvents = 'none';
  canvasEl.style.zIndex = '2147483646';
  canvasEl.setAttribute('aria-hidden', 'true');

  // *** ADD DATA ATTRIBUTE ***
  canvasEl.setAttribute('data-react-scan-canvas', 'true');
  // *** END ADD ***
  shadowRoot.appendChild(canvasEl);

  if (!canvasEl) return null;

  dpr = getDpr();
  canvas = canvasEl;

  const { innerWidth, innerHeight } = window;
  canvasEl.style.width = `${innerWidth}px`;
  canvasEl.style.height = `${innerHeight}px`;
  const width = innerWidth * dpr;
  const height = innerHeight * dpr;
  canvasEl.width = width;
  canvasEl.height = height;

  if (
    IS_OFFSCREEN_CANVAS_WORKER_SUPPORTED &&
    !window.__REACT_SCAN_EXTENSION__
  ) {
    try {
      worker = new Worker(
        URL.createObjectURL(
          new Blob([workerCode], { type: 'application/javascript' }),
        ),
      );

      const offscreenCanvas = canvasEl.transferControlToOffscreen();
      worker?.postMessage(
        {
          type: 'init',
          canvas: offscreenCanvas,
          width: canvasEl.width,
          height: canvasEl.height,
          dpr,
        },
        [offscreenCanvas],
      );
    } catch (e) {
      // biome-ignore lint/suspicious/noConsole: Intended debug output
      console.warn('Failed to initialize OffscreenCanvas worker:', e);
    }
  }

  if (!worker) {
    ctx = initCanvas(canvasEl, dpr) as CanvasRenderingContext2D;
  }

  let isResizeScheduled = false;
  window.addEventListener('resize', () => {
    if (!isResizeScheduled) {
      isResizeScheduled = true;
      // TODO(Alexis): bindable
      setTimeout(() => {
        const width = window.innerWidth;
        const height = window.innerHeight;
        dpr = getDpr();
        canvasEl.style.width = `${width}px`;
        canvasEl.style.height = `${height}px`;
        if (worker) {
          worker.postMessage({
            type: 'resize',
            width,
            height,
            dpr,
          });
        } else {
          canvasEl.width = width * dpr;
          canvasEl.height = height * dpr;
          if (ctx) {
            ctx.resetTransform();
            ctx.scale(dpr, dpr);
          }
          draw();
        }
        isResizeScheduled = false;
      });
    }
  });

  let prevScrollX = window.scrollX;
  let prevScrollY = window.scrollY;
  let isScrollScheduled = false;

  window.addEventListener('scroll', () => {
    if (!isScrollScheduled) {
      isScrollScheduled = true;
      // TODO(Alexis): bindable
      setTimeout(() => {
        const { scrollX, scrollY } = window;
        const deltaX = scrollX - prevScrollX;
        const deltaY = scrollY - prevScrollY;
        prevScrollX = scrollX;
        prevScrollY = scrollY;
        if (worker) {
          worker.postMessage({
            type: 'scroll',
            deltaX,
            deltaY,
          });
        } else {
          requestAnimationFrame(
            updateScroll.bind(null, activeOutlines, deltaX, deltaY),
          );
        }
        isScrollScheduled = false;
      }, 16 * 2);
    }
  });

  setInterval(() => {
    if (blueprintMapKeys.size) {
      requestAnimationFrame(flushOutlines);
    }
  }, 16 * 2);

  shadowRoot.appendChild(canvasEl);
  return host;
};

export const hasStopped = () => {
  return globalThis.__REACT_SCAN_STOP__;
};

export const stop = () => {
  globalThis.__REACT_SCAN_STOP__ = true;
  cleanup();
};

export const cleanup = () => {
  const host = document.querySelector('[data-react-scan]');
  if (host) {
    host.remove();
  }
};

const reportRenderToListeners = (fiber: Fiber) => {
  if (isCompositeFiber(fiber)) {
    // report render has a non trivial cost because it calls Date.now(), so we want to avoid the computation if possible
    if (
      ReactScanInternals.options.value.showToolbar !== false &&
      Store.inspectState.value.kind === 'focused'
    ) {
      const reportFiber = fiber;
      const { selfTime } = getTimings(fiber);
      const displayName = getDisplayName(fiber.type);
      const fiberId = getFiberId(reportFiber);

      const currentData = Store.reportData.get(fiberId);
      const existingCount = currentData?.count ?? 0;
      const existingTime = currentData?.time ?? 0;

      const changes: Array<Change> = [];

      // optimization, for now only track changes on inspected prop, cleanup later when changes is used in outline drawing
      const listeners = Store.changesListeners.get(getFiberId(fiber));

      if (listeners?.length) {
        const propsChanges: Array<PropsChange> = getChangedPropsDetailed(
          fiber,
        ).map((change) => ({
          type: ChangeReason.Props,
          name: change.name,
          value: change.value,
          prevValue: change.prevValue,
          unstable: false,
        }));

        const stateChanges = getStateChanges(fiber);

        // context changes are incorrect, bippy needs to tell us the context dependencies that changed and provide those values every render
        // currently, we say every context change, regardless of the render it happened, is a change. Which requires us to hack change tracking
        // in the whats-changed toolbar component
        const fiberContext = getContextChanges(fiber);
        const contextChanges: Array<ContextChange> = fiberContext.map(
          (info) => ({
            name: info.name,
            type: ChangeReason.Context,
            value: info.value,
            contextType: info.contextType,
          }),
        );

        listeners.forEach((listener) => {
          listener({
            propsChanges,
            stateChanges,
            contextChanges,
          });
        });
      }
      const fiberData: OldRenderData = {
        count: existingCount + 1,
        time: existingTime + selfTime || 0,
        renders: [],
        displayName,
        type: getType(fiber.type) || null,
        changes,
      };

      Store.reportData.set(fiberId, fiberData);
      needsReport = true;
    }
  }
};

let needsReport = false;
let reportInterval: ReturnType<typeof setInterval>;
export const startReportInterval = () => {
  clearInterval(reportInterval);
  reportInterval = setInterval(() => {
    if (needsReport) {
      Store.lastReportTime.value = Date.now();
      needsReport = false;
    }
  }, 50);
};

export const isValidFiber = (fiber: Fiber) => {
  if (ignoredProps.has(fiber.memoizedProps)) {
    return false;
  }

  return true;
};
export const initReactScanInstrumentation = (setupToolbar: () => void) => {
  if (hasStopped()) return;
  // todo: don't hardcode string getting weird ref error in iife when using process.env
  let schedule: ReturnType<typeof requestAnimationFrame>;
  let mounted = false;

  const scheduleSetup = () => {
    if (mounted) {
      return;
    }
    if (schedule) {
      cancelAnimationFrame(schedule);
    }
    schedule = requestAnimationFrame(() => {
      mounted = true;
      const host = getCanvasEl();
      if (host) {
        document.documentElement.appendChild(host);
      }
      setupToolbar();
    }); // TODO(Alexis): perhaps a better timing
  };

  const instrumentation = createInstrumentation('react-scan-devtools-0.1.0', {
    onCommitStart: () => {
      ReactScanInternals.options.value.onCommitStart?.();
    },
    onActive: () => {
      if (hasStopped()) return;

      scheduleSetup();
      if (!window.__REACT_SCAN_EXTENSION__) {
        globalThis.__REACT_SCAN__ = {
          ReactScanInternals,
        };
      }
      startReportInterval();
      logIntro();
    },
    onError: () => {
      // todo: ingest errors without accidentally collecting data about user
    },
    isValidFiber,
    onRender: (fiber, renders) => {
      if (isCompositeFiber(fiber)) {
        Store.interactionListeningForRenders?.(fiber, renders);
      }
      const isOverlayPaused =
        ReactScanInternals.instrumentation?.isPaused.value;
      const isInspectorInactive =
        Store.inspectState.value.kind === 'inspect-off' ||
        Store.inspectState.value.kind === 'uninitialized';
      const shouldFullyAbort = isOverlayPaused && isInspectorInactive;

      if (shouldFullyAbort) {
        return;
      }
      if (!isOverlayPaused) {
        outlineFiber(fiber);
      }
      if (ReactScanInternals.options.value.log) {
        // this can be expensive given enough re-renders
        log(renders);
      }

      if (Store.inspectState.value.kind === 'focused') {
        inspectorUpdateSignal.value = Date.now();
      }
      if (!isInspectorInactive) {
        reportRenderToListeners(fiber);
      }

      ReactScanInternals.options.value.onRender?.(fiber, renders);
    },
    onCommitFinish: () => {
      scheduleSetup();
      ReactScanInternals.options.value.onCommitFinish?.();
    },
    onPostCommitFiberRoot() {
      scheduleSetup();
    },
    trackChanges: false,
  });
  ReactScanInternals.instrumentation = instrumentation;
};
</file>

<file path="src/new-outlines/offscreen-canvas.worker.ts">
import { OUTLINE_ARRAY_SIZE, drawCanvas, initCanvas } from './canvas';
import type { ActiveOutline } from './types';

let canvas: OffscreenCanvas | null = null;
let ctx: OffscreenCanvasRenderingContext2D | null = null;
let dpr = 1;

const activeOutlines: Map<string, ActiveOutline> = new Map();
let animationFrameId: number | null = null;

const draw = () => {
  if (!ctx || !canvas) return;

  const shouldContinue = drawCanvas(ctx, canvas, dpr, activeOutlines);

  if (shouldContinue) {
    animationFrameId = requestAnimationFrame(draw);
  } else {
    animationFrameId = null;
  }
};

self.onmessage = (event) => {
  const { type } = event.data;

  if (type === 'init') {
    canvas = event.data.canvas;
    dpr = event.data.dpr;

    if (canvas) {
      canvas.width = event.data.width;
      canvas.height = event.data.height;
      ctx = initCanvas(canvas, dpr) as OffscreenCanvasRenderingContext2D;
    }
  }

  if (!canvas || !ctx) return;

  if (type === 'resize') {
    dpr = event.data.dpr;
    canvas.width = event.data.width * dpr;
    canvas.height = event.data.height * dpr;
    ctx.resetTransform();
    ctx.scale(dpr, dpr);
    draw();

    return;
  }

  if (type === 'draw-outlines') {
    const { data, names } = event.data;

    const sharedView = new Float32Array(data);
    for (let i = 0; i < sharedView.length; i += OUTLINE_ARRAY_SIZE) {
      const x = sharedView[i + 2];
      const y = sharedView[i + 3];
      const width = sharedView[i + 4];
      const height = sharedView[i + 5];

      const didCommit = sharedView[i + 6] as 0 | 1;
      const outline = {
        id: sharedView[i],
        name: names[i / OUTLINE_ARRAY_SIZE],
        count: sharedView[i + 1],
        x,
        y,
        width,
        height,
        frame: 0,
        targetX: x,
        targetY: y,
        targetWidth: width,
        targetHeight: height,
        didCommit,
      };
      const key = String(outline.id);

      const existingOutline = activeOutlines.get(key);
      if (existingOutline) {
        existingOutline.count++;
        existingOutline.frame = 0;
        existingOutline.targetX = x;
        existingOutline.targetY = y;
        existingOutline.targetWidth = width;
        existingOutline.targetHeight = height;
        existingOutline.didCommit = didCommit;
      } else {
        activeOutlines.set(key, outline);
      }
    }

    if (!animationFrameId) {
      animationFrameId = requestAnimationFrame(draw);
    }

    return;
  }

  if (type === 'scroll') {
    const { deltaX, deltaY } = event.data;
    for (const outline of activeOutlines.values()) {
      const newX = outline.x - deltaX;
      const newY = outline.y - deltaY;
      outline.targetX = newX;
      outline.targetY = newY;
    }
  }
};
</file>

<file path="src/new-outlines/types.ts">
export interface OutlineData {
  id: number;
  name: string;
  count: number;
  x: number;
  y: number;
  width: number;
  height: number;
  didCommit: 0 | 1;
}

export type InlineOutlineData = [
  id: number,
  count: number,
  x: number,
  y: number,
  width: number,
  height: number,
  didCommit: 0 | 1,
];

export interface ActiveOutline {
  id: number;
  name: string;
  count: number;
  x: number;
  y: number;
  width: number;
  height: number;
  targetX: number;
  targetY: number;
  targetWidth: number;
  targetHeight: number;
  frame: number;
  didCommit: 1 | 0;
}

export interface BlueprintOutline {
  name: string;
  count: number;
  elements: Element[];
  didCommit: 1 | 0;
}

declare global {
  var __REACT_SCAN_STOP__: boolean;
  var ReactScan: {
    hasStopped: () => boolean;
    stop: () => void;
    cleanup: () => void;
    init: () => void;
    flushOutlines: () => void;
  };
}
</file>

<file path="src/react-component-name/__tests__/arrow-function.test.ts">
import { describe, it, expect } from 'vitest';
import { transform } from './utils';

describe('arrow function components', () => {
  it('handles inline JSX return', async () => {
    const input = `
      export const Button = () => <button>Click</button>
    `;
    const result = await transform(input);

    expect(result).toContain("Button.displayName = 'Button'");
  });

  it('handles block with JSX return', async () => {
    const input = `
      const Modal = () => {
        return <div>Modal content</div>
      }
    `;
    const result = await transform(input);
    expect(result).toContain("Modal.displayName = 'Modal'");
  });

  it('handles conditional returns', async () => {
    const input = `
      const ConditionalComponent = ({ show }) => {
        if (show) {
          return <div>Shown</div>
        }
        return <div>Hidden</div>
      }
    `;
    const result = await transform(input);
    expect(result).toContain(
      "ConditionalComponent.displayName = 'ConditionalComponent'",
    );
  });

  it('handles early returns', async () => {
    const input = `
      const EarlyReturn = ({ loading, error, data }) => {
        if (loading) return <div>Loading...</div>
        if (error) return <div>Error: {error}</div>
        return <div>{data}</div>
      }
    `;
    const result = await transform(input);
    expect(result).toContain("EarlyReturn.displayName = 'EarlyReturn'");
  });
});
</file>

<file path="src/react-component-name/__tests__/complex-patterns.test.ts">
import { describe, it, expect } from 'vitest';
import { transform } from './utils';

describe('complex component patterns', () => {
  it('handles components with hooks', async () => {
    const input = `
      const TodoList = () => {
        const [todos, setTodos] = useState([])
        useEffect(() => {
          fetchTodos().then(setTodos)
        }, [])
        return <ul>{todos.map(todo => <li key={todo.id}>{todo.text}</li>)}</ul>
      }
    `;
    const result = await transform(input);
    expect(result).toContain("TodoList.displayName = 'TodoList'");
  });

  it('handles components with multiple state updates', async () => {
    const input = `
      const Counter = () => {
        const [count, setCount] = useState(0)
        const increment = () => setCount(c => c + 1)
        const decrement = () => setCount(c => c - 1)
        return (
          <div>
            <button onClick={decrement}>-</button>
            <span>{count}</span>
            <button onClick={increment}>+</button>
          </div>
        )
      }
    `;
    const result = await transform(input);
    expect(result).toContain("Counter.displayName = 'Counter'");
  });

  it('handles components with render props', async () => {
    const input = `
      const DataFetcher = ({ children, url }) => {
        const [data, setData] = useState(null)
        useEffect(() => {
          fetch(url).then(setData)
        }, [url])
        return <>{children(data)}</>
      }
    `;
    const result = await transform(input);
    expect(result).toContain("DataFetcher.displayName = 'DataFetcher'");
  });

  it('handles higher-order components', async () => {
    const input = `
      const withData = (WrappedComponent) => {
        const WithData = (props) => {
          const [data, setData] = useState(null)
          return <WrappedComponent data={data} {...props} />
        }
        return WithData
      }
    `;
    const result = await transform(input);
    expect(result).toContain("WithData.displayName = 'WithData'");
  });
});
</file>

<file path="src/react-component-name/__tests__/function-declarations.test.ts">
import { describe, it, expect } from 'vitest';
import { transform } from './utils';

describe('function declarations', () => {
  it('handles named function declarations', async () => {
    const input = `
      function Welcome(props) {
        return <h1>Hello, {props.name}</h1>
      }
    `;
    const result = await transform(input);
    expect(result).toContain("Welcome.displayName = 'Welcome'");
  });

  it('handles async components', async () => {
    const input = `
      async function AsyncComponent({ id }) {
        const data = await fetchData(id)
        return <div>{data}</div>
      }
    `;
    const result = await transform(input);
    expect(result).toContain("AsyncComponent.displayName = 'AsyncComponent'");
  });
});
</file>

<file path="src/react-component-name/__tests__/general-cases.test.ts">
import { describe, expect, it } from 'vitest';
import { transform } from './utils';

describe('edge cases', () => {
  it('handles nested component declarations', async () => {
    const input = `
      const Parent = () => {
        const NestedChild = () => <div>Child</div>
        return (
          <div>
            <NestedChild />
          </div>
        )
      }
    `;
    const result = await transform(input);
    expect(result).toContain("Parent.displayName = 'Parent'");
    expect(result).toContain("NestedChild.displayName = 'NestedChild'");
  });

  it('handles components with complex expressions', async () => {
    const input = `
      const DynamicComponent = () => {
        const content = useMemo(() => (
          <div>
            {data.map(item => (
              <Fragment key={item.id}>
                {item.visible && <span>{item.text}</span>}
              </Fragment>
            ))}
          </div>
        ), [data])

        return (
          <>
            {isLoading ? <Spinner /> : content}
          </>
        )
      }
    `;
    const result = await transform(input);
    expect(result).toContain(
      "DynamicComponent.displayName = 'DynamicComponent'",
    );
  });

  it('handles components with multiple returns in switch/case', async () => {
    const input = `
      const StatusComponent = ({ status }) => {
        switch (status) {
          case 'loading':
            return <Spinner />
          case 'error':
            return <Error />
          case 'empty':
            return <Empty />
          default:
            return <Content />
        }
      }
    `;
    const result = await transform(input);
    expect(result).toContain("StatusComponent.displayName = 'StatusComponent'");
  });

  it('handles components with try/catch blocks', async () => {
    const input = `
      const SafeComponent = () => {
        try {
          const data = riskyOperation()
          return <div>{data}</div>
        } catch (error) {
          return <div>Error: {error.message}</div>
        }
      }
    `;
    const result = await transform(input);
    expect(result).toContain("SafeComponent.displayName = 'SafeComponent'");
  });

  it('handles components returning primitive values', async () => {
    const input = `
      // Null component
      const EmptyComponent = () => null;

      // String component
      const TextComponent = () => "Hello World";

      // Number component
      const NumberComponent = () => 42;

      // Boolean component (though not very useful)
      const BooleanComponent = () => true;

      // Array of elements
      const ListComponent = () => [
        <div key="1">One</div>,
        <div key="2">Two</div>
      ];

      // Conditional primitive returns
      const ConditionalComponent = ({ value }) => {
        if (!value) return null;
        if (typeof value === 'string') return value;
        if (typeof value === 'number') return value.toString();
        return <div>{value}</div>;
      };

      // Dynamic children
      const DynamicComponent = ({ count }) => {
        return Array(count).fill(null).map((_, i) => <div key={i} />);
      };

      // Async component with suspense
      const AsyncComponent = () => {
        const resource = fetchData();
        if (!resource.isReady) {
          throw resource.promise;
        }
        return <div>{resource.read()}</div>;
      };

      // Portal component
      const PortalComponent = () => {
        return createPortal(<div>Portal content</div>, document.body);
      };

      // Fragment shorthand
      const FragmentComponent = () => <>Fragment content</>;

      // Nested arrays and fragments
      const NestedComponent = () => [
        <div key="1">First</div>,
        <>
          <div>Nested 1</div>
          <div>Nested 2</div>
        </>,
        [<div key="3">Deep nested</div>]
      ];
    `;
    const result = await transform(input);
    // expect(result).toContain("EmptyComponent.displayName = 'EmptyComponent'");
    // expect(result).toContain("TextComponent.displayName = 'TextComponent'");
    // expect(result).toContain("NumberComponent.displayName = 'NumberComponent'");
    // expect(result).toContain(
    //   "BooleanComponent.displayName = 'BooleanComponent'",
    // );
    expect(result).toContain("ListComponent.displayName = 'ListComponent'");
    expect(result).toContain(
      "ConditionalComponent.displayName = 'ConditionalComponent'",
    );
    expect(result).toContain(
      "DynamicComponent.displayName = 'DynamicComponent'",
    );
    expect(result).toContain("AsyncComponent.displayName = 'AsyncComponent'");
    expect(result).toContain("PortalComponent.displayName = 'PortalComponent'");
    expect(result).toContain(
      "FragmentComponent.displayName = 'FragmentComponent'",
    );
    expect(result).toContain("NestedComponent.displayName = 'NestedComponent'");
  });

  it('handles components with complex conditional returns', async () => {
    const input = `
      const ComplexComponent = ({ type, data }) => {
        switch (type) {
          case 'text': return data;
          case 'number': return data.toString();
          case 'array': return data.map(item => <div key={item.id}>{item.text}</div>);
          case 'element': return <div>{data}</div>;
          default: return null;
        }
      };

      const TernaryComponent = ({ condition, value }) =>
        condition
          ? value
          : value
            ? <span>{value}</span>
            : null;

      const ShortCircuitComponent = ({ items }) =>
        items?.length && items.map(item => <div key={item}>{item}</div>);

      const NullishComponent = ({ text }) =>
        text ?? <>Default text</>;

      const ChainedComponent = ({ a, b, c }) =>
        a?.b?.c ?? <div>Fallback</div>;

      // More Suspense examples
      const DataComponent = () => {
        const data = resource.read();
        return <div>{data}</div>;
      };

      const SuspenseImage = ({ src }) => {
        const resource = preloadImage(src);
        if (!resource.complete) {
          throw resource.promise;
        }
        return <img src={src} alt="" />;
      };

      const ProfileComponent = () => {
        const user = userResource.read();
        const posts = postsResource.read();
        if (!user || !posts) {
          throw Promise.all([user?.promise, posts?.promise]);
        }
        return (
          <div>
            <h1>{user.name}</h1>
            {posts.map(post => <div key={post.id}>{post.title}</div>)}
          </div>
        );
      };
    `;
    const result = await transform(input);
    expect(result).toContain(
      "ComplexComponent.displayName = 'ComplexComponent'",
    );
    expect(result).toContain(
      "TernaryComponent.displayName = 'TernaryComponent'",
    );
    expect(result).toContain(
      "ShortCircuitComponent.displayName = 'ShortCircuitComponent'",
    );
    expect(result).toContain(
      "NullishComponent.displayName = 'NullishComponent'",
    );
    expect(result).toContain(
      "ChainedComponent.displayName = 'ChainedComponent'",
    );
    expect(result).toContain("DataComponent.displayName = 'DataComponent'");
    expect(result).toContain("SuspenseImage.displayName = 'SuspenseImage'");
    expect(result).toContain(
      "ProfileComponent.displayName = 'ProfileComponent'",
    );
  });

  it('handles components with complex state and hooks', async () => {
    const input = `
      export const ValueUpdate = ({
        valueUpdate,
        className,
      }) => {
        const actions = useTraceStoreActions();
        const referredToHeapObject = useTraceStore(getReferredToHeapObjectSelector(valueUpdate));
        const constructorStackFrame = useTraceStore(
          referredToHeapObject ? constructorStackFrameSelector(referredToHeapObject.constructorStackFrameId) : () => null,
        );

        const referredToHeapObjectColor = constructorStackFrame ? getFrameColor(constructorStackFrame) : undefined;

        return (
          <AnimatedTrace
            animation={"grow"}
            style={{
              borderColor: referredToHeapObjectColor,
            }}
            key={valueUpdate.valueUpdateId}
            className={cn([
              referredToHeapObject && "border-4",
              referredToHeapObject && "m-[2px]",
            ])}
          >
            <div className="w-fit flex items-center">
              <Editable
                styles={{
                  notEditing: {
                    maxWidth: "20em",
                    minHeight: "0px",
                    height: "1.2rem",
                  },
                }}
                classNames={{
                  notEditing: {
                    input: className,
                  },
                }}
                focusedId={valueUpdate.valueUpdateId}
                key={valueUpdate.valueUpdateId}
                state={{
                  value: valueUpdate.value,
                  onTrash: () => {
                    actions.shared.deleteValueUpdate(valueUpdate.valueUpdateId);
                  },
                  onValueChange: (newValue) => {
                    actions.shared.changeVariableUpdateValue({
                      value: newValue,
                      valueUpdateId: valueUpdate.valueUpdateId,
                    });
                  },
                }}
              />
            </div>
          </AnimatedTrace>
        );
      };

      // Another example with complex state management
      const DataGrid = ({ data, onSort }) => {
        const [sortField, setSortField] = useState(null);
        const [sortDirection, setSortDirection] = useState('asc');
        const [filters, setFilters] = useState({});

        const sortedData = useMemo(() => {
          if (!sortField) return data;
          return [...data].sort((a, b) => {
            const aVal = a[sortField];
            const bVal = b[sortField];
            return sortDirection === 'asc' ? aVal - bVal : bVal - aVal;
          });
        }, [data, sortField, sortDirection]);

        const filteredData = useMemo(() => {
          return sortedData.filter(item => {
            return Object.entries(filters).every(([key, value]) => {
              return item[key].toString().toLowerCase().includes(value.toLowerCase());
            });
          });
        }, [sortedData, filters]);

        const handleHeaderClick = (field) => {
          if (sortField === field) {
            setSortDirection(prev => prev === 'asc' ? 'desc' : 'asc');
          } else {
            setSortField(field);
            setSortDirection('asc');
          }
          onSort?.({ field, direction: sortDirection });
        };

        return (
          <div className="data-grid">
            <div className="header">
              {Object.keys(data[0] || {}).map(field => (
                <div
                  key={field}
                  onClick={() => handleHeaderClick(field)}
                  className={cn([
                    'header-cell',
                    sortField === field && 'sorted',
                    sortField === field && sortDirection === 'desc' && 'desc'
                  ])}
                >
                  {field}
                </div>
              ))}
            </div>
            <div className="body">
              {filteredData.map((row, i) => (
                <div key={i} className="row">
                  {Object.values(row).map((cell, j) => (
                    <div key={j} className="cell">{cell}</div>
                  ))}
                </div>
              ))}
            </div>
          </div>
        );
      };
    `;
    const result = await transform(input);
    expect(result).toContain("ValueUpdate.displayName = 'ValueUpdate'");
    expect(result).toContain("DataGrid.displayName = 'DataGrid'");
  });

  it('handles all forwardRef patterns', async () => {
    const input = `
      import React from 'react';

      // Basic forwardRef
      const Button = React.forwardRef((props, ref) => (
        <button ref={ref} {...props} />
      ));

      // Named function in forwardRef
      const Input = React.forwardRef(function Input(props, ref) {
        return <input ref={ref} {...props} />;
      });

      // forwardRef with type annotations
      const Select = React.forwardRef<HTMLSelectElement, SelectProps>((props, ref) => (
        <select ref={ref} {...props} />
      ));

      // forwardRef with displayName already set (should preserve it)
      const TextArea = React.forwardRef((props, ref) => {
        return <textarea ref={ref} {...props} />;
      });
      TextArea.displayName = 'CustomTextArea';

      // Complex forwardRef with hooks and logic
      const Field = React.forwardRef((props, ref) => {
        const [value, setValue] = useState('');
        const internalRef = useRef(null);

        useImperativeHandle(ref, () => ({
          focus: () => internalRef.current?.focus(),
          reset: () => setValue('')
        }));

        return (
          <div>
            <input
              ref={internalRef}
              value={value}
              onChange={e => setValue(e.target.value)}
            />
          </div>
        );
      });

      // forwardRef with memo
      const MemoizedInput = React.memo(React.forwardRef((props, ref) => (
        <input ref={ref} {...props} />
      )));

      // forwardRef wrapped in HOC
      const EnhancedInput = withStyles(React.forwardRef((props, ref) => (
        <input ref={ref} {...props} />
      )));
    `;
    const result = await transform(input);
    expect(result).toContain("Button.displayName = 'Button'");
    expect(result).toContain("Input.displayName = 'Input'");
    expect(result).toContain("Select.displayName = 'Select'");
    expect(result).toContain("TextArea.displayName = 'CustomTextArea'"); // Should preserve existing, todo check for one

    expect(result).toContain("Field.displayName = 'Field'");
    expect(result).toContain("MemoizedInput.displayName = 'MemoizedInput'");
    expect(result).toContain("EnhancedInput.displayName = 'EnhancedInput'");
  });

  it('handles all memo patterns', async () => {
    const input = `
      import React from 'react';
      // Basic memo
      const Item = React.memo(props => (
        <div>{props.text}</div>
      ));

      // Named function in memo
      const Header = React.memo(function Header({ title }) {
        return <h1>{title}</h1>;
      });

      // memo with comparison function
      const ExpensiveList = React.memo(({ items }) => (
        <ul>
          {items.map(item => <li key={item.id}>{item.text}</li>)}
        </ul>
      ), (prevProps, nextProps) => prevProps.items === nextProps.items);


      // memo with type annotations
      const TypedButton = React.memo<ButtonProps>(props => (
        <button {...props} />
      ));

      // memo with displayName already set (should preserve it)
      const Footer = React.memo(props => (
        <footer>{props.children}</footer>
      ));
      Footer.displayName = 'CustomFooter';

      // Complex memo with hooks and logic
      const SearchBar = React.memo(({ onSearch }) => {
        const [query, setQuery] = useState('');
        const debouncedQuery = useDebounce(query, 300);

        useEffect(() => {
          onSearch(debouncedQuery);
        }, [debouncedQuery, onSearch]);

        return (
          <input
            type="search"
            value={query}
            onChange={e => setQuery(e.target.value)}
          />
        );
      });

      // Nested memo
      const NestedMemo = React.memo(React.memo(props => (
        <div>{props.text}</div>
      )));

      // memo wrapped in HOC
      const EnhancedList = withStyles(React.memo(props => (
        <ul>{props.items.map(item => <li key={item.id}>{item.text}</li>)}</ul>
      )));

      // memo with forwardRef
      const MemoInput = React.memo(React.forwardRef((props, ref) => (
        <input ref={ref} {...props} />
      )));
    `;

    const result = await transform(input);
    expect(result).toContain("Item.displayName = 'Item'");
    expect(result).toContain("Header.displayName = 'Header'");
    expect(result).toContain("ExpensiveList.displayName = 'ExpensiveList'");
    expect(result).toContain("TypedButton.displayName = 'TypedButton'");
    expect(result).toContain("Footer.displayName = 'CustomFooter'"); // Should preserve existing
    expect(result).toContain("SearchBar.displayName = 'SearchBar'");
    expect(result).toContain("NestedMemo.displayName = 'NestedMemo'");
    expect(result).toContain("EnhancedList.displayName = 'EnhancedList'");
    expect(result).toContain("MemoInput.displayName = 'MemoInput'");
  });

  it('handles components with various function calls returning JSX', async () => {
    const input = `
      const ArrayMethodsComponent = ({ items }) => {
        // Filter then map
        const filtered = items
          .filter(item => item.visible)
          .map(item => <div key={item.id}>{item.text}</div>);

        // Reduce to JSX
        const reduced = items.reduce((acc, item) => [
          ...acc,
          <div key={item.id}>{item.text}</div>
        ], []);

        // Custom function returning JSX
        const renderItem = (item) => <div>{item.text}</div>;

        // Method chaining with JSX returns
        const processed = items
          .slice(0, 5)
          .filter(item => item.score > 10)
          .map(renderItem);

        return (
          <>
            <div>{filtered}</div>
            <div>{reduced}</div>
            <div>{processed}</div>
            <div>{renderItem(items[0])}</div>
          </>
        );
      };

      // Custom utility functions returning JSX
      const renderList = (items) => items.map(item => <li key={item.id}>{item.text}</li>);
      const createWrapper = (content) => <div className="wrapper">{content}</div>;
      const withLayout = (Component) => (props) => (
        <div className="layout">
          <Component {...props} />
        </div>
      );

      const CustomFunctionsComponent = ({ items }) => {
        // Direct function calls returning JSX
        const list = renderList(items);
        const wrapped = createWrapper(<span>Content</span>);

        // Function composition
        const content = createWrapper(renderList(items));

        // HOC usage
        const WrappedComponent = withLayout(({ text }) => <div>{text}</div>);

        return (
          <>
            {list}
            {wrapped}
            {content}
            <WrappedComponent text="Hello" />
          </>
        );
      };

      // Promise/async function returns
      const AsyncComponent = ({ id }) => {
        const [data, setData] = useState(null);

        useEffect(() => {
          const fetchData = async () => {
            const result = await api.get(id);
            return <div>{result.data}</div>;
          };

          fetchData().then(setData);
        }, [id]);

        return data || <div>Loading...</div>;
      };

      // Complex method chaining
      const ChainedComponent = ({ data }) => {
        const result = Object.entries(data)
          .filter(([_, value]) => value.isValid)
          .map(([key, value]) => ({ key, ...value }))
          .reduce((acc, item) => ({
            ...acc,
            [item.key]: <div key={item.key}>{item.content}</div>
          }), {});

        return (
          <div>
            {Object.values(result)}
          </div>
        );
      };

      // Functional composition
      const compose = (...fns) => x => fns.reduceRight((v, f) => f(v), x);

      const withData = Component => props => {
        const data = useData();
        return <Component {...props} data={data} />;
      };

      const withTheme = Component => props => {
        const theme = useTheme();
        return <Component {...props} theme={theme} />;
      };

      const BaseComponent = ({ data, theme, label }) => (
        <div className={theme}>{data[label]}</div>
      );

      const EnhancedComponent = compose(
        withData,
        withTheme
      )(BaseComponent);
    `;

    const result = await transform(input);
    expect(result).toContain(
      "ArrayMethodsComponent.displayName = 'ArrayMethodsComponent'",
    );
    expect(result).toContain(
      "CustomFunctionsComponent.displayName = 'CustomFunctionsComponent'",
    );
    expect(result).toContain("AsyncComponent.displayName = 'AsyncComponent'");
    expect(result).toContain(
      "ChainedComponent.displayName = 'ChainedComponent'",
    );
    expect(result).toContain("BaseComponent.displayName = 'BaseComponent'");
    // expect(result).toContain(
    //   "EnhancedComponent.displayName = 'EnhancedComponent'",
    // );
  });

  it('handles shadcn-style component patterns', async () => {
    const input = `
      import React from 'react';
      // Basic shadcn component pattern
      const Button = React.forwardRef<
        HTMLButtonElement,
        React.ButtonHTMLAttributes<HTMLButtonElement>
      >(({ className, ...props }, ref) => (
        <button
          className={cn("rounded-lg px-4", className)}
          ref={ref}
          {...props}
        />
      ));

      // With variants using cva
      const button = cva(
        "rounded-lg px-4",
        {
          variants: {
            variant: {
              default: "bg-primary",
              secondary: "bg-secondary",
            },
            size: {
              default: "h-10",
              sm: "h-8",
              lg: "h-12",
            },
          },
          defaultVariants: {
            variant: "default",
            size: "default",
          },
        }
      );

      interface ButtonProps
        extends React.ButtonHTMLAttributes<HTMLButtonElement>,
          VariantProps<typeof button> {}

      const ButtonWithVariants = React.forwardRef<HTMLButtonElement, ButtonProps>(
        ({ className, variant, size, ...props }, ref) => {
          return (
            <button
              className={cn(button({ variant, size, className }))}
              ref={ref}
              {...props}
            />
          )
        }
      );

      // With slot compositions
      const Card = React.forwardRef<
        HTMLDivElement,
        React.HTMLAttributes<HTMLDivElement>
      >(({ className, ...props }, ref) => (
        <div
          ref={ref}
          className={cn("rounded-lg border", className)}
          {...props}
        />
      ));

      const CardHeader = React.forwardRef<
        HTMLDivElement,
        React.HTMLAttributes<HTMLDivElement>
      >(({ className, ...props }, ref) => (
        <div
          ref={ref}
          className={cn("flex flex-col space-y-1.5 p-6", className)}
          {...props}
        />
      ));

      // Component composition
      const Dialog = ({ children, ...props }) => (
        <DialogPrimitive.Root {...props}>
          {children}
        </DialogPrimitive.Root>
      );

      const DialogTrigger = React.forwardRef<
        React.ElementRef<typeof DialogPrimitive.Trigger>,
        React.ComponentPropsWithoutRef<typeof DialogPrimitive.Trigger>
      >(({ className, ...props }, ref) => (
        <DialogPrimitive.Trigger
          ref={ref}
          className={cn("", className)}
          {...props}
        />
      ));
    `;

    const result = await transform(input);
    expect(result).toContain("Button.displayName = 'Button'");
    expect(result).toContain(
      "ButtonWithVariants.displayName = 'ButtonWithVariants'",
    );
    expect(result).toContain("Card.displayName = 'Card'");
    expect(result).toContain("CardHeader.displayName = 'CardHeader'");
    expect(result).toContain("Dialog.displayName = 'Dialog'");
    expect(result).toContain("DialogTrigger.displayName = 'DialogTrigger'");
  });

  it('handles legacy and unconventional component patterns', async () => {
    const input = `


      // createReactClass (after createClass was removed from React)
      const CreateClassComponent = createReactClass({
        render() {
          return <div>Still Legacy</div>
        }
      });

      // Mixins (old pattern, but still exists)
      const mixins = {
        componentDidMount() {
          console.log('mounted');
        }
      };

      const WithMixins = createReactClass({
        mixins: [mixins],
        render() {
          return <div>With Mixins</div>
        }
      });

      // Factory pattern (common in older Material-UI and other libs)
      const createComponent = (config) => {
        class GeneratedComponent extends React.Component {
          render() {
            return <div>{config.text}</div>
          }
        }
        return GeneratedComponent;
      };
      const FactoryComponent = createComponent({ text: 'Factory' });

      // Decorator pattern (still common in MobX codebases)
      @observer
      class DecoratedComponent extends React.Component {
        render() {
          return <div>{this.props.data}</div>
        }
      }

      // Render props with multiple children functions
      const RenderPropComponent = ({ children, render, component: Component }) => (
        <div>
          {children(data)}
          {render(data)}
          <Component data={data} />
        </div>
      );

      // Old context pattern
      class OldContextComponent extends React.Component {
        static contextTypes = {
          theme: PropTypes.object
        };

        render() {
          return <div>{this.context.theme}</div>
        }
      }

      // Partial application component creation
      const createPartialComponent = (defaultProps) =>
        function PartialComponent(props) {
          return <div {...defaultProps} {...props} />;
        };
      const PartialButton = createPartialComponent({ type: 'button' });

      // jQuery-style plugins (seen in older React codebases)
      React.Component.prototype.plugin = function() {
        return <div>Plugin</div>;
      };
      class PluginComponent extends React.Component {
        render() {
          return <>{this.plugin()}</>;
        }
      }



      // Multiple inheritance simulation
      const withInheritance = Base => class extends Base {
        render() {
          return <div>Extended {super.render()}</div>;
        }
      };
      class BaseComponent extends React.Component {
        render() {
          return <div>Base</div>;
        }
      }
      const InheritedComponent = withInheritance(BaseComponent);
    `;

    const result = await transform(input);
    expect(result).toContain(
      "CreateClassComponent.displayName = 'CreateClassComponent'",
    );
    expect(result).toContain("WithMixins.displayName = 'WithMixins'");
    // expect(result).toContain(
    //   "FactoryComponent.displayName = 'FactoryComponent'",
    // );
    expect(result).toContain(
      "DecoratedComponent.displayName = 'DecoratedComponent'",
    );
    expect(result).toContain(
      "RenderPropComponent.displayName = 'RenderPropComponent'",
    );
    expect(result).toContain(
      "OldContextComponent.displayName = 'OldContextComponent'",
    );
    // expect(result).toContain("PartialButton.displayName = 'PartialButton'");
    expect(result).toContain("PluginComponent.displayName = 'PluginComponent'");
    // expect(result).toContain(
    //   "InheritedComponent.displayName = 'InheritedComponent'",
    // );
  });
});
</file>

<file path="src/react-component-name/__tests__/react-patterns.test.ts">
import { describe, it, expect } from 'vitest';
import { transform } from './utils';

describe('modern React patterns', () => {
  it('handles components with hooks and context', async () => {
    const input = `
      const UserProfile = () => {
        const { user } = useContext(UserContext)
        const { theme } = useContext(ThemeContext)
        return (
          <div className={theme}>
            <h1>{user.name}</h1>
            <p>{user.email}</p>
          </div>
        )
      }
    `;
    const result = await transform(input);
    expect(result).toContain("UserProfile.displayName = 'UserProfile'");
  });

  it('handles components with custom hooks', async () => {
    const input = `
      const SearchResults = () => {
        const { data, loading, error } = useQuery(SEARCH_QUERY)
        const { formatResult } = useSearchFormatter()

        if (loading) return <div>Loading...</div>
        if (error) return <div>Error!</div>

        return (
          <ul>
            {data.map(item => (
              <li key={item.id}>{formatResult(item)}</li>
            ))}
          </ul>
        )
      }
    `;
    const result = await transform(input);
    expect(result).toContain("SearchResults.displayName = 'SearchResults'");
  });

  it('handles components with suspense boundaries', async () => {
    const input = `
      const AsyncContent = () => {
        const data = useSuspenseQuery(QUERY)
        return (
          <Suspense fallback={<div>Loading...</div>}>
            <div>{data.content}</div>
          </Suspense>
        )
      }
    `;
    const result = await transform(input);
    expect(result).toContain("AsyncContent.displayName = 'AsyncContent'");
  });

  it('handles components with error boundaries', async () => {
    const input = `
      import React from 'react';

      class ErrorBoundary extends React.Component {
        state = { hasError: false }

        static getDerivedStateFromError(error) {
          return { hasError: true }
        }

        render() {
          if (this.state.hasError) {
            return <div>Something went wrong</div>
          }
          return this.props.children
        }
      }
    `;
    const result = await transform(input);
    expect(result).toContain("ErrorBoundary.displayName = 'ErrorBoundary'");
  });
});
</file>

<file path="src/react-component-name/__tests__/ts-patterns.test.ts">
import { describe, it, expect } from 'vitest';
import { transform } from './utils';

describe('typescript patterns', () => {
  it('handles components with type parameters', async () => {
    const input = `
      interface Props<T> {
        items: T[]
        renderItem: (item: T) => React.ReactNode
      }

      const List = <T extends unknown>({ items, renderItem }: Props<T>) => {
        return <div>{items.map(renderItem)}</div>
      }
    `;
    const result = await transform(input);
    expect(result).toContain("List.displayName = 'List'");
  });

  it('handles components with complex types', async () => {
    const input = `
      type Props = {
        id: string
        onClick: (e: React.MouseEvent) => void
        children: React.ReactNode
      } & Omit<React.ButtonHTMLAttributes<HTMLButtonElement>, 'onClick'>

      export const Button: React.FC<Props> = ({ id, onClick, children, ...rest }) => {
        return <button onClick={onClick} {...rest}>{children}</button>
      }
    `;
    const result = await transform(input);
    expect(result).toContain("Button.displayName = 'Button'");
  });
});
</file>

<file path="src/react-component-name/__tests__/utils.ts">
import { type Options, reactComponentNamePlugin } from '..';

type TransformFn = (
  code: string,
  id: string,
) => Promise<{ code: string } | string | null>;

export const transform = async (code: string, options?: Options) => {
  const plugin = reactComponentNamePlugin.vite(options || {}) as {
    transform: TransformFn;
  };
  const transformFn = plugin.transform;
  if (!transformFn) return code;

  const result = await transformFn.call(
    {
      getCombinedSourcemap: () => null,
      error: console.error,
    },
    code,
    'test.tsx',
  );

  if (!result) return code;
  if (typeof result === 'string') return result;
  return result.code;
};
</file>

<file path="src/react-component-name/babel/get-descriptive-name.ts">
import type * as babel from '@babel/core';

export function getDescriptiveName(
  path: babel.NodePath,
  defaultName: string,
): string {
  let current: babel.NodePath | null = path;
  while (current) {
    switch (current.node.type) {
      case 'FunctionDeclaration':
      case 'FunctionExpression': {
        if (current.node.id) {
          return current.node.id.name;
        }
        break;
      }
      case 'VariableDeclarator': {
        if (current.node.id.type === 'Identifier') {
          return current.node.id.name;
        }
        break;
      }
      case 'ClassPrivateMethod':
      case 'ClassMethod':
      case 'ObjectMethod': {
        switch (current.node.key.type) {
          case 'Identifier':
            return current.node.key.name;
          case 'PrivateName':
            return current.node.key.id.name;
          default:
            break;
        }
        break;
      }
      default:
        break;
    }
    current = current.parentPath;
  }
  return defaultName;
}
</file>

<file path="src/react-component-name/babel/get-root-statement-path.ts">
import type * as babel from '@babel/core';
import * as t from '@babel/types';

export function getRootStatementPath(path: babel.NodePath): babel.NodePath {
  let current = path.parentPath;
  while (current) {
    const next = current.parentPath;
    if (next && t.isProgram(next.node)) {
      return current;
    }
    current = next;
  }
  return path;
}
</file>

<file path="src/react-component-name/babel/index.ts">
import type { NodePath, PluginObj } from '@babel/core';
import * as t from '@babel/types';
import type { Options } from '../core/options';
import { isComponentishName } from './is-componentish-name';
import { pathReferencesImport } from './path-references-import';
import { unwrapNode, unwrapPath } from './unwrap';

function getAssignedDisplayNames(path: NodePath<t.Program>): Set<string> {
  const names = new Set<string>();
  path.traverse({
    AssignmentExpression(path) {
      const { node } = path;

      const memberExpr = unwrapNode(node.left, t.isMemberExpression);
      if (!memberExpr) {
        return;
      }
      const object = unwrapNode(memberExpr.object, t.isIdentifier);
      if (!object) {
        return;
      }
      if (
        t.isIdentifier(memberExpr.property) &&
        memberExpr.property.name === 'displayName'
      ) {
        names.add(object.name);
      }
    },
  });
  return names;
}

function isValidFunction(
  node: t.Node,
): node is t.ArrowFunctionExpression | t.FunctionExpression {
  return t.isArrowFunctionExpression(node) || t.isFunctionExpression(node);
}

function assignDisplayName(
  statement: NodePath<t.Statement>,
  name: string,
  dontAddTryCatch = false,
): void {
  if (dontAddTryCatch) {
    statement.insertAfter([
      t.expressionStatement(
        t.assignmentExpression(
          '=',
          t.memberExpression(t.identifier(name), t.identifier('displayName')),
          t.stringLiteral(name),
        ),
      ),
    ]);
  } else {
    statement.insertAfter([
      t.tryStatement(
        t.blockStatement([
          t.expressionStatement(
            t.assignmentExpression(
              '=',
              t.memberExpression(
                t.identifier(name),
                t.identifier('displayName'),
              ),
              t.stringLiteral(name),
            ),
          ),
        ]),
        t.catchClause(t.identifier('error'), t.blockStatement([])),
      ),
    ]);
  }
}

const REACT_CLASS = ['Component', 'PureComponent'];

function isNamespaceExport(
  namespace: string,
  moduleExports: string[],
  path: NodePath<t.Expression>,
): boolean {
  const identifier = unwrapPath(path, t.isIdentifier);
  if (identifier) {
    return moduleExports.includes(identifier.node.name);
  }
  const memberExpr = unwrapPath(path, t.isMemberExpression);
  if (memberExpr) {
    const object = unwrapPath(memberExpr.get('object'), t.isIdentifier);
    if (object && object.node.name === namespace) {
      const property = memberExpr.get('property');
      return (
        property.isIdentifier() && moduleExports.includes(property.node.name)
      );
    }
  }
  return false;
}

function isReactClassComponent(path: NodePath<t.Class>): boolean {
  const superClass = path.get('superClass');

  if (!superClass.isExpression()) {
    return false;
  }
  if (isNamespaceExport('React', REACT_CLASS, superClass)) {
    return true;
  }
  // The usual
  if (pathReferencesImport(superClass, 'react', REACT_CLASS, false, true)) {
    return true;
  }
  return false;
}

function isStyledComponent(
  moduleName: string,
  importName: string[],
  path: NodePath<t.Expression>,
): boolean {
  function isStyledImport(path: NodePath<t.Node>): boolean {
    return (
      (path.isIdentifier() && path.node.name === 'styled') ||
      pathReferencesImport(path, moduleName, importName, false, false)
    );
  }
  const callExpr = unwrapPath(path, t.isCallExpression);
  if (callExpr) {
    const callee = callExpr.get('callee');
    // styled('h1', () => {...});
    if (isStyledImport(callee)) {
      return true;
    }
    // styled.h1(() => {...})
    const memberExpr = unwrapPath(callee, t.isMemberExpression);
    if (memberExpr) {
      const object = unwrapPath(memberExpr.get('object'), t.isIdentifier);
      if (object && isStyledImport(object)) {
        return true;
      }
    }

    return false;
  }

  const taggedExpr = unwrapPath(path, t.isTaggedTemplateExpression);
  if (taggedExpr) {
    const tag = taggedExpr.get('tag');

    const memberExpr = unwrapPath(tag, t.isMemberExpression);
    if (memberExpr) {
      const object = unwrapPath(memberExpr.get('object'), t.isIdentifier);
      // styled.h1`...`;
      if (object && isStyledImport(object)) {
        return true;
      }

      return false;
    }

    // styled(Link)`...`
    const callExpr = unwrapPath(tag, t.isCallExpression);
    if (callExpr) {
      const callee = callExpr.get('callee');
      if (isStyledImport(callee)) {
        return true;
      }

      return false;
    }
  }
  return false;
}

const REACT_FACTORY = [
  'forwardRef',
  'memo',
  'createClass',
  // 'lazy',
];

function isReactComponent(
  expr: NodePath<t.Expression>,
  flags: Options['flags'],
): boolean {
  // Check for class components
  const classExpr = unwrapPath(expr, t.isClassExpression);
  if (classExpr && isReactClassComponent(classExpr)) {
    return true;
  }
  // Check for function components
  const funcExpr = unwrapPath(expr, isValidFunction);
  if (funcExpr && !funcExpr.node.generator && funcExpr.node.params.length < 3) {
    return true;
  }
  // Time for call exprs
  const callExpr = unwrapPath(expr, t.isCallExpression);
  if (callExpr) {
    const callee = callExpr.get('callee');
    // React
    const factory = [...REACT_FACTORY];
    if (!flags?.noCreateContext) {
      factory.push('createContext');
    }
    if (
      (callee.isExpression() &&
        isNamespaceExport('React', REACT_FACTORY, callee)) ||
      pathReferencesImport(callee, 'react', REACT_FACTORY, false, true)
    ) {
      return true;
    }
    const identifier = unwrapPath(callee, t.isIdentifier);
    if (identifier) {
      if (identifier.node.name === 'createReactClass') {
        return true;
      }
      // Assume HOCs
      if (/^with[A-Z]/.test(identifier.node.name)) {
        return true;
      }
    }
  }

  if (flags?.noStyledComponents) return false;
  if (isStyledComponent('@emotion/styled', ['default'], expr)) {
    return true;
  }
  if (isStyledComponent('styled-components', ['default'], expr)) {
    return true;
  }
  return false;
}

export const reactScanComponentNamePlugin = (options?: Options): PluginObj => ({
  name: 'react-scan/component-name',
  visitor: {
    Program(path) {
      const assignedNames = getAssignedDisplayNames(path);
      path.traverse({
        ClassDeclaration(path) {
          if (isReactClassComponent(path)) {
            if (!path.node.id) {
              return;
            }
            const name = path.node.id.name;
            if (assignedNames.has(name)) {
              return;
            }
            assignDisplayName(path, name, options?.flags?.noTryCatchDisplayNames);
          }
        },
        FunctionDeclaration(path) {
          const decl = path.node;

          if (
            // Check if the declaration has an identifier, and then check
            decl.id &&
            // if the name is component-ish
            isComponentishName(decl.id.name, options?.flags) &&
            !decl.generator &&
            // Might be component-like, but the only valid components
            // have zero, one or two (forwardRef) parameters
            decl.params.length < 3
          ) {
            if (!path.node.id) {
              return;
            }
            const name = path.node.id.name;
            if (assignedNames.has(name)) {
              return;
            }
            assignDisplayName(path, name, options?.flags?.noTryCatchDisplayNames);
          }
        },
        VariableDeclarator(path) {
          if (!path.parentPath.isVariableDeclaration()) {
            return;
          }
          const identifier = path.node.id;
          const init = path.get('init');
          if (!(init.isExpression() && t.isIdentifier(identifier))) {
            return;
          }
          if (!isComponentishName(identifier.name, options?.flags)) {
            return;
          }
          if (isReactComponent(init, options?.flags)) {
            const name = identifier.name;

            if (!assignedNames.has(name)) {
              assignDisplayName(
                path.parentPath,
                name,
                options?.flags?.noTryCatchDisplayNames,
              );
            }
          }
        },
      });
    },
  },
});
</file>

<file path="src/react-component-name/babel/is-componentish-name.ts">
// This is just a Pascal heuristic
// we only assume a function is a component

import type { Options } from '../core/options';

// if the first character is in uppercase
export function isComponentishName(name: string, flags: Options['flags']) {
  return (
    name[0] >= 'A' &&
    name[0] <= 'Z' &&
    !flags?.ignoreComponentSubstrings?.some((substring) =>
      name.includes(substring),
    )
  );
}
</file>

<file path="src/react-component-name/babel/is-nested-expression.ts">
import type * as t from '@babel/types';
type NestedExpression =
  | t.ParenthesizedExpression
  | t.TypeCastExpression
  | t.TSAsExpression
  | t.TSSatisfiesExpression
  | t.TSNonNullExpression
  | t.TSInstantiationExpression
  | t.TSTypeAssertion;

export const isNestedExpression = (node: t.Node): node is NestedExpression => {
  switch (node.type) {
    case 'ParenthesizedExpression':
    case 'TypeCastExpression':
    case 'TSAsExpression':
    case 'TSSatisfiesExpression':
    case 'TSNonNullExpression':
    case 'TSTypeAssertion':
    case 'TSInstantiationExpression':
      return true;
    default:
      return false;
  }
};
</file>

<file path="src/react-component-name/babel/is-path-valid.ts">
import type { NodePath } from '@babel/core';
import type * as t from '@babel/types';

type TypeFilter<V extends t.Node> = (node: t.Node) => node is V;

export const isPathValid = <V extends t.Node>(
  path: unknown,
  key: TypeFilter<V>,
): path is NodePath<V> => {
  return key((path as NodePath).node);
};
</file>

<file path="src/react-component-name/babel/is-statement-top-level.ts">
import type * as babel from '@babel/core';
import type * as t from '@babel/types';

export function isStatementTopLevel(
  path: babel.NodePath<t.Statement>,
): boolean {
  let blockParent = path.scope.getBlockParent();
  const programParent = path.scope.getProgramParent();
  // a FunctionDeclaration binding refers to itself as the block parent
  if (blockParent.path === path) {
    blockParent = blockParent.parent;
  }

  return programParent === blockParent;
}
</file>

<file path="src/react-component-name/babel/path-references-import.ts">
import type { NodePath } from '@babel/core';
import * as t from '@babel/types';
import { isPathValid } from './is-path-valid';
import { unwrapPath } from './unwrap';

export const pathReferencesImport = (
  path: NodePath,
  moduleSource: string,
  importName: string[],
  asType: boolean,
  defaultNamespace = false,
): boolean => {
  const identifier = unwrapPath(path, t.isIdentifier);
  if (identifier) {
    const binding = path.scope.getBinding(identifier.node.name);
    if (binding && binding.kind === 'module') {
      const importPath = binding.path;
      const importParent = importPath.parentPath;
      if (
        isPathValid(importParent, t.isImportDeclaration) &&
        importParent.node.source.value === moduleSource
      ) {
        if (isPathValid(importPath, t.isImportSpecifier)) {
          const key = t.isIdentifier(importPath.node.imported)
            ? importPath.node.imported.name
            : importPath.node.imported.value;
          return importName.includes(key);
        }
        if (isPathValid(importPath, t.isImportDefaultSpecifier)) {
          return importName.includes('default');
        }
        if (isPathValid(importPath, t.isImportNamespaceSpecifier)) {
          return importName.includes('*');
        }
      }
    }
    return false;
  }
  const memberExpr =
    unwrapPath(path, t.isMemberExpression) ||
    unwrapPath(path, t.isOptionalMemberExpression);
  if (memberExpr) {
    const object = unwrapPath(memberExpr.get('object'), t.isIdentifier);
    if (!object) {
      return false;
    }
    const property = memberExpr.get('property');
    if (isPathValid(property, t.isIdentifier)) {
      return (
        importName.includes(property.node.name) &&
        (pathReferencesImport(object, moduleSource, ['*'], asType) ||
          (defaultNamespace &&
            pathReferencesImport(object, moduleSource, ['default'], asType)))
      );
    }
    if (isPathValid(property, t.isStringLiteral)) {
      return (
        importName.includes(property.node.value) &&
        (pathReferencesImport(object, moduleSource, ['*'], asType) ||
          (defaultNamespace &&
            pathReferencesImport(object, moduleSource, ['default'], asType)))
      );
    }
  }
  return false;
};
</file>

<file path="src/react-component-name/babel/unwrap.ts">
import type { NodePath } from '@babel/core';
import type * as t from '@babel/types';
import { isNestedExpression } from './is-nested-expression';
import { isPathValid } from './is-path-valid';

type TrueTypeFilter<U extends t.Node> = (node: t.Node) => node is U;
type TypeCheck<K> = K extends TrueTypeFilter<infer U> ? U : never;

type NodeTypeFilter = (node: t.Node) => boolean;

export const unwrapNode = <K extends NodeTypeFilter>(
  node: t.Node | null | undefined,
  key: K,
): TypeCheck<K> | undefined => {
  if (!node) {
    return undefined;
  }
  if (key(node)) {
    return node as TypeCheck<K>;
  }
  if (isNestedExpression(node)) {
    return unwrapNode(node.expression, key);
  }
  return undefined;
};

type PathTypeFilter<V extends t.Node> = (node: t.Node) => node is V;

export const unwrapPath = <V extends t.Node>(
  path: unknown,
  key: PathTypeFilter<V>,
): NodePath<V> | undefined => {
  if (isPathValid(path, key)) {
    return path;
  }
  if (isPathValid(path, isNestedExpression)) {
    return unwrapPath(path.get('expression'), key);
  }
  return undefined;
};
</file>

<file path="src/react-component-name/core/options.ts">
import type { FilterPattern } from '@rollup/pluginutils';

export interface Options {
  include?: FilterPattern;
  exclude?: FilterPattern;
  enforce?: 'pre' | 'post' | undefined;
  flags?: {
    noTryCatchDisplayNames?: boolean;
    noStyledComponents?: boolean;
    noCreateContext?: boolean;
    ignoreComponentSubstrings?: Array<string>;
  };
}

type Overwrite<T, U> = Pick<T, Exclude<keyof T, keyof U>> & U;

export type OptionsResolved = Overwrite<
  Required<Options>,
  Pick<Options, 'enforce'>
>;

export function resolveOptions(options: Options): OptionsResolved {
  return {
    include: options.include ?? [/\.[cm]?[jt]sx?$/],
    exclude: options.exclude ?? [/node_modules/],
    enforce: 'enforce' in options ? options.enforce : 'pre',
    flags: options.flags ?? {},
  };
}
</file>

<file path="src/react-component-name/astro.ts">
import type { Options } from '.';
import vite from './vite';

export default (options: Options = {}) => ({
  name: 'react-component-name',
  hooks: {
    // biome-ignore lint/suspicious/noExplicitAny: should be { config: AstroConfig }
    'astro:config:setup': (astro: any) => {
      astro.config.vite.plugins ||= [];
      astro.config.vite.plugins.push(vite(options));
    },
  },
});
</file>

<file path="src/react-component-name/esbuild.ts">
import { reactComponentNamePlugin } from '.'

export default reactComponentNamePlugin.esbuild
</file>

<file path="src/react-component-name/index.ts">
import { transformAsync } from '@babel/core';
import { createFilter } from '@rollup/pluginutils';
import { createUnplugin } from 'unplugin';
import { reactScanComponentNamePlugin } from './babel';
import type { Options } from './core/options';

export const transform = async (
  code: string,
  id: string,
  filter: (id: string) => boolean,
  options?: Options,
) => {
  if (!filter(id)) return null;

  try {
    const result = await transformAsync(code, {
      plugins: [reactScanComponentNamePlugin(options)],
      ignore: [/\/(?<c>build|node_modules)\//],
      parserOpts: {
        plugins: ['jsx', 'typescript', 'decorators'],
      },
      cloneInputAst: false,
      filename: id,
      ast: false,
      highlightCode: false,
      sourceMaps: true,
      configFile: false,
      babelrc: false,
      generatorOpts: {
        jsescOption: {
          quotes: 'single',
          minimal: true,
        },
      },
    });

    if (result?.code) {
      return { code: result.code ?? '', map: result.map };
    }

    return null;
  } catch (error) {
    // biome-ignore lint/suspicious/noConsole: Intended debug output
    console.error('Error processing file:', id, error);
    return null;
  }
};

export const DEFAULT_INCLUDE = '**/*.{mtsx,mjsx,tsx,jsx}';
export const DEFAULT_EXCLUDE = '**/node_modules/**';
export const reactComponentNamePlugin = createUnplugin<Options>(
  (options?: Options) => {
    // mirror to loader.ts when changing this
    const filter = createFilter(
      options?.include || DEFAULT_INCLUDE,
      options?.exclude || [
        DEFAULT_EXCLUDE,
        // Next.js pages dir specific
        '**/_app.{jsx,tsx,js,ts}',
        '**/_document.{jsx,tsx,js,ts}',
        '**/api/**/*',
        // Million.js specific
        '**/.million/**/*',
      ],
    );

    return {
      name: 'react-component-name',
      enforce: 'post',
      async transform(code, id) {
        return transform(code, id, filter, options);
      },
    };
  },
);

export default reactComponentNamePlugin;
export type { Options };
</file>

<file path="src/react-component-name/loader.ts">
import { type FilterPattern, createFilter } from '@rollup/pluginutils';
import { DEFAULT_EXCLUDE, DEFAULT_INCLUDE, transform } from '.';

interface LoaderContext {
  getOptions(): { include?: FilterPattern; exclude?: FilterPattern };
  resourcePath: string;
  async(): (
    error: Error | null,
    content?: string,
    sourceMap?: string | object,
  ) => void;
}

export default async function ReactComponentNameLoader(
  this: LoaderContext,
  code: string,
  sourceMap: string | object | undefined,
) {
  const parsedMap =
    typeof sourceMap === 'string' ? JSON.parse(sourceMap) : sourceMap;
  const callback = this.async();
  try {
    const options = this.getOptions();
    const id = this.resourcePath;
    const filter = createFilter(
      options?.include || DEFAULT_INCLUDE,
      options?.exclude || [
        DEFAULT_EXCLUDE,
        // Next.js pages dir specific
        '**/_app.{jsx,tsx,js,ts}',
        '**/_document.{jsx,tsx,js,ts}',
        '**/api/**/*',
        // Million.js specific
        '**/.million/**/*',
      ],
    );
    if (!filter(id)) return callback(null, code, parsedMap);

    const result = await transform(code, id, filter);

    callback(
      null,
      result?.code || '',
      result?.map ? JSON.stringify(result.map) : undefined,
    );
  } catch (e) {
    callback(e as Error);
  }
}
</file>

<file path="src/react-component-name/rolldown.ts">
import { reactComponentNamePlugin } from ".";


export default reactComponentNamePlugin.rolldown;
</file>

<file path="src/react-component-name/rollup.ts">
import reactComponentNamePlugin from '.';

export default reactComponentNamePlugin.rollup;
</file>

<file path="src/react-component-name/rspack.ts">
import reactComponentNamePlugin from '.';

export default reactComponentNamePlugin.rspack;
</file>

<file path="src/react-component-name/tsconfig.json">
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "lib": ["ESNext"],
    "moduleResolution": "node",
    "esModuleInterop": true,
    "strict": true,
    "strictNullChecks": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "skipDefaultLibCheck": true,
    "types": ["@types/node"]
  },
  "include": ["."],
}
</file>

<file path="src/react-component-name/vite.ts">
import { reactComponentNamePlugin } from '.';

export default reactComponentNamePlugin.vite;
</file>

<file path="src/react-component-name/webpack.ts">
import { reactComponentNamePlugin } from '.';

export default reactComponentNamePlugin.webpack;
</file>

<file path="src/web/assets/css/styles.tailwind.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

* {
  outline: none !important;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  backface-visibility: hidden;

  /* WebKit (Chrome, Safari, Edge) specific scrollbar styles */
  &::-webkit-scrollbar {
    width: 6px;
    height: 6px;
  }

  &::-webkit-scrollbar-track {
    border-radius: 10px;
    background: transparent;
  }

  &::-webkit-scrollbar-thumb {
    border-radius: 10px;
    background: rgba(255, 255, 255, 0.3);
  }

  &::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, .4);
  }

  &::-webkit-scrollbar-corner {
    background: transparent;
  }
}

@-moz-document url-prefix() {
  * {
    scrollbar-width: thin;
    scrollbar-color: rgba(255, 255, 255, 0.4) transparent;
    scrollbar-width: 6px;
  }
}


button {
  @apply hover:bg-none;
  @apply outline-none;
  @apply border-none;
  @apply transition-colors ease-linear;
  @apply cursor-pointer;
}

input {
  @apply outline-none;
  @apply border-none;
  @apply bg-none bg-transparent;
  @apply outline-none;
  @apply placeholder:text-neutral-500 placeholder:italic placeholder:text-xs;
  @apply placeholder-shown:truncate;
}

svg {
  @apply w-auto h-auto;
  @apply pointer-events-none;
}

/*
  Using CSS content with data attributes is more performant than:
  1. React re-renders with JSX text content
  2. Direct DOM manipulation methods:
     - element.textContent (creates/updates text nodes, triggers repaint)
     - element.innerText (triggers reflow by computing styles & layout)
     - element.innerHTML (heavy parsing, triggers reflow, security risks)
  3. Multiple data attributes with complex CSS concatenation

  This approach:
  - Avoids React reconciliation
  - Uses browser's native CSS engine (optimized content updates)
  - Minimizes main thread work
  - Reduces DOM operations
  - Avoids forced reflows (layout recalculation)
  - Only triggers necessary repaints
  - Keeps pseudo-element updates in render layer
*/
.with-data-text {
  overflow: hidden;
  &::before {
    content: attr(data-text);
    @apply block;
    @apply truncate;
  }
}

#react-scan-toolbar {
  @apply fixed left-0 top-0;
  @apply flex flex-col;
  @apply rounded-lg shadow-lg;
  @apply font-mono text-[13px] text-white;
  @apply bg-black;
  @apply select-none;
  @apply cursor-move;
  @apply opacity-0;
  @apply z-[2147483678];
  @apply animate-fade-in animation-duration-300 animation-delay-300;
  @apply shadow-[0_4px_12px_rgba(0,0,0,0.2)];
  @apply place-self-start;

  /* [CURSOR GENERATED] Anti-blur fixes:
   * We removed will-change-transform and replaced it with these properties
   * because will-change was causing stacking context issues and inconsistent
   * text rendering. The new properties work together to force proper
   * GPU acceleration without z-index side effects:
   */
  transform: translate3d(0, 0, 0);      /* Forces GPU acceleration without causing stacking issues */
  backface-visibility: hidden;          /* Prevents blurry text during transforms */
  perspective: 1000;                    /* Creates proper 3D context for crisp text */
  -webkit-transform-style: preserve-3d; /* Ensures consistent text rendering across browsers */
  transform-style: preserve-3d;
}

.button {
  &:hover {
    background: rgba(255, 255, 255, 0.1);
  }

  &:active {
    background: rgba(255, 255, 255, 0.15);
  }
}

.resize-line-wrapper {
  @apply absolute;
  @apply overflow-hidden;
}

.resize-line {
  @apply absolute inset-0;
  @apply overflow-hidden;
  @apply bg-black;
  @apply transition-all;

  svg {
    @apply absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2;
  }
}

.resize-right,
.resize-left {
  @apply inset-y-0;
  @apply w-6;
  @apply cursor-ew-resize;

  .resize-line-wrapper {
    @apply inset-y-0;
    @apply w-1/2;
  }

  &:hover {
    .resize-line {
      @apply translate-x-0;
    }
  }
}
.resize-right {
  @apply right-0;
  @apply translate-x-1/2;

  .resize-line-wrapper {
    @apply right-0;
  }
  .resize-line {
    @apply rounded-r-lg;
    @apply -translate-x-full;
  }
}

.resize-left {
  @apply left-0;
  @apply -translate-x-1/2;

  .resize-line-wrapper {
    @apply left-0;
  }
  .resize-line {
    @apply rounded-l-lg;
    @apply translate-x-full;
  }
}

.resize-top,
.resize-bottom {
  @apply inset-x-0;
  @apply h-6;
  @apply cursor-ns-resize;

  .resize-line-wrapper {
    @apply inset-x-0;
    @apply h-1/2;
  }

  &:hover {
    .resize-line {
      @apply translate-y-0;
    }
  }
}
.resize-top {
  @apply top-0;
  @apply -translate-y-1/2;

  .resize-line-wrapper {
    @apply top-0;
  }
  .resize-line {
    @apply rounded-t-lg;
    @apply translate-y-full;
  }
}

.resize-bottom {
  @apply bottom-0;
  @apply translate-y-1/2;

  .resize-line-wrapper {
    @apply bottom-0;
  }
  .resize-line {
    @apply rounded-b-lg;
    @apply -translate-y-full;
  }
}

.react-scan-header {
  @apply flex items-center gap-x-2;
  @apply pl-3 pr-2;
  @apply min-h-9;
  @apply border-b-1 border-[#222];
  @apply whitespace-nowrap overflow-hidden;
}

.react-scan-replay-button,
.react-scan-close-button {
  @apply flex items-center;
  @apply p-1;
  @apply min-w-fit;
  @apply rounded;
  @apply transition-all duration-300;
}

.react-scan-replay-button {
  @apply relative;
  @apply overflow-hidden;
  @apply !bg-purple-500/50;

  &:hover {
    @apply bg-purple-500/25;
  }

  &.disabled {
    @apply opacity-50;
    @apply pointer-events-none;
  }

  &:before {
    content: '';
    @apply absolute;
    @apply inset-0;
    @apply -translate-x-full;
    animation: shimmer 2s infinite;
    background: linear-gradient(to right,
      transparent,
      rgba(142, 97, 227, 0.3),
      transparent);
  }
}

.react-scan-close-button {
  @apply bg-white/10;

  &:hover {
    @apply bg-white/15;
  }
}

@keyframes shimmer {
  100% {
    @apply translate-x-full;
  }
}

.react-section-header {
  @apply sticky z-100;
  @apply flex items-center gap-x-2;
  @apply px-3;
  @apply w-full h-7;
  @apply text-[#888] truncate;
  @apply bg-[#0a0a0a] border-b-1 border-[#222];
}

.react-scan-section {
  @apply flex flex-col;
  @apply px-2;
  @apply text-[#888];
  @apply before:content-[attr(data-section)] before:text-gray-500;
  @apply text-xs;

  > .react-scan-property {
    @apply -ml-3.5;
  }
}

.react-scan-property {
  @apply relative;
  @apply flex flex-col;
  @apply pl-8;
  @apply border-l-1 border-transparent;
  @apply overflow-hidden;
}

.react-scan-property-content {
  @apply flex-1 flex flex-col;
  @apply min-h-7;
  @apply max-w-full;
  @apply overflow-hidden;
}

.react-scan-string {
  color: #9ecbff;
}

.react-scan-number {
  color: #79c7ff;
}

.react-scan-boolean {
  color: #56b6c2;
}

.react-scan-key {
  @apply w-fit max-w-60;
  @apply text-white whitespace-nowrap;
}

.react-scan-input {
  @apply text-white;
  @apply bg-black;
}

@keyframes blink {
  from { @apply opacity-100; }
  to { @apply opacity-0; }
}

.react-scan-arrow {
  @apply absolute top-0 left-7;
  @apply flex items-center justify-center;
  @apply cursor-pointer;
  @apply w-6 h-7;
  @apply -translate-x-full;
  @apply z-10;

  > svg {
    @apply transition-transform;
  }
}

.react-scan-expandable {
  @apply grid grid-rows-[0fr];
  @apply transition-all duration-75;

  &.react-scan-expanded {
    @apply grid-rows-[1fr];
    @apply duration-100;
  }
}

.react-scan-nested {
  @apply relative;
  @apply overflow-hidden;

  &:before {
    content: '';
    @apply absolute top-0 left-0;
    @apply w-[1px] h-full;
    @apply bg-gray-500/30;
  }
}

.react-scan-settings {
  @apply absolute inset-0;
  @apply flex flex-col gap-4;
  @apply py-2 px-4;
  @apply text-[#888];

  >div {
    @apply flex items-center justify-between;
    @apply transition-colors duration-300;
  }
}

.react-scan-preview-line {
  @apply relative;
  @apply flex items-center min-h-7 gap-x-2;
}

.react-scan-flash-overlay {
  @apply absolute inset-0;
  @apply opacity-0;
  @apply z-50;
  @apply pointer-events-none;
  @apply transition-opacity;
  @apply mix-blend-multiply;
  @apply bg-purple-500/90;
}

.react-scan-toggle {
  @apply relative;
  @apply inline-flex;
  @apply w-10 h-6;

  input {
    @apply absolute inset-0;
    @apply opacity-0 z-20;
    @apply cursor-pointer;
    @apply w-full h-full;
  }

  input:checked {
    +div {
      @apply bg-[#5f3f9a];

      &::before {
        @apply translate-x-full;
        @apply left-auto;
        @apply border-[#5f3f9a];
      }
    }
  }

  >div {
    @apply absolute inset-1;
    @apply bg-neutral-700;
    @apply rounded-full;
    @apply pointer-events-none;
    @apply transition-colors duration-300;

    &:before {
      @apply content-[''];
      @apply absolute top-1/2 left-0;
      @apply -translate-y-1/2;
      @apply w-4 h-4;
      @apply bg-white;
      @apply border-2 border-neutral-700;
      @apply rounded-full;
      @apply shadow-sm;
      @apply transition-all duration-300;
    }
  }
}

.react-scan-flash-active {
  @apply opacity-40;
  @apply transition-opacity duration-300;
}

.react-scan-inspector-overlay {
  @apply flex flex-col;
  @apply opacity-0;
  @apply transition-opacity duration-300;

  &.fade-out {
    @apply opacity-0;
  }

  &.fade-in {
    @apply opacity-100;
  }
}

.react-scan-what-changed {
  ul {
    @apply list-disc;
    @apply pl-4;
  }

  li {
    @apply whitespace-nowrap;
    > div {
      @apply flex items-center justify-between gap-x-2;
    }
  }
}

.count-badge {
  @apply flex gap-x-2 items-center;
  @apply px-1.5 py-0.5;
  @apply text-[#a855f7] text-xs font-medium tabular-nums rounded-[4px] origin-center;
  @apply bg-[#a855f7]/10;
  @apply origin-center;
  @apply transition-all duration-300 delay-150;
}

.count-flash {
  @apply animate-count-flash;
}

.count-flash-white {
  @apply animate-count-flash-shake !delay-500;
}

.change-scope {
  @apply flex items-center gap-x-1;
  @apply text-[#666];
  @apply text-xs;
  @apply font-mono;

  > div {
    @apply px-1.5 py-0.5;
    @apply text-xs font-medium tabular-nums rounded-[4px] origin-center;
    @apply origin-center;
    @apply transition-all duration-300 delay-150;

    &[data-flash="true"] {
      @apply bg-[#a855f7]/10 text-[#a855f7];
    }
  }
}

.react-scan-slider {
  @apply relative;
  @apply min-h-6;

  > input {
    @apply absolute inset-0;
    @apply opacity-0;
  }

  &:before {
    @apply content-[''];
    @apply absolute inset-x-0 top-1/2 -translate-y-1/2;
    @apply h-1.5;
    @apply bg-[#8e61e3]/40;
    @apply rounded-lg;
    @apply pointer-events-none;
  }

  &:after {
    @apply content-[''];
    @apply absolute inset-x-0 -inset-y-2;
    @apply -z-10;
  }

  span {
    @apply absolute left-0 top-1/2 -translate-y-1/2;
    @apply w-2.5 h-2.5;
    @apply rounded-lg;
    @apply bg-[#8e61e3];
    @apply pointer-events-none;
    @apply transition-transform duration-75;
  }
}

.resize-v-line {
  @apply flex items-center justify-center;
  @apply min-w-1 max-w-1;
  @apply w-full h-full;
  @apply transition-colors;

  &:hover,
  &:active {
    > span {
      @apply bg-[#222];
    }

    svg {
      @apply opacity-100;
    }
  }

  &::before {
    @apply content-[""];
    @apply absolute inset-0 left-1/2 -translate-x-1/2;
    @apply w-[1px];
    @apply bg-[#222];
    @apply transition-colors;
  }

  > span {
    @apply absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2;
    @apply w-1.5 h-4.5;
    @apply rounded;
    @apply transition-colors;
  }

  svg {
    @apply absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2;
    @apply text-neutral-400 rotate-90;
    @apply opacity-0;
    @apply transition-opacity;
    @apply z-50;
  }
}


.tree-node-search-highlight {
  @apply truncate;

  span {
    @apply py-[1px];
    @apply font-medium bg-yellow-300 text-black rounded-sm;
  }

  .single {
    @apply px-[2px] mr-[1px];
  }

  .regex {
    @apply px-[2px];
  }

  .start {
    @apply rounded-l-sm ml-[1px];
  }

  .end {
    @apply rounded-r-sm mr-[1px];
  }

  .middle {
    @apply rounded-sm mx-[1px];
  }
}

.react-scan-toolbar-notification {
  @apply absolute inset-x-0;
  @apply flex items-center gap-x-2;
  @apply p-1 pl-2 text-[10px];
  @apply text-neutral-300;
  @apply bg-black/90;
  @apply transition-transform;

  &:before {
    @apply content-[''];
    @apply absolute inset-x-0;
    @apply bg-black;
    @apply h-2;
  }

  &.position-top {
    @apply top-full -translate-y-full;
    @apply rounded-b-lg;

    &::before {
      @apply top-0 -translate-y-full;
    }
  }

  &.position-bottom {
    @apply bottom-full translate-y-full;
    @apply rounded-t-lg;

    &::before {
      @apply bottom-0 translate-y-full;
    }

  }

  &.is-open {
    @apply translate-y-0;
  }
}


.react-scan-header-item {
  @apply absolute inset-0 -translate-y-[200%];
  @apply transition-transform duration-300;

  &.is-visible {
    @apply translate-y-0;
  }
}

.react-scan-components-tree:has(.resize-v-line:hover, .resize-v-line:active) .tree {
  overflow: hidden;
}



.react-scan-expandable {
  display: grid;
  grid-template-rows: 0fr;
  @apply overflow-hidden;
  @apply transition-all duration-75;
  transition-timing-function: ease-out;

  > * {
    min-height: 0;
  }

  &.react-scan-expanded {
    grid-template-rows: 1fr;
    transition-duration: 100ms;
  }
}
</file>

<file path="src/web/components/copy-to-clipboard/index.tsx">
import { memo } from 'preact/compat';
import { useCallback, useEffect, useState } from 'preact/hooks';
import { cn } from '~web/utils/helpers';
import { Icon } from '../icon';

interface CopyToClipboardProps {
  text: string;
  children?: (props: {
    ClipboardIcon: JSX.Element;
    onClick: (e: MouseEvent) => void;
  }) => JSX.Element;
  onCopy?: (success: boolean, text: string) => void;
  className?: string;
  iconSize?: number;
}

export const CopyToClipboard = /* @__PURE__ */ memo(
  ({
    text,
    children,
    onCopy,
    className,
    iconSize = 14,
  }: CopyToClipboardProps): JSX.Element => {
    const [isCopied, setIsCopied] = useState(false);

    useEffect(() => {
      if (isCopied) {
        const timeout = setTimeout(() => setIsCopied(false), 600);
        return () => {
          clearTimeout(timeout);
        };
      }
    }, [isCopied]);

    const copyToClipboard = useCallback(
      (e: MouseEvent) => {
        e.preventDefault();
        e.stopPropagation();

        navigator.clipboard.writeText(text).then(
          () => {
            setIsCopied(true);
            onCopy?.(true, text);
          },
          () => {
            onCopy?.(false, text);
          },
        );
      },
      [text, onCopy],
    );

    const ClipboardIcon = (
      <button
        onClick={copyToClipboard}
        type="button"
        className={cn(
          'z-10',
          'flex items-center justify-center',
          'hover:text-dev-pink-400',
          'transition-colors duration-200 ease-in-out',
          'cursor-pointer',
          `size-[${iconSize}px]`,
          className,
        )}
      >
        <Icon
          name={`icon-${isCopied ? 'check' : 'copy'}`}
          size={[iconSize]}
          className={cn(isCopied && 'text-green-500')}
        />
      </button>
    );

    if (!children) {
      return ClipboardIcon;
    }

    return children({
      ClipboardIcon,
      onClick: copyToClipboard,
    });
  },
);
</file>

<file path="src/web/components/icon/index.tsx">
import type { JSX } from 'preact';
import { type ForwardedRef, forwardRef } from 'preact/compat';

export interface SVGIconProps {
  size?: number | Array<number>;
  name: string;
  fill?: string;
  stroke?: string;
  className?: string;
  externalURL?: string;
  style?: JSX.CSSProperties;
}

export const Icon = forwardRef(({
  size = 15,
  name,
  fill = 'currentColor',
  stroke = 'currentColor',
  className,
  externalURL = '',
  style,
}: SVGIconProps, ref: ForwardedRef<SVGSVGElement>) => {
  const width = Array.isArray(size) ? size[0] : size;
  const height = Array.isArray(size) ? size[1] || size[0] : size;

  const path = `${externalURL}#${name}`;

  return (
    <svg
      ref={ref}
      width={`${width}px`}
      height={`${height}px`}
      fill={fill}
      stroke={stroke}
      className={className}
      style={{
        ...style,
        minWidth: `${width}px`,
        maxWidth: `${width}px`,
        minHeight: `${height}px`,
        maxHeight: `${height}px`,
      }}
    >
      <title>{name}</title>
      <use href={path} />
    </svg>
  );
});
</file>

<file path="src/web/components/slider/index.tsx">
import { useCallback, useEffect, useRef } from "preact/hooks";
import { cn } from "~web/utils/helpers";

interface SliderProps {
  className?: string;
  onChange: (e: Event) => void;
  value: number;
  min: number;
  max: number;
  totalUpdates?: number;
}

export const Slider = ({
  value,
  min,
  max,
  onChange,
  className,
  totalUpdates = max + 1,
}: SliderProps) => {
  const refThumb = useRef<HTMLSpanElement>(null);
  const refLastValue = useRef<number>(value);

  const updateThumbPosition = useCallback((value: number) => {
    if (!refThumb.current) return;

    const range = Math.max(1, max - min);
    const valueOffset = value - min;
    const percentage = min === max ? 0 : Math.min(100, Math.round((valueOffset / range) * 100));

    refThumb.current.style.setProperty('left', `${percentage}%`);
  }, [min, max]);

  /**
   * biome-ignore lint/correctness/useExhaustiveDependencies:
   * we rely on min, max and value to update the thumb position
   */
  useEffect(() => {
    updateThumbPosition(value);
  }, [min, max, value]);

  const handleChange = useCallback((e: Event) => {
    const target = e.target as HTMLInputElement;
    const newValue = Number.parseInt(target.value, 10);

    if (newValue >= totalUpdates) {
      return;
    }

    if (refLastValue.current !== newValue) {
      refLastValue.current = newValue;
      updateThumbPosition(newValue);
      onChange(e);
    }
  }, [onChange, updateThumbPosition, totalUpdates]);

  return (
    <div
      onPointerDown={(e) => {
        e.stopPropagation();
      }}
      className={cn(
        'react-scan-slider relative',
        'flex-1',
        className
      )}
    >
      <input
        type="range"
        value={value}
        min={min}
        max={max}
        onChange={handleChange}
        className={cn(
          'react-scan-slider',
          'flex-1',
          'h-1.5',
          'bg-gray-200',
          'rounded-lg',
          'appearance-none',
          'cursor-pointer',
          className
        )}
      />
      <div
        className={cn(
          'absolute inset-0 right-2',
          'pointer-events-none',
        )}
      >
        <span ref={refThumb} />
      </div>
    </div>
  );
};
</file>

<file path="src/web/components/sticky-section/index.tsx">
import { memo } from 'preact/compat';
import { useCallback, useRef, useState } from 'preact/hooks';
import type { useMergedRefs } from '~web/hooks/use-merged-refs';

interface StickyRenderProps {
  refSticky: ReturnType<typeof useMergedRefs<HTMLElement>>;
  isSticky: boolean;
  calculateStickyTop: (removeSticky?: boolean) => void;
}

interface StickyProps {
  children: (props: StickyRenderProps) => preact.JSX.Element;
}

export const StickySection = /* @__PURE__ */ memo(
  ({ children }: StickyProps) => {
    const refScrollableElement = useRef<HTMLElement | null>(null);
    const refScrollAtTop = useRef(false);
    const [isSticky, setIsSticky] = useState(false);
    const refRafId = useRef(0);

    const calculateStickyTop = useCallback((removeSticky = false) => {
      const stickyElements = Array.from(
        refScrollableElement.current?.children || [],
      ) as HTMLElement[];
      if (!stickyElements.length) return;

      let cumulativeHeight = 0;

      for (const element of stickyElements) {
        const sticky = element as HTMLElement;
        if (sticky.dataset.sticky) {
          if (removeSticky) {
            sticky.style.removeProperty('top');
          } else {
            sticky.style.setProperty('top', `${cumulativeHeight}px`);
          }
          cumulativeHeight += sticky.offsetHeight;
        }
      }
    }, []);

    const refSticky = useCallback(
      (node: HTMLElement | null) => {
        if (!node) {
          requestAnimationFrame(() => {
            calculateStickyTop();
          });
          return;
        }

        refScrollableElement.current = node.parentElement;
        node.dataset.sticky = 'true';

        const handleClick = () => {
          if (!node.dataset.disableScroll) {
            refScrollableElement.current?.scrollTo({
              top: Number(node.style.top) ?? 0,
              behavior: 'smooth',
            });
          }
        };

        node.onclick = handleClick;
        calculateStickyTop();

        const handleScroll = () => {
          cancelAnimationFrame(refRafId.current);
          refRafId.current = requestAnimationFrame(() => {
            if (!node || !refScrollableElement.current) return;

            const refRect = node.getBoundingClientRect();
            const containerRect =
              refScrollableElement.current.getBoundingClientRect();

            const stickyOffset = Number.parseInt(getComputedStyle(node).top);
            refScrollAtTop.current = refScrollableElement.current.scrollTop > 0;

            const stickyActive =
              refScrollAtTop.current &&
              refRect.top <= containerRect.top + stickyOffset;

            if (stickyActive !== isSticky) {
              setIsSticky(stickyActive);
            }

            calculateStickyTop();
          });
        };

        refScrollableElement.current?.addEventListener('scroll', handleScroll, {
          passive: true,
        });
      },
      [isSticky, calculateStickyTop],
    );

    return children({
      refSticky,
      isSticky,
      calculateStickyTop,
    });
  },
);
</file>

<file path="src/web/components/svg-sprite/index.tsx">
export const SvgSprite = () => {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
      <title>React Scan Icons</title>
      <symbol id="icon-inspect" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M12.034 12.681a.498.498 0 0 1 .647-.647l9 3.5a.5.5 0 0 1-.033.943l-3.444 1.068a1 1 0 0 0-.66.66l-1.067 3.443a.5.5 0 0 1-.943.033z" />
        <path d="M5 3a2 2 0 0 0-2 2" />
        <path d="M19 3a2 2 0 0 1 2 2" />
        <path d="M5 21a2 2 0 0 1-2-2" />
        <path d="M9 3h1" />
        <path d="M9 21h2" />
        <path d="M14 3h1" />
        <path d="M3 9v1" />
        <path d="M21 9v2" />
        <path d="M3 14v1" />
      </symbol>

      <symbol id="icon-focus" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M12.034 12.681a.498.498 0 0 1 .647-.647l9 3.5a.5.5 0 0 1-.033.943l-3.444 1.068a1 1 0 0 0-.66.66l-1.067 3.443a.5.5 0 0 1-.943.033z" />
        <path d="M21 11V5a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h6" />
      </symbol>

      <symbol id="icon-next" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M6 9h6V5l7 7-7 7v-4H6V9z" />
      </symbol>

      <symbol id="icon-previous" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M18 15h-6v4l-7-7 7-7v4h6v6z" />
      </symbol>

      <symbol id="icon-close" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="18" y1="6" x2="6" y2="18" />
        <line x1="6" y1="6" x2="18" y2="18" />
      </symbol>

      <symbol id="icon-replay" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M3 7V5a2 2 0 0 1 2-2h2" />
        <path d="M17 3h2a2 2 0 0 1 2 2v2" />
        <path d="M21 17v2a2 2 0 0 1-2 2h-2" />
        <path d="M7 21H5a2 2 0 0 1-2-2v-2" />
        <circle cx="12" cy="12" r="1" />
        <path d="M18.944 12.33a1 1 0 0 0 0-.66 7.5 7.5 0 0 0-13.888 0 1 1 0 0 0 0 .66 7.5 7.5 0 0 0 13.888 0" />
      </symbol>

      <symbol id="icon-ellipsis" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="1" />
        <circle cx="19" cy="12" r="1" />
        <circle cx="5" cy="12" r="1" />
      </symbol>

      <symbol id="icon-copy" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect width="14" height="14" x="8" y="8" rx="2" ry="2" />
        <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2" />
      </symbol>

      <symbol id="icon-check" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M20 6 9 17l-5-5" />
      </symbol>

      <symbol id="icon-chevron-right" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="m9 18 6-6-6-6" />
      </symbol>

      <symbol id="icon-settings" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z" /><circle cx="12" cy="12" r="3" />
      </symbol>

      <symbol id="icon-flame" viewBox="0 0 24 24">
        <path d="M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z" />
      </symbol>

      <symbol id="icon-function" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect width="18" height="18" x="3" y="3" rx="2" ry="2" />
        <path d="M9 17c2 0 2.8-1 2.8-2.8V10c0-2 1-3.3 3.2-3" />
        <path d="M9 11.2h5.7" />
      </symbol>

      <symbol id="icon-triangle-alert" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3" />
        <path d="M12 9v4" />
        <path d="M12 17h.01" />
      </symbol>

      <symbol id="icon-gallery-horizontal-end" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M2 7v10" /><path d="M6 5v14" />
        <rect width="12" height="18" x="10" y="3" rx="2" />
      </symbol>

      <symbol id="icon-search" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="11" cy="11" r="8" />
        <line x1="21" y1="21" x2="16.65" y2="16.65" />
      </symbol>

      <symbol id="icon-lock" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect width="18" height="11" x="3" y="11" rx="2" ry="2" />
        <path d="M7 11V7a5 5 0 0 1 10 0v4" />
      </symbol>

      <symbol id="icon-lock-open" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect width="18" height="11" x="3" y="11" rx="2" ry="2" />
        <path d="M7 11V7a5 5 0 0 1 9.9-1" />
      </symbol>

      <symbol id="icon-sanil" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M2 13a6 6 0 1 0 12 0 4 4 0 1 0-8 0 2 2 0 0 0 4 0" />
        <circle cx="10" cy="13" r="8" />
        <path d="M2 21h12c4.4 0 8-3.6 8-8V7a2 2 0 1 0-4 0v6" />
        <path d="M18 3 19.1 5.2" />
      </symbol>
    </svg>
  )
};
</file>

<file path="src/web/components/toggle/index.tsx">
import type { JSX } from 'preact';
import { cn } from '~web/utils/helpers';

interface ToggleProps extends JSX.HTMLAttributes<HTMLInputElement> {
  checked: boolean;
  onChange: ((e: Event) => void);
  className?: string;
};

export const Toggle = ({
  className,
  ...props
}: ToggleProps) => {
  return (
    <div className={cn('react-scan-toggle', className)}>
      <input
        type="checkbox"
        {...props}
      />
      <div />
    </div>
  );
};
</file>

<file path="src/web/hooks/use-delayed-value.ts">
import { useEffect, useState } from 'preact/hooks';

/**
 * Delays a boolean value change by a specified duration.
 * Perfect for coordinating animations with state changes.
 *
 * @param {boolean} value - The boolean value to delay
 * @param {number} onDelay - Milliseconds to wait before changing to true
 * @param {number} [offDelay] - Milliseconds to wait before changing to false (defaults to onDelay)
 * @returns {boolean} The delayed value
 *
 * @example
 * // Delay both transitions by 300ms
 * const isVisible = useDelayedValue(show, 300);
 *
 * @example
 * // Quick show (100ms), slow hide (500ms)
 * const isVisible = useDelayedValue(show, 100, 500);
 *
 * @example
 * // Use with CSS transitions
 * const isVisible = useDelayedValue(show, 300);
 * return (
 *   <div
 *     className="transition-all duration-300"
 *     style={{
 *       opacity: isVisible ? 1 : 0,
 *       transform: isVisible ? 'none' : 'translateY(4px)'
 *     }}
 *   >
 *     {content}
 *   </div>
 * );
 */
export const useDelayedValue = (
  value: boolean,
  onDelay: number,
  offDelay: number = onDelay,
): boolean => {
  const [delayedValue, setDelayedValue] = useState(value);

  /*
   * biome-ignore lint/correctness/useExhaustiveDependencies:
   * delayedValue is intentionally omitted to prevent unnecessary timeouts
   * and used only in the early return check
   */
  useEffect(() => {
    if (value === delayedValue) return;

    const delay = value ? onDelay : offDelay;
    const timeout = setTimeout(() => setDelayedValue(value), delay);

    return () => clearTimeout(timeout);
  }, [value, onDelay, offDelay]);

  return delayedValue;
};
</file>

<file path="src/web/hooks/use-merged-refs.ts">
import type { Ref, RefCallback } from 'preact';
import { type MutableRefObject, useCallback } from 'preact/compat';

type PossibleRef<T> = Ref<T> | undefined;

const assignRef = <T>(ref: PossibleRef<T>, value: T) => {
  if (typeof ref === 'function') {
    ref(value);
  } else if (ref !== null) {
    (ref as MutableRefObject<T>).current = value;
  }
};

const mergeRefs = <T>(...refs: PossibleRef<T>[]) => {
  return (node: T) => {
    for (const ref of refs) {
      if (ref) {
        assignRef(ref, node);
      }
    }
  };
};

export const useMergedRefs = <T>(...refs: PossibleRef<T>[]) => {
  return useCallback(mergeRefs(...refs), [...refs]) as RefCallback<T>;
};
</file>

<file path="src/web/hooks/use-virtual-list.ts">
import {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'preact/hooks';

export interface VirtualItem {
  key: number;
  index: number;
  start: number;
}

export const useVirtualList = (options: {
  count: number;
  getScrollElement: () => HTMLElement | null;
  estimateSize: () => number;
  overscan?: number;
}) => {
  const { count, getScrollElement, estimateSize, overscan = 5 } = options;
  const [scrollTop, setScrollTop] = useState(0);
  const [containerHeight, setContainerHeight] = useState(0);
  const refResizeObserver = useRef<ResizeObserver>();
  const refScrollElement = useRef<HTMLElement | null>(null);
  const refRafId = useRef<number | null>(null);
  const itemHeight = estimateSize();

  const updateContainer = useCallback((entries?: ResizeObserverEntry[]) => {
    if (!refScrollElement.current) return;

    const height =
      entries?.[0]?.contentRect.height ??
      refScrollElement.current.getBoundingClientRect().height;
    setContainerHeight(height);
  }, []);

  const debouncedUpdateContainer = useCallback(() => {
    if (refRafId.current !== null) {
      cancelAnimationFrame(refRafId.current);
    }
    refRafId.current = requestAnimationFrame(() => {
      updateContainer();
      refRafId.current = null;
    });
  }, [updateContainer]);

  useEffect(() => {
    const element = getScrollElement();
    if (!element) return;

    refScrollElement.current = element;

    const handleScroll = () => {
      if (!refScrollElement.current) return;
      setScrollTop(refScrollElement.current.scrollTop);
    };

    updateContainer();

    if (!refResizeObserver.current) {
      refResizeObserver.current = new ResizeObserver(() => {
        debouncedUpdateContainer();
      });
    }
    refResizeObserver.current.observe(element);

    element.addEventListener('scroll', handleScroll, { passive: true });

    const mutationObserver = new MutationObserver(debouncedUpdateContainer);
    mutationObserver.observe(element, {
      attributes: true,
      childList: true,
      subtree: true,
    });

    return () => {
      element.removeEventListener('scroll', handleScroll);
      if (refResizeObserver.current) {
        refResizeObserver.current.disconnect();
      }
      mutationObserver.disconnect();
      if (refRafId.current !== null) {
        cancelAnimationFrame(refRafId.current);
      }
    };
  }, [getScrollElement, updateContainer, debouncedUpdateContainer]);

  const visibleRange = useMemo(() => {
    const start = Math.floor(scrollTop / itemHeight);
    const visibleCount = Math.ceil(containerHeight / itemHeight);

    return {
      start: Math.max(0, start - overscan),
      end: Math.min(count, start + visibleCount + overscan),
    };
  }, [scrollTop, itemHeight, containerHeight, count, overscan]);

  const items = useMemo(() => {
    const virtualItems: VirtualItem[] = [];
    for (let index = visibleRange.start; index < visibleRange.end; index++) {
      virtualItems.push({
        key: index,
        index,
        start: index * itemHeight,
      });
    }
    return virtualItems;
  }, [visibleRange, itemHeight]);

  return {
    virtualItems: items,
    totalSize: count * itemHeight,
    scrollTop,
    containerHeight,
  };
};
</file>

<file path="src/web/utils/preact/constant.ts">
import {
  type Attributes,
  type Component,
  type FunctionComponent,
  createElement,
} from 'preact';

function CONSTANT_UPDATE() {
  return false;
}

export function constant<P extends Attributes>(
  Component: FunctionComponent<P>,
) {
  function Memoed(this: Component<P>, props: P) {
    this.shouldComponentUpdate = CONSTANT_UPDATE;
    return createElement<P>(Component, props);
  }
  Memoed.displayName = `Memo(${Component.displayName || Component.name})`;
  Memoed.prototype.isReactComponent = true;
  Memoed._forwarded = true;
  return Memoed;
}
</file>

<file path="src/web/utils/preact/use-constant.ts">
import { useDebugValue } from 'preact/hooks';
import { useLazyRef } from './use-lazy-ref';

export function useConstant<T>(supplier: () => T): T {
  const value = useLazyRef(supplier).current;
  useDebugValue(value);
  return value;
}
</file>

<file path="src/web/utils/preact/use-lazy-ref.ts">
import { useDebugValue, useRef, type MutableRef } from 'preact/hooks';

export function useLazyRef<T>(supplier: () => T): MutableRef<T> {
  const ref = useRef<MutableRef<T> | null>();

  if (!ref.current) {
    ref.current = {
      current: supplier(),
    };
  }

  useDebugValue(ref.current);

  return ref.current;
}
</file>

<file path="src/web/utils/constants.ts">
export const IS_CLIENT = typeof window !== 'undefined';
</file>

<file path="src/web/utils/create-store.ts">
/**
 * Adapted from zustand v5.0.3
 *
 * https://github.com/pmndrs/zustand
 *
 * Do not modify unless you know what you are doing
 */
type SetStateInternal<T> = {
  _(
    partial: T | Partial<T> | { _(state: T): T | Partial<T> }['_'],
    replace?: false,
  ): void;
  _(state: T | { _(state: T): T }['_'], replace: true): void;
}['_'];

export interface StoreApi<T> {
  setState: SetStateInternal<T>;
  getState: () => T;
  getInitialState: () => T;
  subscribe: {
    (listener: (state: T, prevState: T) => void): () => void;
    <U>(
      selector: (state: T) => U,
      listener: (selectedState: U, prevSelectedState: U) => void,
    ): () => void;
  };
}

export type ExtractState<S> = S extends { getState: () => infer T } ? T : never;

type Get<T, K, F> = K extends keyof T ? T[K] : F;

export type Mutate<S, Ms> = number extends Ms['length' & keyof Ms]
  ? S
  : Ms extends []
    ? S
    : Ms extends [[infer Mi, infer Ma], ...infer Mrs]
      ? Mutate<StoreMutators<S, Ma>[Mi & StoreMutatorIdentifier], Mrs>
      : never;

export type StateCreator<
  T,
  Mis extends [StoreMutatorIdentifier, unknown][] = [],
  Mos extends [StoreMutatorIdentifier, unknown][] = [],
  U = T,
> = ((
  setState: Get<Mutate<StoreApi<T>, Mis>, 'setState', never>,
  getState: Get<Mutate<StoreApi<T>, Mis>, 'getState', never>,
  store: Mutate<StoreApi<T>, Mis>,
) => U) & { $$storeMutators?: Mos };

// biome-ignore lint/correctness/noUnusedVariables: <explanation>
export interface StoreMutators<S, A> {}
export type StoreMutatorIdentifier = keyof StoreMutators<unknown, unknown>;

type CreateStore = {
  <T, Mos extends [StoreMutatorIdentifier, unknown][] = []>(
    initializer: StateCreator<T, [], Mos>,
  ): Mutate<StoreApi<T>, Mos>;

  <T>(): <Mos extends [StoreMutatorIdentifier, unknown][] = []>(
    initializer: StateCreator<T, [], Mos>,
  ) => Mutate<StoreApi<T>, Mos>;
};

type CreateStoreImpl = <
  T,
  Mos extends [StoreMutatorIdentifier, unknown][] = [],
>(
  initializer: StateCreator<T, [], Mos>,
) => Mutate<StoreApi<T>, Mos>;

const createStoreImpl: CreateStoreImpl = (createState) => {
  type TState = ReturnType<typeof createState>;
  type Listener = (state: TState, prevState: TState) => void;
  let state: TState;
  const listeners: Set<Listener> = new Set();

  const setState: StoreApi<TState>['setState'] = (partial, replace) => {
    const nextState =
      typeof partial === 'function'
        ? (partial as (state: TState) => TState)(state)
        : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state =
        (replace ?? (typeof nextState !== 'object' || nextState === null))
          ? (nextState as TState)
          : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };

  const getState: StoreApi<TState>['getState'] = () => state;

  const getInitialState: StoreApi<TState>['getInitialState'] = () =>
    initialState;

  const subscribe: StoreApi<TState>['subscribe'] = (
    selectorOrListener:
      | ((state: TState, prevState: TState) => void)
      // biome-ignore lint/suspicious/noExplicitAny: <explanation>
      | ((state: TState) => any),
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    listener?: (selectedState: any, prevSelectedState: any) => void,
  ) => {
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    let selector: ((state: TState) => any) | undefined;
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    let actualListener: (state: any, prevState: any) => void;

    if (listener) {
      // Selector subscription case
      // biome-ignore lint/suspicious/noExplicitAny: <explanation>
      selector = selectorOrListener as (state: TState) => any;
      actualListener = listener;
    } else {
      // Regular subscription case
      actualListener = selectorOrListener as (
        state: TState,
        prevState: TState,
      ) => void;
    }

    let currentSlice = selector ? selector(state) : undefined;

    const wrappedListener = (newState: TState, previousState: TState) => {
      if (selector) {
        const nextSlice = selector(newState);
        const prevSlice = selector(previousState);
        if (!Object.is(currentSlice, nextSlice)) {
          currentSlice = nextSlice;
          actualListener(nextSlice, prevSlice);
        }
      } else {
        actualListener(newState, previousState);
      }
    };

    listeners.add(wrappedListener);
    // Unsubscribe
    return () => listeners.delete(wrappedListener);
  };

  const api = { setState, getState, getInitialState, subscribe };
  const initialState = (state = createState(setState, getState, api));
  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
  return api as any;
};

export const createStore = ((createState) =>
  createState ? createStoreImpl(createState) : createStoreImpl) as CreateStore;
</file>

<file path="src/web/utils/geiger.ts">
// MIT License
// Copyright (c) 2025 Kristian Dupont

import { isFirefox, readLocalStorage } from './helpers';

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// Taken from: https://github.com/kristiandupont/react-geiger/blob/main/src/Geiger.tsx

// Simple throttle for high-frequency calls
let lastPlayTime = 0;
const MIN_INTERVAL = 32; // ~30fps throttle

// Pre-calculate common values
const BASE_VOLUME = 0.5;
const FREQ_MULTIPLIER = 200;
const DEFAULT_VOLUME = 0.5;

// Ensure volume is between 0 and 1
const storedVolume = Math.max(
  0,
  Math.min(1, readLocalStorage<number>('react-scan-volume') ?? DEFAULT_VOLUME),
);

// Audio configurations for different browsers
const config = {
  firefox: {
    duration: 0.02,
    oscillatorType: 'sine' as const,
    startFreq: 220,
    endFreq: 110,
    attack: 0.0005,
    volumeMultiplier: storedVolume,
  },
  default: {
    duration: 0.001,
    oscillatorType: 'sine' as const,
    startFreq: 440,
    endFreq: 220,
    attack: 0.0005,
    volumeMultiplier: storedVolume,
  },
} as const; // Make entire config readonly

// Cache the selected config
const audioConfig = isFirefox ? config.firefox : config.default;

/**
 * Plays a Geiger counter-like click sound
 * Cross-browser compatible version (Firefox, Chrome, Safari)
 */
export const playGeigerClickSound = (
  audioContext: AudioContext,
  amplitude: number,
) => {
  const now = performance.now();
  if (now - lastPlayTime < MIN_INTERVAL) {
    return;
  }
  lastPlayTime = now;

  // Cache currentTime for consistent timing
  const currentTime = audioContext.currentTime;
  const { duration, oscillatorType, startFreq, endFreq, attack } = audioConfig;

  // Pre-calculate volume once
  const volume =
    Math.max(BASE_VOLUME, amplitude) * audioConfig.volumeMultiplier;

  // Create and configure nodes in one go
  const oscillator = new OscillatorNode(audioContext, {
    type: oscillatorType,
    frequency: startFreq + amplitude * FREQ_MULTIPLIER,
  });

  const gainNode = new GainNode(audioContext, {
    gain: 0,
  });

  // Schedule all parameters
  oscillator.frequency.exponentialRampToValueAtTime(
    endFreq,
    currentTime + duration,
  );
  gainNode.gain.linearRampToValueAtTime(volume, currentTime + attack);

  // Connect and schedule playback
  oscillator.connect(gainNode).connect(audioContext.destination);

  oscillator.start(currentTime);
  oscillator.stop(currentTime + duration);
};
</file>

<file path="src/web/utils/helpers.ts">
import {
  type Fiber,
  MemoComponentTag,
  SimpleMemoComponentTag,
  SuspenseComponentTag,
  getDisplayName,
  hasMemoCache,
} from 'bippy';
import { type ClassValue, clsx } from 'clsx';
import { IS_CLIENT } from './constants';
import { twMerge } from 'tailwind-merge';

export const cn = (...inputs: Array<ClassValue>): string => {
  return twMerge(clsx(inputs));
};

export const isFirefox =
  /* @__PURE__ */ typeof navigator !== 'undefined' &&
  navigator.userAgent.includes('Firefox');

export const onIdle = (callback: () => void) => {
  if ('scheduler' in globalThis) {
    return globalThis.scheduler.postTask(callback, {
      priority: 'background',
    });
  }
  if ('requestIdleCallback' in window) {
    return requestIdleCallback(callback);
  }
  return setTimeout(callback, 0);
};

export const throttle = <E>(
  callback: (e?: E) => void,
  delay: number,
): ((e?: E) => void) => {
  let lastCall = 0;
  return (e?: E) => {
    const now = Date.now();
    if (now - lastCall >= delay) {
      lastCall = now;
      return callback(e);
    }
    return undefined;
  };
};

export const tryOrElse = <T>(fn: () => T, defaultValue: T): T => {
  try {
    return fn();
  } catch {
    return defaultValue;
  }
};

export const readLocalStorage = <T>(storageKey: string): T | null => {
  if (!IS_CLIENT) return null;

  try {
    const stored = localStorage.getItem(storageKey);
    return stored ? JSON.parse(stored) : null;
  } catch {
    return null;
  }
};

export const saveLocalStorage = <T>(storageKey: string, state: T): void => {
  if (!IS_CLIENT) return;

  try {
    window.localStorage.setItem(storageKey, JSON.stringify(state));
  } catch {}
};
export const removeLocalStorage = (storageKey: string): void => {
  if (!IS_CLIENT) return;

  try {
    window.localStorage.removeItem(storageKey);
  } catch {}
};

export const toggleMultipleClasses = (
  element: HTMLElement,
  classes: Array<string>,
) => {
  for (const cls of classes) {
    element.classList.toggle(cls);
  }
};

interface WrapperBadge {
  type: 'memo' | 'forwardRef' | 'lazy' | 'suspense' | 'profiler' | 'strict';
  title: string;
  compiler?: boolean;
}

export interface ExtendedDisplayName {
  name: string | null;
  wrappers: Array<string>;
  wrapperTypes: Array<WrapperBadge>;
}

// React internal tags not exported by bippy
const LazyComponentTag = 24;
const ProfilerTag = 12;

export const getExtendedDisplayName = (fiber: Fiber): ExtendedDisplayName => {
  if (!fiber) {
    return {
      name: 'Unknown',
      wrappers: [],
      wrapperTypes: [],
    };
  }

  const { tag, type, elementType } = fiber;
  let name = getDisplayName(type);
  const wrappers: Array<string> = [];
  const wrapperTypes: Array<WrapperBadge> = [];

  if (
    hasMemoCache(fiber) ||
    tag === SimpleMemoComponentTag ||
    tag === MemoComponentTag ||
    (type as { $$typeof?: symbol })?.$$typeof === Symbol.for('react.memo') ||
    (elementType as { $$typeof?: symbol })?.$$typeof ===
      Symbol.for('react.memo')
  ) {
    const compiler = hasMemoCache(fiber);
    wrapperTypes.push({
      type: 'memo',
      title: compiler
        ? 'This component has been auto-memoized by the React Compiler.'
        : 'Memoized component that skips re-renders if props are the same',
      compiler,
    });
  }

  if (tag === LazyComponentTag) {
    wrapperTypes.push({
      type: 'lazy',
      title: 'Lazily loaded component that supports code splitting',
    });
  }

  if (tag === SuspenseComponentTag) {
    wrapperTypes.push({
      type: 'suspense',
      title: 'Component that can suspend while content is loading',
    });
  }

  if (tag === ProfilerTag) {
    wrapperTypes.push({
      type: 'profiler',
      title: 'Component that measures rendering performance',
    });
  }

  if (typeof name === 'string') {
    const wrapperRegex = /^(\w+)\((.*)\)$/;
    let currentName = name;
    while (wrapperRegex.test(currentName)) {
      const match = currentName.match(wrapperRegex);
      if (match?.[1] && match?.[2]) {
        wrappers.unshift(match[1]);
        currentName = match[2];
      } else {
        break;
      }
    }
    name = currentName;
  }

  return {
    name: name || 'Unknown',
    wrappers,
    wrapperTypes,
  };
};
</file>

<file path="src/web/utils/lerp.ts">
export const lerp = (start: number, end: number, t: number) => {
  return start + (end - start) * t;
};
</file>

<file path="src/web/utils/log.ts">
// @ts-nocheck
import { ChangeReason, type Render } from '~core/instrumentation';
import { getLabelText } from '~core/utils';

export const log = (renders: Array<Render>) => {
  const logMap = new Map<
    string,
    Array<{ prev: unknown; next: unknown; type: string; unstable?: boolean }>
  >();
  for (let i = 0, len = renders.length; i < len; i++) {
    const render = renders[i];

    if (!render.componentName) continue;

    const changeLog = logMap.get(render.componentName) ?? [];
    renders;
    const labelText = getLabelText([
      {
        aggregatedCount: 1,

        computedKey: null,
        name: render.componentName,
        frame: null,
        ...render,
        changes: {
          // TODO(Alexis): use a faster reduction method
          type: render.changes.reduce((set, change) => set | change.type, 0),
          unstable: render.changes.some((change) => change.unstable),
        },
        phase: render.phase,
        computedCurrent: null,
      },
    ]);
    if (!labelText) continue;

    let prevChangedProps: Record<string, unknown> | null = null;
    let nextChangedProps: Record<string, unknown> | null = null;

    if (render.changes) {
      for (let i = 0, len = render.changes.length; i < len; i++) {
        const { name, prevValue, nextValue, unstable, type } =
          render.changes[i];
        if (type === ChangeReason.Props) {
          prevChangedProps ??= {};
          nextChangedProps ??= {};
          prevChangedProps[`${unstable ? '' : ''}${name} (prev)`] = prevValue;
          nextChangedProps[`${unstable ? '' : ''}${name} (next)`] = nextValue;
        } else {
          changeLog.push({
            prev: prevValue,
            next: nextValue,
            type: type === ChangeReason.Context ? 'context' : 'state',
            unstable: unstable ?? false,
          });
        }
      }
    }

    if (prevChangedProps && nextChangedProps) {
      changeLog.push({
        prev: prevChangedProps,
        next: nextChangedProps,
        type: 'props',
        unstable: false,
      });
    }

    logMap.set(labelText, changeLog);
  }
  for (const [name, changeLog] of Array.from(logMap.entries())) {
    // biome-ignore lint/suspicious/noConsole: Intended debug output
    console.group(
      `%c${name}`,
      'background: hsla(0,0%,70%,.3); border-radius:3px; padding: 0 2px;',
    );
    for (const { type, prev, next, unstable } of changeLog) {
      // biome-ignore lint/suspicious/noConsole: Intended debug output
      console.log(`${type}:`, unstable ? '' : '', prev, '!==', next);
    }
    // biome-ignore lint/suspicious/noConsole: Intended debug output
    console.groupEnd();
  }
};

export const logIntro = () => {
  if (window.hideIntro) {
    window.hideIntro = undefined;
    return;
  }
  // biome-ignore lint/suspicious/noConsole: Intended debug output
  console.log(
    '%c[] %cReact Scan',
    'font-weight:bold;color:#7a68e8;font-size:20px;',
    'font-weight:bold;font-size:14px;',
  );
  // biome-ignore lint/suspicious/noConsole: Intended debug output
  console.log(
    'Try React Scan Monitoring to target performance issues in production: https://react-scan.com/monitoring',
  );
};
</file>

<file path="src/web/utils/lru.ts">
class LRUNode<Key, Value> {
  public next: LRUNode<Key, Value> | undefined;
  public prev: LRUNode<Key, Value> | undefined;

  constructor(
    public key: Key,
    public value: Value,
  ) {}
}

/**
 * Doubly linked list LRU
 */
export class LRUMap<Key, Value> {
  private nodes = new Map<Key, LRUNode<Key, Value>>();

  private head: LRUNode<Key, Value> | undefined;
  private tail: LRUNode<Key, Value> | undefined;

  constructor(public limit: number) {}

  has(key: Key) {
    return this.nodes.has(key);
  }

  get(key: Key): Value | undefined {
    const result = this.nodes.get(key);
    if (result) {
      this.bubble(result);
      return result.value;
    }
    return undefined;
  }

  set(key: Key, value: Value): void {
    // If node already exists, bubble up
    if (this.nodes.has(key)) {
      const result = this.nodes.get(key);
      if (result) {
        this.bubble(result);
      }
      return;
    }

    // create a new node
    const node = new LRUNode(key, value);

    // Set node as head
    this.insertHead(node);

    // if the map is already at it's limit, remove the old tail
    if (this.nodes.size === this.limit && this.tail) {
      this.delete(this.tail.key);
    }

    this.nodes.set(key, node);
  }

  delete(key: Key): void {
    const result = this.nodes.get(key);

    if (result) {
      this.removeNode(result);
      this.nodes.delete(key);
    }
  }

  private insertHead(node: LRUNode<Key, Value>): void {
    if (this.head) {
      node.next = this.head;
      this.head.prev = node;
    } else {
      this.tail = node;
      node.next = undefined;
    }
    node.prev = undefined;
    this.head = node;
  }

  private removeNode(node: LRUNode<Key, Value>): void {
    // Link previous node to next node
    if (node.prev) {
      node.prev.next = node.next;
    }
    // and vice versa
    if (node.next) {
      node.next.prev = node.prev;
    }

    if (node === this.tail) {
      this.tail = node.prev;
      if (this.tail) {
        this.tail.next = undefined;
      }
    }
  }

  private insertBefore(
    node: LRUNode<Key, Value>,
    newNode: LRUNode<Key, Value>,
  ) {
    newNode.next = node;
    if (node.prev) {
      newNode.prev = node.prev;
      node.prev.next = newNode;
    } else {
      newNode.prev = undefined;
      this.head = newNode;
    }
    node.prev = newNode;
  }

  private bubble(node: LRUNode<Key, Value>) {
    if (node.prev) {
      // Remove the node
      this.removeNode(node);
      // swap places with previous node
      this.insertBefore(node.prev, node);
    }
  }
}
</file>

<file path="src/web/utils/outline.ts">
// THIS FILE WILL BE DELETED

import type { Fiber } from 'bippy';
import { type OutlineKey } from '~core/index';
import type { AggregatedChange } from '~core/instrumentation';

export interface OutlineLabel {
  alpha: number;
  color: { r: number; g: number; b: number };
  reasons: number; // based on Reason enum
  labelText: string;
  textWidth: number;
  activeOutline: Outline;
}

// using intersection observer lets us get the boundingClientRect asynchronously without forcing a reflow.
// The browser can internally optimize the bounding rect query, so this will be faster then meticulously
// Batching getBoundingClientRect at the right time in the browser rendering pipeline.
// batchGetBoundingRects function can return in sub <10ms under good conditions, but may take much longer under poor conditions.
// We interpolate the outline rects to avoid the appearance of jitter
// reference: https://w3c.github.io/IntersectionObserver/
/**
 *
 * @deprecated use getBatchedRectMap
 */
export const batchGetBoundingRects = (
  elements: Array<Element>,
): Promise<Map<Element, DOMRect>> => {
  return new Promise((resolve) => {
    const results = new Map<Element, DOMRect>();
    const observer = new IntersectionObserver((entries) => {
      for (const entry of entries) {
        const element = entry.target;
        const bounds = entry.boundingClientRect;
        results.set(element, bounds);
      }
      observer.disconnect();
      resolve(results);
    });

    for (const element of elements) {
      observer.observe(element);
    }
  });
};

type ComponentName = string;

export interface Outline {
  domNode: Element;
  /** Aggregated render info */ // TODO: Flatten AggregatedRender into Outline to avoid re-creating objects
  // this render is useless when in active outlines (confirm this rob)
  aggregatedRender: AggregatedRender; // maybe we should set this to null when its useless

  /* Active Info- we re-use the Outline object to avoid over-allocing objects, which is why we have a singular aggregatedRender and collection of it (groupedAggregatedRender) */
  alpha: number | null;
  totalFrames: number | null;
  /*
    - Invariant: This scales at a rate of O(unique components rendered at the same (x,y) coordinates)
    - renders with the same x/y position but different fibers will be a different fiber -> aggregated render entry.
  */
  groupedAggregatedRender: Map<Fiber, AggregatedRender> | null;

  /* Rects for interpolation */
  current: DOMRect | null;
  target: DOMRect | null;
  /* This value is computed before the full rendered text is shown, so its only considered an estimate */
  estimatedTextWidth: number | null; // todo: estimated is stupid just make it the actual
}

export enum RenderPhase {
  Mount = 0b001,
  Update = 0b010,
  Unmount = 0b100,
}

export const RENDER_PHASE_STRING_TO_ENUM = {
  mount: RenderPhase.Mount,
  update: RenderPhase.Update,
  unmount: RenderPhase.Unmount,
} as const;

export interface AggregatedRender {
  name: ComponentName;
  frame: number | null;
  phase: number; // union of RenderPhase
  time: number | null;
  aggregatedCount: number;
  forget: boolean;
  changes: AggregatedChange;
  unnecessary: boolean | null;
  didCommit: boolean;
  fps: number;

  computedKey: OutlineKey | null;
  computedCurrent: DOMRect | null; // reference to dom rect to copy over to new outline made at new position
}
</file>

<file path="src/web/utils/pin.ts">
import type { Fiber } from 'bippy';
import { Store } from '~core/index';
import { findComponentDOMNode } from '~web/views/inspector/utils';
import { readLocalStorage } from './helpers';

export interface FiberMetadata {
  componentName: string;
  parent: string;
  position: number;
  sibling: string | null;
  path: string;
  propKeys: string[];
}

const metadata = readLocalStorage<FiberMetadata>('react-scann-pinned');

export const getFiberPath = (fiber: Fiber): string => {
  const pathSegments: string[] = [];
  let currentFiber: Fiber | null = fiber;

  while (currentFiber) {
    const elementType = currentFiber.elementType;
    const name =
      typeof elementType === 'function'
        ? elementType.displayName || elementType.name
        : typeof elementType === 'string'
          ? elementType
          : 'Unknown';

    const index =
      currentFiber.index !== undefined ? `[${currentFiber.index}]` : '';
    pathSegments.unshift(`${name}${index}`);

    currentFiber = currentFiber.return ?? null;
  }

  return pathSegments.join('::');
};

export const getFiberMetadata = (fiber: Fiber): FiberMetadata | null => {
  if (!fiber || !fiber.elementType) return null;

  const componentName = fiber.elementType.name || 'UnknownComponent';
  const position = fiber.index !== undefined ? fiber.index : -1;
  const sibling = fiber.sibling?.elementType?.name || null;

  let parentFiber = fiber.return;
  let parent = 'Root';

  while (parentFiber) {
    const parentName = parentFiber.elementType?.name;

    if (typeof parentName === 'string' && parentName.trim().length > 0) {
      parent = parentName;
      break;
    }

    parentFiber = parentFiber.return;
  }

  const path = getFiberPath(fiber);

  const propKeys = fiber.pendingProps
    ? Object.keys(fiber.pendingProps).filter((key) => key !== 'children')
    : [];

  return { componentName, parent, position, sibling, path, propKeys };
};

const checkFiberMatch = (fiber: Fiber | undefined): boolean => {
  if (!fiber || !fiber.elementType || !metadata?.componentName) return false;

  if (fiber.elementType.name !== metadata.componentName) return false;

  let currentParentFiber = fiber.return;
  let parent = '';

  while (currentParentFiber) {
    if (currentParentFiber.elementType?.name) {
      parent = currentParentFiber.elementType.name;
      break;
    }
    currentParentFiber = currentParentFiber.return;
  }

  if (parent !== metadata.parent) return false;
  if (fiber.index !== metadata.position) return false;

  const fiberPath = getFiberPath(fiber);
  return fiberPath === metadata.path;
};

const fiberQueue: Fiber[] = [];
let isProcessing = false;

const processFiberQueue = (): void => {
  if (isProcessing || fiberQueue.length === 0) return;
  isProcessing = true;

  requestIdleCallback(() => {
    while (fiberQueue.length > 0) {
      const fiber = fiberQueue.shift();
      if (fiber && checkFiberMatch(fiber)) {
        // biome-ignore lint/suspicious/noConsole: Intended debug output
        console.log(' Pinned component found!', fiber);
        isProcessing = false;

        const componentElement = findComponentDOMNode(fiber);

        if (!componentElement) return;

        Store.inspectState.value = {
          kind: 'focused',
          focusedDomElement: componentElement,
          fiber,
        };
        return;
      }
    }
    isProcessing = false;
  });
};

export const enqueueFiber = (fiber: Fiber) => {
  if (metadata === null || metadata.componentName !== fiber.elementType?.name) {
    return;
  }

  fiberQueue.push(fiber);
  if (!isProcessing) processFiberQueue();
};
</file>

<file path="src/web/views/inspector/components-tree/index.tsx">
import {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'preact/hooks';
import { Store } from '~core/index';
import { renderDataMap } from '~core/instrumentation';
import { Icon } from '~web/components/icon';
import {
  LOCALSTORAGE_KEY,
  MIN_CONTAINER_WIDTH,
} from '~web/constants';
import { useVirtualList } from '~web/hooks/use-virtual-list';
import { signalWidget } from '~web/state';
import {
  cn,
  getExtendedDisplayName,
  saveLocalStorage,
} from '~web/utils/helpers';
import { getFiberPath } from '~web/utils/pin';
import { inspectorUpdateSignal } from '../states';
import {
  type InspectableElement,
  getCompositeComponentFromElement,
  getInspectableElements,
} from '../utils';
import {
  type FlattenedNode,
  type TreeNode,
  searchState,
  signalSkipTreeUpdate,
} from './state';

const flattenTree = (
  nodes: TreeNode[],
  depth = 0,
  parentPath: string | null = null,
): FlattenedNode[] => {
  return nodes.reduce<FlattenedNode[]>((acc, node, index) => {
    const nodePath = node.element
      ? getFiberPath(node.fiber)
      : `${parentPath}-${index}`;

    const renderData = node.fiber?.type
      ? renderDataMap.get(node.fiber.type)
      : undefined;

    const flatNode: FlattenedNode = {
      ...node,
      depth,
      nodeId: nodePath,
      parentId: parentPath,
      fiber: node.fiber,
      renderData,
    };
    acc.push(flatNode);

    if (node.children?.length) {
      acc.push(...flattenTree(node.children, depth + 1, nodePath));
    }

    return acc;
  }, []);
};

const getMaxDepth = (nodes: FlattenedNode[]): number => {
  return nodes.reduce((max, node) => Math.max(max, node.depth), 0);
};

const calculateIndentSize = (containerWidth: number, maxDepth: number) => {
  const MIN_INDENT = 0;
  const MAX_INDENT = 24;
  const MIN_TOTAL_INDENT = 24;

  if (maxDepth <= 0) return MAX_INDENT;

  const availableSpace = Math.max(0, containerWidth - MIN_CONTAINER_WIDTH);

  if (availableSpace < MIN_TOTAL_INDENT) return MIN_INDENT;

  const targetTotalIndent = Math.min(
    availableSpace * 0.3,
    maxDepth * MAX_INDENT,
  );
  const baseIndent = targetTotalIndent / maxDepth;

  return Math.max(MIN_INDENT, Math.min(MAX_INDENT, baseIndent));
};

interface TreeNodeItemProps {
  node: FlattenedNode;
  nodeIndex: number;
  hasChildren: boolean;
  isCollapsed: boolean;
  handleTreeNodeClick: (e: Event) => void;
  handleTreeNodeToggle: (e: Event) => void;
  searchValue: typeof searchState.value;
}

const VALID_TYPES = ['memo', 'forwardRef', 'lazy', 'suspense'];

const parseTypeSearch = (query: string) => {
  const typeMatch = query.match(/\[(.*?)\]/);
  if (!typeMatch) return null;

  const typeSearches: string[] = [];
  const parts = typeMatch[1].split(',');
  for (const part of parts) {
    const trimmed = part.trim().toLowerCase();
    if (trimmed) typeSearches.push(trimmed);
  }

  return typeSearches;
};

const isValidTypeSearch = (typeSearches: string[]) => {
  if (typeSearches.length === 0) return false;

  for (const search of typeSearches) {
    let isValid = false;
    for (const validType of VALID_TYPES) {
      if (validType.toLowerCase().includes(search)) {
        isValid = true;
        break;
      }
    }
    if (!isValid) return false;
  }
  return true;
};

const matchesTypeSearch = (
  typeSearches: string[],
  wrapperTypes: Array<{ type: string }>,
) => {
  if (typeSearches.length === 0) return true;
  if (!wrapperTypes.length) return false;

  for (const search of typeSearches) {
    let foundMatch = false;
    for (const wrapper of wrapperTypes) {
      if (wrapper.type.toLowerCase().includes(search)) {
        foundMatch = true;
        break;
      }
    }
    if (!foundMatch) return false;
  }
  return true;
};

const useNodeHighlighting = (
  node: FlattenedNode,
  searchValue: typeof searchState.value,
) => {
  return useMemo(() => {
    const { query, matches } = searchValue;
    const isMatch = matches.some((match) => match.nodeId === node.nodeId);
    const typeSearches = parseTypeSearch(query) || [];
    const searchQuery = query ? query.replace(/\[.*?\]/, '').trim() : '';

    if (!query || !isMatch) {
      return {
        highlightedText: <span className="truncate">{node.label}</span>,
        typeHighlight: false,
      };
    }

    let matchesType = true;
    if (typeSearches.length > 0) {
      if (!node.fiber) {
        matchesType = false;
      } else {
        const { wrapperTypes } = getExtendedDisplayName(node.fiber);
        matchesType = matchesTypeSearch(typeSearches, wrapperTypes);
      }
    }

    let textContent = <span className="truncate">{node.label}</span>;
    if (searchQuery) {
      try {
        if (searchQuery.startsWith('/') && searchQuery.endsWith('/')) {
          const pattern = searchQuery.slice(1, -1);
          const regex = new RegExp(`(${pattern})`, 'i');
          const parts = node.label.split(regex);

          textContent = (
            <span className="tree-node-search-highlight">
              {parts.map((part, index) =>
                regex.test(part) ? (
                  <span
                    key={`${node.nodeId}-${part}`}
                    className={cn('regex', {
                      start: regex.test(part) && index === 0,
                      middle: regex.test(part) && index % 2 === 1,
                      end: regex.test(part) && index === parts.length - 1,
                      '!ml-0': index === 1,
                    })}
                  >
                    {part}
                  </span>
                ) : (
                  part
                ),
              )}
            </span>
          );
        } else {
          const lowerLabel = node.label.toLowerCase();
          const lowerQuery = searchQuery.toLowerCase();
          const index = lowerLabel.indexOf(lowerQuery);

          if (index >= 0) {
            textContent = (
              <span className="tree-node-search-highlight">
                {node.label.slice(0, index)}
                <span className="single">
                  {node.label.slice(index, index + searchQuery.length)}
                </span>
                {node.label.slice(index + searchQuery.length)}
              </span>
            );
          }
        }
      } catch {}
    }

    return {
      highlightedText: textContent,
      typeHighlight: matchesType && typeSearches.length > 0,
    };
  }, [node.label, node.nodeId, node.fiber, searchValue]);
};

const formatTime = (time: number) => {
  if (time > 0) {
    if (time < 0.1 - Number.EPSILON) {
      return '< 0.1';
    }
    if (time < 1000) {
      return Number(time.toFixed(1)).toString();
    }
    return `${(time / 1000).toFixed(1)}k`;
  }
  return '0';
};

const TreeNodeItem = ({
  node,
  nodeIndex,
  hasChildren,
  isCollapsed,
  handleTreeNodeClick,
  handleTreeNodeToggle,
  searchValue,
}: TreeNodeItemProps) => {
  const refRenderCount = useRef<HTMLSpanElement>(null);
  const refPrevRenderCount = useRef(node.renderData?.renderCount ?? 0);

  const { highlightedText, typeHighlight } = useNodeHighlighting(
    node,
    searchValue,
  );

  useEffect(() => {
    const currentRenderCount = node.renderData?.renderCount;
    const element = refRenderCount.current;
    if (
      !element ||
      !refPrevRenderCount.current ||
      !currentRenderCount ||
      refPrevRenderCount.current === currentRenderCount
    ) {
      return;
    }

    element.classList.remove('count-flash');
    void element.offsetWidth;
    element.classList.add('count-flash');

    refPrevRenderCount.current = currentRenderCount;
  }, [node.renderData?.renderCount]);

  const renderTimeInfo = useMemo(() => {
    if (!node.renderData) return null;
    const { selfTime, totalTime, renderCount } = node.renderData;

    if (!renderCount) {
      return null;
    }

    return (
      <span
        className={cn(
          'flex items-center gap-x-0.5 ml-1.5',
          'text-[10px] text-neutral-400',
        )}
      >
        <span
          ref={refRenderCount}
          title={`Self time: ${formatTime(selfTime)}ms\nTotal time: ${formatTime(totalTime)}ms`}
          className="count-badge"
        >
          {renderCount}
        </span>
      </span>
    );
  }, [node.renderData]);

  const componentTypes = useMemo(() => {
    if (!node.fiber) return null;
    const { wrapperTypes } = getExtendedDisplayName(node.fiber);
    const firstWrapperType = wrapperTypes[0];

    return (
      <span
        className={cn(
          'flex items-center gap-x-1',
          'text-[10px] text-neutral-400 tracking-wide',
          'overflow-hidden',
        )}
      >
        {firstWrapperType && (
          <>
            <span
              key={firstWrapperType.type}
              title={firstWrapperType?.title}
              className={cn(
                'rounded py-[1px] px-1',
                'bg-neutral-700 text-neutral-300',
                'truncate',
                firstWrapperType.type === 'memo' && 'bg-[#8e61e3] text-white',
                typeHighlight && 'bg-yellow-300 text-black',
              )}
            >
              {firstWrapperType.type}
            </span>
            {firstWrapperType.compiler && (
              <span className="text-yellow-300 ml-1"></span>
            )}
          </>
        )}
        {wrapperTypes.length > 1 && `${wrapperTypes.length}`}
        {renderTimeInfo}
      </span>
    );
  }, [node.fiber, typeHighlight, renderTimeInfo]);

  return (
    <button
      type="button"
      title={node.title}
      data-index={nodeIndex}
      className={cn(
        'flex items-center gap-x-1',
        'pl-1 pr-2',
        'w-full h-7',
        'text-left',
        'rounded',
        'cursor-pointer select-none',
      )}
      onClick={handleTreeNodeClick}
    >
      <button
        type="button"
        data-index={nodeIndex}
        onClick={handleTreeNodeToggle}
        className={cn('w-6 h-6 flex items-center justify-center', 'text-left')}
      >
        {hasChildren && (
          <Icon
            name="icon-chevron-right"
            size={12}
            className={cn('transition-transform', !isCollapsed && 'rotate-90')}
          />
        )}
      </button>
      {highlightedText}
      {componentTypes}
    </button>
  );
};

export const ComponentsTree = () => {
  const refContainer = useRef<HTMLDivElement>(null);
  const refMainContainer = useRef<HTMLDivElement>(null);
  const refSearchInputContainer = useRef<HTMLDivElement>(null);
  const refSearchInput = useRef<HTMLInputElement>(null);
  const refSelectedElement = useRef<HTMLElement | null>(null);
  const refMaxTreeDepth = useRef(0);
  const refIsHovering = useRef(false);
  const refIsResizing = useRef(false);
  const refResizeHandle = useRef<HTMLDivElement>(null);

  const [flattenedNodes, setFlattenedNodes] = useState<FlattenedNode[]>([]);
  const [collapsedNodes, setCollapsedNodes] = useState<Set<string>>(new Set());
  const [selectedIndex, setSelectedIndex] = useState<number | undefined>(
    undefined,
  );
  const [searchValue, setSearchValue] = useState(searchState.value);

  const visibleNodes = useMemo(() => {
    const visible: FlattenedNode[] = [];
    const nodes = flattenedNodes;
    const nodeMap = new Map(nodes.map((node) => [node.nodeId, node]));

    for (const node of nodes) {
      let isVisible = true;

      let currentNode = node;
      while (currentNode.parentId) {
        const parent = nodeMap.get(currentNode.parentId);
        if (!parent) break;

        if (collapsedNodes.has(parent.nodeId)) {
          isVisible = false;
          break;
        }
        currentNode = parent;
      }

      if (isVisible) {
        visible.push(node);
      }
    }

    return visible;
  }, [collapsedNodes, flattenedNodes]);

  const ITEM_HEIGHT = 28;

  const { virtualItems, totalSize } = useVirtualList({
    count: visibleNodes.length,
    getScrollElement: () => refContainer.current,
    estimateSize: () => ITEM_HEIGHT,
    overscan: 5,
  });

  const handleElementClick = useCallback(
    (element: HTMLElement) => {
      refIsHovering.current = true;
      refSearchInput.current?.blur();
      signalSkipTreeUpdate.value = true;

      const { parentCompositeFiber } =
        getCompositeComponentFromElement(element);
      if (!parentCompositeFiber) return;

      Store.inspectState.value = {
        kind: 'focused',
        focusedDomElement: element,
        fiber: parentCompositeFiber,
      };

      const nodeIndex = visibleNodes.findIndex(
        (node) => node.element === element,
      );
      if (nodeIndex !== -1) {
        setSelectedIndex(nodeIndex);
        const itemTop = nodeIndex * ITEM_HEIGHT;
        const container = refContainer.current;
        if (container) {
          const containerHeight = container.clientHeight;
          const scrollTop = container.scrollTop;

          if (
            itemTop < scrollTop ||
            itemTop + ITEM_HEIGHT > scrollTop + containerHeight
          ) {
            container.scrollTo({
              top: Math.max(0, itemTop - containerHeight / 2),
              behavior: 'instant',
            });
          }
        }
      }
    },
    [visibleNodes],
  );

  const handleTreeNodeClick = useCallback(
    (e: Event) => {
      const target = e.currentTarget as HTMLElement;
      const index = Number(target.dataset.index);
      if (Number.isNaN(index)) return;
      const element = visibleNodes[index].element;
      if (!element) return;
      handleElementClick(element);
    },
    [visibleNodes, handleElementClick],
  );

  const handleToggle = useCallback((nodeId: string) => {
    setCollapsedNodes((prev) => {
      const next = new Set(prev);
      if (next.has(nodeId)) {
        next.delete(nodeId);
      } else {
        next.add(nodeId);
      }
      return next;
    });
  }, []);

  const handleTreeNodeToggle = useCallback(
    (e: Event) => {
      e.stopPropagation();
      const target = e.target as HTMLElement;
      const index = Number(target.dataset.index);
      if (Number.isNaN(index)) return;
      const nodeId = visibleNodes[index].nodeId;
      handleToggle(nodeId);
    },
    [visibleNodes, handleToggle],
  );

  const handleOnChangeSearch = useCallback(
    (query: string) => {
      refSearchInputContainer.current?.classList.remove('!border-red-500');
      const matches: FlattenedNode[] = [];

      if (!query) {
        searchState.value = { query, matches, currentMatchIndex: -1 };
        return;
      }

      if (query.includes('[') && !query.includes(']')) {
        if (query.length > query.indexOf('[') + 1) {
          refSearchInputContainer.current?.classList.add('!border-red-500');
          return;
        }
      }

      const typeSearches = parseTypeSearch(query) || [];
      if (query.includes('[')) {
        if (!isValidTypeSearch(typeSearches)) {
          refSearchInputContainer.current?.classList.add('!border-red-500');
          return;
        }
      }

      const searchQuery = query.replace(/\[.*?\]/, '').trim();
      const isRegex = /^\/.*\/$/.test(searchQuery);
      let matchesLabel = (_label: string) => false;

      if (searchQuery.startsWith('/') && !isRegex) {
        if (searchQuery.length > 1) {
          refSearchInputContainer.current?.classList.add('!border-red-500');
          return;
        }
      }

      if (isRegex) {
        try {
          const pattern = searchQuery.slice(1, -1);
          const regex = new RegExp(pattern, 'i');
          matchesLabel = (label: string) => regex.test(label);
        } catch {
          refSearchInputContainer.current?.classList.add('!border-red-500');
          return;
        }
      } else if (searchQuery) {
        const lowerQuery = searchQuery.toLowerCase();
        matchesLabel = (label: string) =>
          label.toLowerCase().includes(lowerQuery);
      }

      for (const node of flattenedNodes) {
        let matchesSearch = true;

        if (searchQuery) {
          matchesSearch = matchesLabel(node.label);
        }

        if (matchesSearch && typeSearches.length > 0) {
          if (!node.fiber) {
            matchesSearch = false;
          } else {
            const { wrapperTypes } = getExtendedDisplayName(node.fiber);
            matchesSearch = matchesTypeSearch(typeSearches, wrapperTypes);
          }
        }

        if (matchesSearch) {
          matches.push(node);
        }
      }

      searchState.value = {
        query,
        matches,
        currentMatchIndex: matches.length > 0 ? 0 : -1,
      };

      if (matches.length > 0) {
        const firstMatch = matches[0];
        const nodeIndex = visibleNodes.findIndex(
          (node) => node.nodeId === firstMatch.nodeId,
        );
        if (nodeIndex !== -1) {
          const itemTop = nodeIndex * ITEM_HEIGHT;
          const container = refContainer.current;
          if (container) {
            const containerHeight = container.clientHeight;
            container.scrollTo({
              top: Math.max(0, itemTop - containerHeight / 2),
              behavior: 'instant',
            });
          }
        }
      }
    },
    [flattenedNodes, visibleNodes],
  );

  const handleInputChange = useCallback(
    (e: Event) => {
      const target = e.currentTarget as HTMLInputElement;
      if (!target) return;
      handleOnChangeSearch(target.value);
    },
    [handleOnChangeSearch],
  );

  const navigateSearch = useCallback(
    (direction: 'next' | 'prev') => {
      const { matches, currentMatchIndex } = searchState.value;
      if (matches.length === 0) return;

      const newIndex =
        direction === 'next'
          ? (currentMatchIndex + 1) % matches.length
          : (currentMatchIndex - 1 + matches.length) % matches.length;

      searchState.value = {
        ...searchState.value,
        currentMatchIndex: newIndex,
      };

      const currentMatch = matches[newIndex];
      const nodeIndex = visibleNodes.findIndex(
        (node) => node.nodeId === currentMatch.nodeId,
      );
      if (nodeIndex !== -1) {
        setSelectedIndex(nodeIndex);
        const itemTop = nodeIndex * ITEM_HEIGHT;
        const container = refContainer.current;
        if (container) {
          const containerHeight = container.clientHeight;
          container.scrollTo({
            top: Math.max(0, itemTop - containerHeight / 2),
            behavior: 'instant',
          });
        }
      }
    },
    [visibleNodes],
  );

  const updateContainerWidths = useCallback((width: number) => {
    if (refMainContainer.current) {
      refMainContainer.current.style.width = `${width}px`;
    }
    if (refContainer.current) {
      refContainer.current.style.width = `${width}px`;
      const indentSize = calculateIndentSize(width, refMaxTreeDepth.current);
      refContainer.current.style.setProperty(
        '--indentation-size',
        `${indentSize}px`,
      );
    }
  }, []);

  const updateResizeDirection = useCallback((width: number) => {
    if (!refResizeHandle.current) return;

    const parentWidth = signalWidget.value.dimensions.width;
    const maxWidth = Math.floor(parentWidth - (MIN_CONTAINER_WIDTH / 2));

    refResizeHandle.current.classList.remove(
      'cursor-ew-resize',
      'cursor-w-resize',
      'cursor-e-resize',
    );

    if (width <= MIN_CONTAINER_WIDTH) {
      refResizeHandle.current.classList.add('cursor-w-resize');
    } else if (width >= maxWidth) {
      refResizeHandle.current.classList.add('cursor-e-resize');
    } else {
      refResizeHandle.current.classList.add('cursor-ew-resize');
    }
  }, []);

  const handleResize = useCallback(
    (e: MouseEvent) => {
      e.preventDefault();
      e.stopPropagation();

      if (!refContainer.current) return;
      refContainer.current.style.setProperty('pointer-events', 'none');

      refIsResizing.current = true;

      const startX = e.clientX;
      const startWidth = refContainer.current.offsetWidth;
      const parentWidth = signalWidget.value.dimensions.width;
      const maxWidth = Math.floor(parentWidth - (MIN_CONTAINER_WIDTH / 2));

      updateResizeDirection(startWidth);

      const handlePointerMove = (e: PointerEvent) => {
        const delta = startX - e.clientX;
        const newWidth = startWidth + delta;
        updateResizeDirection(newWidth);

        const clampedWidth = Math.min(
          maxWidth,
          Math.max(MIN_CONTAINER_WIDTH, newWidth),
        );
        updateContainerWidths(clampedWidth);
      };

      const handlePointerUp = () => {
        if (!refContainer.current) return;
        refContainer.current.style.removeProperty('pointer-events');
        document.removeEventListener('pointermove', handlePointerMove);
        document.removeEventListener('pointerup', handlePointerUp);

        signalWidget.value = {
          ...signalWidget.value,
          componentsTree: {
            ...signalWidget.value.componentsTree,
            width: refContainer.current.offsetWidth,
          },
        };

        saveLocalStorage(LOCALSTORAGE_KEY, signalWidget.value);
        refIsResizing.current = false;
      };

      document.addEventListener('pointermove', handlePointerMove);
      document.addEventListener('pointerup', handlePointerUp);
    },
    [updateContainerWidths, updateResizeDirection],
  );

  useEffect(() => {
    if (!refContainer.current) return;
    const currentWidth = refContainer.current.offsetWidth;
    updateResizeDirection(currentWidth);

    return signalWidget.subscribe(() => {
      if (!refContainer.current) return;
      updateResizeDirection(refContainer.current.offsetWidth);
    });
  }, [updateResizeDirection]);

  const onPointerLeave = useCallback(() => {
    refIsHovering.current = false;
  }, []);

  // biome-ignore lint/correctness/useExhaustiveDependencies: no deps
  useEffect(() => {
    let isInitialTreeBuild = true;
    const buildTreeFromElements = (elements: Array<InspectableElement>) => {
      const nodeMap = new Map<HTMLElement, TreeNode>();
      const rootNodes: TreeNode[] = [];

      for (const { element, name, fiber } of elements) {
        if (!element) continue;

        let title = name;
        const { name: componentName, wrappers } = getExtendedDisplayName(fiber);
        if (componentName) {
          if (wrappers.length > 0) {
            title = `${wrappers.join('(')}(${componentName})${')'.repeat(wrappers.length)}`;
          } else {
            title = componentName;
          }
        }

        nodeMap.set(element, {
          label: componentName || name,
          title,
          children: [],
          element,
          fiber,
        });
      }

      for (const { element, depth } of elements) {
        if (!element) continue;
        const node = nodeMap.get(element);
        if (!node) continue;

        if (depth === 0) {
          rootNodes.push(node);
        } else {
          let parent = element.parentElement;
          while (parent) {
            const parentNode = nodeMap.get(parent);
            if (parentNode) {
              parentNode.children = parentNode.children || [];
              parentNode.children.push(node);
              break;
            }
            parent = parent.parentElement;
          }
        }
      }

      return rootNodes;
    };

    const updateTree = () => {
      const element = refSelectedElement.current;
      if (!element) return;

      const inspectableElements = getInspectableElements();
      const tree = buildTreeFromElements(inspectableElements);

      if (tree.length > 0) {
        const flattened = flattenTree(tree);
        const newMaxDepth = getMaxDepth(flattened);
        refMaxTreeDepth.current = newMaxDepth;

        updateContainerWidths(signalWidget.value.componentsTree.width);
        setFlattenedNodes(flattened);

        if (isInitialTreeBuild) {
          isInitialTreeBuild = false;
          const focusedIndex = flattened.findIndex(
            (node) => node.element === element,
          );
          if (focusedIndex !== -1) {
            const itemTop = focusedIndex * ITEM_HEIGHT;
            const container = refContainer.current;
            if (container) {
              setTimeout(() => {
                container.scrollTo({
                  top: itemTop,
                  behavior: 'instant',
                });
              }, 96);
            }
          }
        }
      }
    };

    const unsubscribeStore = Store.inspectState.subscribe((state) => {
      if (state.kind === 'focused') {
        if (signalSkipTreeUpdate.value) {
          return;
        }

        handleOnChangeSearch('');
        refSelectedElement.current = state.focusedDomElement as HTMLElement;
        updateTree();
      }
    });

    let rafId = 0;
    const unsubscribeUpdates = inspectorUpdateSignal.subscribe(() => {
      if (Store.inspectState.value.kind === 'focused') {
        cancelAnimationFrame(rafId);
        if (refIsResizing.current) return;

        rafId = requestAnimationFrame(() => {
          signalSkipTreeUpdate.value = false;
          updateTree();
        });
      }
    });

    return () => {
      unsubscribeStore();
      unsubscribeUpdates();

      searchState.value = {
        query: '',
        matches: [],
        currentMatchIndex: -1,
      };
    };
  }, []);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (!refIsHovering.current) return;

      if (!selectedIndex) return;

      switch (e.key) {
        case 'ArrowUp': {
          e.preventDefault();
          e.stopPropagation();

          if (selectedIndex > 0) {
            const currentNode = visibleNodes[selectedIndex - 1];
            if (currentNode?.element) {
              handleElementClick(currentNode.element);
            }
          }
          return;
        }
        case 'ArrowDown': {
          e.preventDefault();
          e.stopPropagation();

          if (selectedIndex < visibleNodes.length - 1) {
            const currentNode = visibleNodes[selectedIndex + 1];
            if (currentNode?.element) {
              handleElementClick(currentNode.element);
            }
          }
          return;
        }
        case 'ArrowLeft': {
          e.preventDefault();
          e.stopPropagation();

          const currentNode = visibleNodes[selectedIndex];
          if (currentNode?.nodeId) {
            handleToggle(currentNode.nodeId);
          }
          return;
        }
        case 'ArrowRight': {
          e.preventDefault();
          e.stopPropagation();

          const currentNode = visibleNodes[selectedIndex];
          if (currentNode?.nodeId) {
            handleToggle(currentNode.nodeId);
          }
          return;
        }
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [selectedIndex, visibleNodes, handleElementClick, handleToggle]);

  useEffect(() => {
    return searchState.subscribe(setSearchValue);
  }, []);

  // biome-ignore lint/correctness/useExhaustiveDependencies: no deps
  useEffect(() => {
    const unsubscribe = signalWidget.subscribe((state) => {
      refMainContainer.current?.style.setProperty('transition', 'width 0.1s');
      updateContainerWidths(state.componentsTree.width);

      setTimeout(() => {
        refMainContainer.current?.style.removeProperty('transition');
      }, 500);
    });
    return unsubscribe;
  }, []);

  return (
    <div className="react-scan-components-tree flex">
      <div
        ref={refResizeHandle}
        onPointerDown={handleResize}
        className="relative resize-v-line"
      >
        <span>
          <Icon name="icon-ellipsis" size={18} />
        </span>
      </div>
      <div ref={refMainContainer} className="flex flex-col h-full">
        <div className="p-2 border-b border-[#1e1e1e]">
          <div
            ref={refSearchInputContainer}
            title={`Search components by:

 Name (e.g., "Button")  Case insensitive, matches any part

 Regular Expression (e.g., "/^Button/")  Use forward slashes

 Wrapper Type (e.g., "[memo,forwardRef]"):
   - Available types: memo, forwardRef, lazy, suspense
   - Matches any part of type name (e.g., "mo" matches "memo")
   - Use commas for multiple types

 Combined Search:
   - Mix name/regex with type: "button [for]"
   - Will match components satisfying both conditions

 Navigation:
   - Enter  Next match
   - Shift + Enter  Previous match
   - Cmd/Ctrl + Enter  Select and focus match
`}
            className={cn(
              'relative',
              'flex items-center gap-x-1 px-2',
              'rounded',
              'border border-transparent',
              'focus-within:border-[#454545]',
              'bg-[#1e1e1e] text-neutral-300',
              'transition-colors',
              'whitespace-nowrap',
              'overflow-hidden',
            )}
          >
            <Icon name="icon-search" size={12} className=" text-neutral-500" />
            <div className="relative flex-1 h-7 overflow-hidden">
              <input
                ref={refSearchInput}
                type="text"
                value={searchState.value.query}
                onClick={(e) => {
                  e.stopPropagation();
                  e.currentTarget.focus();
                }}
                onPointerDown={(e) => {
                  e.stopPropagation();
                }}
                onKeyDown={(e) => {
                  if (e.key === 'Escape') {
                    e.currentTarget.blur();
                  }
                  if (searchState.value.matches.length) {
                    if (e.key === 'Enter' && e.shiftKey) {
                      navigateSearch('prev');
                    } else if (e.key === 'Enter') {
                      if (e.metaKey || e.ctrlKey) {
                        e.preventDefault();
                        e.stopPropagation();
                        handleElementClick(
                          searchState.value.matches[
                            searchState.value.currentMatchIndex
                          ].element as HTMLElement,
                        );

                        e.currentTarget.focus();
                      } else {
                        navigateSearch('next');
                      }
                    }
                  }
                }}
                onChange={handleInputChange}
                className="absolute inset-y-0 inset-x-1"
                placeholder="Component name, /regex/, or [type]"
              />
            </div>
            {searchState.value.query ? (
              <>
                <span className="flex items-center gap-x-0.5 text-xs text-neutral-500">
                  {searchState.value.currentMatchIndex + 1}
                  {'|'}
                  {searchState.value.matches.length}
                </span>
                {!!searchState.value.matches.length && (
                  <>
                    <button
                      type="button"
                      onClick={(e) => {
                        e.stopPropagation();
                        navigateSearch('prev');
                      }}
                      className="button rounded w-4 h-4 flex items-center justify-center text-neutral-400 hover:text-neutral-300"
                    >
                      <Icon
                        name="icon-chevron-right"
                        className="-rotate-90"
                        size={12}
                      />
                    </button>
                    <button
                      type="button"
                      onClick={(e) => {
                        e.stopPropagation();
                        navigateSearch('next');
                      }}
                      className="button rounded w-4 h-4 flex items-center justify-center text-neutral-400 hover:text-neutral-300"
                    >
                      <Icon
                        name="icon-chevron-right"
                        className="rotate-90"
                        size={12}
                      />
                    </button>
                  </>
                )}
                <button
                  type="button"
                  onClick={(e) => {
                    e.stopPropagation();
                    handleOnChangeSearch('');
                  }}
                  className="button rounded w-4 h-4 flex items-center justify-center text-neutral-400 hover:text-neutral-300"
                >
                  <Icon name="icon-close" size={12} />
                </button>
              </>
            ) : (
              !!flattenedNodes.length && (
                <span className="text-xs text-neutral-500">
                  {flattenedNodes.length}
                </span>
              )
            )}
          </div>
        </div>
        <div className="flex-1 overflow-hidden">
          <div
            ref={refContainer}
            onPointerLeave={onPointerLeave}
            className="tree h-full overflow-auto will-change-transform"
          >
            <div
              className="relative w-full"
              style={{
                height: totalSize,
              }}
            >
              {virtualItems.map((virtualItem) => {
                const node = visibleNodes[virtualItem.index];
                if (!node) return null;

                const isSelected =
                  Store.inspectState.value.kind === 'focused' &&
                  node.element === Store.inspectState.value.focusedDomElement;
                const isKeyboardSelected = virtualItem.index === selectedIndex;

                return (
                  <div
                    key={node.nodeId}
                    className={cn(
                      'absolute left-0 w-full overflow-hidden',
                      'text-neutral-400 hover:text-neutral-300',
                      'bg-transparent hover:bg-[#5f3f9a]/20',
                      (isSelected || isKeyboardSelected) &&
                        'text-neutral-300 bg-[#5f3f9a]/40 hover:bg-[#5f3f9a]/40',
                    )}
                    style={{
                      top: virtualItem.start,
                      height: ITEM_HEIGHT,
                    }}
                  >
                    <div
                      className="w-full h-full"
                      style={{
                        paddingLeft: `calc(${node.depth} * var(--indentation-size))`,
                      }}
                    >
                      <TreeNodeItem
                        node={node}
                        nodeIndex={virtualItem.index}
                        hasChildren={!!node.children?.length}
                        isCollapsed={collapsedNodes.has(node.nodeId)}
                        handleTreeNodeClick={handleTreeNodeClick}
                        handleTreeNodeToggle={handleTreeNodeToggle}
                        searchValue={searchValue}
                      />
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/web/views/inspector/components-tree/state.ts">
import { signal } from '@preact/signals';
import type { Fiber } from 'bippy';
import type { RenderData } from '~core/instrumentation';

export interface TreeNode {
  label: string;
  title?: string;
  fiber: Fiber;
  element?: HTMLElement;
  children?: TreeNode[];
  renderData?: RenderData;
}

export interface FlattenedNode extends TreeNode {
  depth: number;
  nodeId: string;
  parentId: string | null;
  fiber: Fiber;
}

export const searchState = signal<{
  query: string;
  matches: FlattenedNode[];
  currentMatchIndex: number;
}>({
  query: '',
  matches: [],
  currentMatchIndex: -1,
});

export interface TreeItem {
  name: string;
  depth: number;
  element: HTMLElement;
  fiber: Fiber;
}

export const signalSkipTreeUpdate = /* @__PURE__ */ signal(false);
</file>

<file path="src/web/views/inspector/overlay/index.tsx">
import { type Fiber, getDisplayName } from 'bippy';
import { useEffect, useRef } from 'preact/hooks';
import { ReactScanInternals, Store } from '~core/index';

import { signalIsSettingsOpen, signalWidgetViews } from '~web/state';
import { IS_CLIENT } from '~web/utils/constants';
import { cn, throttle } from '~web/utils/helpers';
import { lerp } from '~web/utils/lerp';
import {
  type States,
  findComponentDOMNode,
  getAssociatedFiberRect,
  getCompositeComponentFromElement,
  nonVisualTags,
} from '../utils';

type DrawKind = 'locked' | 'inspecting';

interface Rect {
  left: number;
  top: number;
  width: number;
  height: number;
}

interface LockIconRect {
  x: number;
  y: number;
  width: number;
  height: number;
}

const ANIMATION_CONFIG = {
  frameInterval: 1000 / 60,
  speeds: {
    fast: 0.51,
    slow: 0.1,
    off: 0,
  },
} as const;

export const OVERLAY_DPR = IS_CLIENT
  ? /* @__PURE__ */ window.devicePixelRatio || 1
  : 1;

export const currentLockIconRect: LockIconRect | null = null;

export const ScanOverlay = () => {
  const refCanvas = useRef<HTMLCanvasElement>(null);
  const refEventCatcher = useRef<HTMLDivElement>(null);
  const refCurrentRect = useRef<Rect | null>(null);
  const refCurrentLockIconRect = useRef<LockIconRect | null>(null);
  const refLastHoveredElement = useRef<Element | null>(null);
  const refRafId = useRef<number>(0);
  const refTimeout = useRef<TTimer>();
  const refCleanupMap = useRef(
    new Map<States['kind'] | 'fade-out', () => void>(),
  );
  const refIsFadingOut = useRef(false);
  const refLastFrameTime = useRef<number>(0);

  const drawLockIcon = (
    ctx: CanvasRenderingContext2D,
    x: number,
    y: number,
    size: number,
  ) => {
    ctx.save();
    ctx.strokeStyle = 'white';
    ctx.fillStyle = 'white';
    ctx.lineWidth = 1.5;

    const shackleWidth = size * 0.6;
    const shackleHeight = size * 0.5;
    const shackleX = x + (size - shackleWidth) / 2;
    const shackleY = y;

    ctx.beginPath();
    ctx.arc(
      shackleX + shackleWidth / 2,
      shackleY + shackleHeight / 2,
      shackleWidth / 2,
      Math.PI,
      0,
      false,
    );
    ctx.stroke();

    const bodyWidth = size * 0.8;
    const bodyHeight = size * 0.5;
    const bodyX = x + (size - bodyWidth) / 2;
    const bodyY = y + shackleHeight / 2;

    ctx.fillRect(bodyX, bodyY, bodyWidth, bodyHeight);
    ctx.restore();
  };

  const drawStatsPill = (
    ctx: CanvasRenderingContext2D,
    rect: Rect,
    kind: 'locked' | 'inspecting',
    fiber: Fiber | null,
  ) => {
    if (!fiber) return;

    const pillHeight = 24;
    const pillPadding = 8;
    const componentName =
      (fiber?.type && getDisplayName(fiber.type)) ?? 'Unknown';
    const text = componentName;

    ctx.save();
    ctx.font = '12px system-ui, -apple-system, sans-serif';
    const textMetrics = ctx.measureText(text);
    const textWidth = textMetrics.width;
    const lockIconSize = kind === 'locked' ? 14 : 0;
    const lockIconPadding = kind === 'locked' ? 6 : 0;
    const pillWidth =
      textWidth + pillPadding * 2 + lockIconSize + lockIconPadding;

    const pillX = rect.left;
    const pillY = rect.top - pillHeight - 4;

    ctx.fillStyle = 'rgb(37, 37, 38, .75)';
    ctx.beginPath();
    ctx.roundRect(pillX, pillY, pillWidth, pillHeight, 3);
    ctx.fill();

    if (kind === 'locked') {
      const lockX = pillX + pillPadding;
      const lockY = pillY + (pillHeight - lockIconSize) / 2 + 2;
      drawLockIcon(ctx, lockX, lockY, lockIconSize);
      refCurrentLockIconRect.current = {
        x: lockX,
        y: lockY,
        width: lockIconSize,
        height: lockIconSize,
      };
    } else {
      refCurrentLockIconRect.current = null;
    }

    ctx.fillStyle = 'white';
    ctx.textBaseline = 'middle';
    const textX =
      pillX +
      pillPadding +
      (kind === 'locked' ? lockIconSize + lockIconPadding : 0);
    ctx.fillText(text, textX, pillY + pillHeight / 2);
    ctx.restore();
  };

  const drawRect = (
    canvas: HTMLCanvasElement,
    ctx: CanvasRenderingContext2D,
    kind: DrawKind,
    fiber: Fiber | null,
  ) => {
    if (!refCurrentRect.current) return;
    const rect = refCurrentRect.current;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.strokeStyle = 'rgba(142, 97, 227, 0.5)';
    ctx.fillStyle = 'rgba(173, 97, 230, 0.10)';

    if (kind === 'locked') {
      ctx.setLineDash([]);
    } else {
      ctx.setLineDash([4]);
    }

    ctx.lineWidth = 1;
    ctx.fillRect(rect.left, rect.top, rect.width, rect.height);
    ctx.strokeRect(rect.left, rect.top, rect.width, rect.height);

    drawStatsPill(ctx, rect, kind, fiber);
  };

  const animate = (
    canvas: HTMLCanvasElement,
    ctx: CanvasRenderingContext2D,
    targetRect: Rect,
    kind: DrawKind,
    parentCompositeFiber: Fiber,
    onComplete?: () => void,
  ) => {
    const speed = ReactScanInternals.options.value
      .animationSpeed as keyof typeof ANIMATION_CONFIG.speeds;
    const t = ANIMATION_CONFIG.speeds[speed] ?? ANIMATION_CONFIG.speeds.off;

    const animationFrame = (timestamp: number) => {
      if (
        timestamp - refLastFrameTime.current <
        ANIMATION_CONFIG.frameInterval
      ) {
        refRafId.current = requestAnimationFrame(animationFrame);
        return;
      }
      refLastFrameTime.current = timestamp;

      if (!refCurrentRect.current) {
        cancelAnimationFrame(refRafId.current);
        return;
      }

      refCurrentRect.current = {
        left: lerp(refCurrentRect.current.left, targetRect.left, t),
        top: lerp(refCurrentRect.current.top, targetRect.top, t),
        width: lerp(refCurrentRect.current.width, targetRect.width, t),
        height: lerp(refCurrentRect.current.height, targetRect.height, t),
      };

      drawRect(canvas, ctx, kind, parentCompositeFiber);

      const stillMoving =
        Math.abs(refCurrentRect.current.left - targetRect.left) > 0.1 ||
        Math.abs(refCurrentRect.current.top - targetRect.top) > 0.1 ||
        Math.abs(refCurrentRect.current.width - targetRect.width) > 0.1 ||
        Math.abs(refCurrentRect.current.height - targetRect.height) > 0.1;

      if (stillMoving) {
        refRafId.current = requestAnimationFrame(animationFrame);
      } else {
        refCurrentRect.current = targetRect;
        drawRect(canvas, ctx, kind, parentCompositeFiber);
        cancelAnimationFrame(refRafId.current);
        ctx.restore();
        onComplete?.();
      }
    };

    cancelAnimationFrame(refRafId.current);
    clearTimeout(refTimeout.current);

    refRafId.current = requestAnimationFrame(animationFrame);

    refTimeout.current = setTimeout(() => {
      cancelAnimationFrame(refRafId.current);
      refCurrentRect.current = targetRect;
      drawRect(canvas, ctx, kind, parentCompositeFiber);
      ctx.restore();
      onComplete?.();
    }, 1000);
  };

  const setupOverlayAnimation = (
    canvas: HTMLCanvasElement,
    ctx: CanvasRenderingContext2D,
    targetRect: Rect,
    kind: DrawKind,
    parentCompositeFiber: Fiber,
  ) => {
    ctx.save();

    if (!refCurrentRect.current) {
      refCurrentRect.current = targetRect;
      drawRect(canvas, ctx, kind, parentCompositeFiber);
      ctx.restore();
      return;
    }

    animate(canvas, ctx, targetRect, kind, parentCompositeFiber);
  };

  const drawHoverOverlay = async (
    overlayElement: Element | null,
    canvas: HTMLCanvasElement | null,
    ctx: CanvasRenderingContext2D | null,
    kind: DrawKind,
  ) => {
    if (!overlayElement || !canvas || !ctx) return;

    const { parentCompositeFiber } =
      getCompositeComponentFromElement(overlayElement);
    const targetRect = await getAssociatedFiberRect(overlayElement);

    if (!parentCompositeFiber || !targetRect) return;

    setupOverlayAnimation(canvas, ctx, targetRect, kind, parentCompositeFiber);
  };

  const unsubscribeAll = () => {
    for (const cleanup of refCleanupMap.current.values()) {
      cleanup?.();
    }
  };

  const cleanupCanvas = (canvas: HTMLCanvasElement) => {
    const ctx = canvas.getContext('2d');
    if (ctx) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
    refCurrentRect.current = null;
    refCurrentLockIconRect.current = null;
    refLastHoveredElement.current = null;
    canvas.classList.remove('fade-in');
    refIsFadingOut.current = false;
  };

  const startFadeOut = (onComplete?: () => void) => {
    if (!refCanvas.current || refIsFadingOut.current) return;

    const handleTransitionEnd = (e: TransitionEvent) => {
      if (
        !refCanvas.current ||
        e.propertyName !== 'opacity' ||
        !refIsFadingOut.current
      ) {
        return;
      }
      refCanvas.current.removeEventListener(
        'transitionend',
        handleTransitionEnd,
      );
      cleanupCanvas(refCanvas.current);
      onComplete?.();
    };
    const existingListener = refCleanupMap.current.get('fade-out');
    if (existingListener) {
      existingListener();
      refCleanupMap.current.delete('fade-out');
    }

    refCanvas.current.addEventListener('transitionend', handleTransitionEnd);
    refCleanupMap.current.set('fade-out', () => {
      refCanvas.current?.removeEventListener(
        'transitionend',
        handleTransitionEnd,
      );
    });

    refIsFadingOut.current = true;
    refCanvas.current.classList.remove('fade-in');
    requestAnimationFrame(() => {
      refCanvas.current?.classList.add('fade-out');
    });
  };

  const startFadeIn = () => {
    if (!refCanvas.current) return;
    refIsFadingOut.current = false;
    refCanvas.current.classList.remove('fade-out');
    requestAnimationFrame(() => {
      refCanvas.current?.classList.add('fade-in');
    });
  };

  const handleHoverableElement = (componentElement: Element) => {
    if (componentElement === refLastHoveredElement.current) return;

    refLastHoveredElement.current = componentElement;

    if (nonVisualTags.has(componentElement.tagName)) {
      startFadeOut();
    } else {
      startFadeIn();
    }

    Store.inspectState.value = {
      kind: 'inspecting',
      hoveredDomElement: componentElement,
    };
  };

  const handleNonHoverableArea = () => {
    if (
      !refCurrentRect.current ||
      !refCanvas.current ||
      refIsFadingOut.current
    ) {
      return;
    }

    startFadeOut();
  };

  const handlePointerMove = throttle((e?: PointerEvent) => {
    const state = Store.inspectState.peek();
    if (state.kind !== 'inspecting' || !refEventCatcher.current) return;

    refEventCatcher.current.style.pointerEvents = 'none';
    const element = document.elementFromPoint(e?.clientX ?? 0, e?.clientY ?? 0);

    refEventCatcher.current.style.removeProperty('pointer-events');

    clearTimeout(refTimeout.current);

    if (element && element !== refCanvas.current) {
      const { parentCompositeFiber } = getCompositeComponentFromElement(
        element as Element,
      );
      if (parentCompositeFiber) {
        const componentElement = findComponentDOMNode(parentCompositeFiber);
        if (componentElement) {
          handleHoverableElement(componentElement);
          return;
        }
      }
    }

    handleNonHoverableArea();
  }, 32);

  const isClickInLockIcon = (e: MouseEvent, canvas: HTMLCanvasElement) => {
    const currentRect = refCurrentLockIconRect.current;
    if (!currentRect) return false;

    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;
    const adjustedX = x / OVERLAY_DPR;
    const adjustedY = y / OVERLAY_DPR;

    return (
      adjustedX >= currentRect.x &&
      adjustedX <= currentRect.x + currentRect.width &&
      adjustedY >= currentRect.y &&
      adjustedY <= currentRect.y + currentRect.height
    );
  };

  const handleLockIconClick = (state: States) => {
    if (state.kind === 'focused') {
      Store.inspectState.value = {
        kind: 'inspecting',
        hoveredDomElement: state.focusedDomElement,
      };
    }
  };

  const handleElementClick = (e: MouseEvent) => {
    const clickableElements = [
      'react-scan-inspect-element',
      'react-scan-power',
    ];
    // avoid capturing the synthetic event sent back to the toolbar, we don't want to block click events on it ever
    if (
      e.target instanceof HTMLElement &&
      clickableElements.includes(e.target.id)
    ) {
      return;
    }

    const tagName = refLastHoveredElement.current?.tagName;
    if (tagName && nonVisualTags.has(tagName)) {
      return;
    }

    e.preventDefault();
    e.stopPropagation();

    const element =
      refLastHoveredElement.current ??
      document.elementFromPoint(e.clientX, e.clientY);
    if (!element) return;

    const clickedEl = e.composedPath().at(0);

    if (
      clickedEl instanceof HTMLElement &&
      clickableElements.includes(clickedEl.id)
    ) {
      const syntheticEvent = new MouseEvent(e.type, e);
      // @ts-ignore - this allows to know to not re-process this event when this event handler captures it
      syntheticEvent.__reactScanSyntheticEvent = true;
      clickedEl.dispatchEvent(syntheticEvent);
      return;
    }
    const { parentCompositeFiber } = getCompositeComponentFromElement(
      element as Element,
    );
    if (!parentCompositeFiber) return;

    const componentElement = findComponentDOMNode(parentCompositeFiber);

    if (!componentElement) {
      refLastHoveredElement.current = null;
      Store.inspectState.value = {
        kind: 'inspect-off',
      };
      return;
    }

    Store.inspectState.value = {
      kind: 'focused',
      focusedDomElement: componentElement,
      fiber: parentCompositeFiber,
    };
  };

  const handleClick = (e: MouseEvent) => {
    // @ts-ignore - metadata added to toolbar button events we create and dispatch
    if (e.__reactScanSyntheticEvent) {
      return;
    }

    const state = Store.inspectState.peek();
    const canvas = refCanvas.current;
    if (!canvas || !refEventCatcher.current) return;

    if (isClickInLockIcon(e, canvas)) {
      e.preventDefault();
      e.stopPropagation();
      handleLockIconClick(state);
      return;
    }

    if (state.kind === 'inspecting') {
      handleElementClick(e);
    }
  };

  const handleKeyDown = (e: KeyboardEvent) => {
    if (e.key !== 'Escape') return;

    const state = Store.inspectState.peek();
    const canvas = refCanvas.current;
    if (!canvas) return;

    if (document.activeElement?.id === 'react-scan-root') {
      return;
    }

    signalWidgetViews.value = {
      view: 'none',
    };

    if (state.kind === 'focused' || state.kind === 'inspecting') {
      e.preventDefault();
      e.stopPropagation();

      switch (state.kind) {
        case 'focused': {
          startFadeIn();
          refCurrentRect.current = null;
          refLastHoveredElement.current = state.focusedDomElement;
          Store.inspectState.value = {
            kind: 'inspecting',
            hoveredDomElement: state.focusedDomElement,
          };
          break;
        }
        case 'inspecting': {
          startFadeOut(() => {
            signalIsSettingsOpen.value = false;
            Store.inspectState.value = {
              kind: 'inspect-off',
            };
          });
          break;
        }
      }
    }
  };

  const handleStateChange = (
    state: States,
    canvas: HTMLCanvasElement,
    ctx: CanvasRenderingContext2D,
  ) => {
    refCleanupMap.current.get(state.kind)?.();

    if (refEventCatcher.current) {
      if (state.kind !== 'inspecting') {
        refEventCatcher.current.style.pointerEvents = 'none';
      }
    }

    if (refRafId.current) {
      cancelAnimationFrame(refRafId.current);
    }

    let unsubReport: (() => void) | undefined;

    switch (state.kind) {
      case 'inspect-off':
        startFadeOut();
        return;

      case 'inspecting':
        drawHoverOverlay(state.hoveredDomElement, canvas, ctx, 'inspecting');
        break;

      case 'focused':
        if (!state.focusedDomElement) return;

        if (refLastHoveredElement.current !== state.focusedDomElement) {
          refLastHoveredElement.current = state.focusedDomElement;
        }

        signalWidgetViews.value = {
          view: 'inspector',
        };

        drawHoverOverlay(state.focusedDomElement, canvas, ctx, 'locked');

        unsubReport = Store.lastReportTime.subscribe(() => {
          if (refRafId.current && refCurrentRect.current) {
            const { parentCompositeFiber } = getCompositeComponentFromElement(
              state.focusedDomElement,
            );
            if (parentCompositeFiber) {
              drawHoverOverlay(state.focusedDomElement, canvas, ctx, 'locked');
            }
          }
        });

        if (unsubReport) {
          refCleanupMap.current.set(state.kind, unsubReport);
        }
        break;
    }
  };

  const updateCanvasSize = (
    canvas: HTMLCanvasElement,
    ctx: CanvasRenderingContext2D,
  ) => {
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * OVERLAY_DPR;
    canvas.height = rect.height * OVERLAY_DPR;
    ctx.scale(OVERLAY_DPR, OVERLAY_DPR);
    ctx.save();
  };

  const handleResizeOrScroll = () => {
    const state = Store.inspectState.peek();
    const canvas = refCanvas.current;
    if (!canvas) return;
    const ctx = canvas?.getContext('2d');
    if (!ctx) return;

    cancelAnimationFrame(refRafId.current);
    clearTimeout(refTimeout.current);

    updateCanvasSize(canvas, ctx);
    refCurrentRect.current = null;

    if (state.kind === 'focused' && state.focusedDomElement) {
      drawHoverOverlay(state.focusedDomElement, canvas, ctx, 'locked');
    } else if (state.kind === 'inspecting' && state.hoveredDomElement) {
      drawHoverOverlay(state.hoveredDomElement, canvas, ctx, 'inspecting');
    }
  };

  const handlePointerDown = (e: PointerEvent) => {
    const state = Store.inspectState.peek();
    const canvas = refCanvas.current;
    if (!canvas) return;

    if (
      state.kind === 'inspecting' ||
      isClickInLockIcon(e as unknown as MouseEvent, canvas)
    ) {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  };

  // biome-ignore lint/correctness/useExhaustiveDependencies: no deps
  useEffect(() => {
    const canvas = refCanvas.current;
    if (!canvas) return;
    const ctx = canvas?.getContext('2d');
    if (!ctx) return;

    updateCanvasSize(canvas, ctx);

    const unSubState = Store.inspectState.subscribe((state) => {
      handleStateChange(state, canvas, ctx);
    });

    window.addEventListener('scroll', handleResizeOrScroll, { passive: true });
    window.addEventListener('resize', handleResizeOrScroll, { passive: true });
    document.addEventListener('pointermove', handlePointerMove, {
      passive: true,
      capture: true,
    });
    document.addEventListener('pointerdown', handlePointerDown, {
      capture: true,
    });
    document.addEventListener('click', handleClick, { capture: true });
    document.addEventListener('keydown', handleKeyDown, { capture: true });

    return () => {
      unsubscribeAll();
      unSubState();
      window.removeEventListener('scroll', handleResizeOrScroll);
      window.removeEventListener('resize', handleResizeOrScroll);
      document.removeEventListener('pointermove', handlePointerMove, {
        capture: true,
      });
      document.removeEventListener('click', handleClick, { capture: true });
      document.removeEventListener('pointerdown', handlePointerDown, {
        capture: true,
      });
      document.removeEventListener('keydown', handleKeyDown, { capture: true });

      if (refRafId.current) {
        cancelAnimationFrame(refRafId.current);
      }
      clearTimeout(refTimeout.current);
    };
  }, []);

  return (
    <>
      <div
        ref={refEventCatcher}
        className={cn('fixed inset-0 w-screen h-screen', 'z-[214748365]')}
        // DO NOT DO NOT DO NOT REMOVE THE STYLE IT WILL CAUSE MASSIVE PERFORMANCE ISSUES https://x.com/RobKnight__/status/1897524145157439558
        style={{
          pointerEvents: 'none',
        }}
      />
      <canvas
        ref={refCanvas}
        dir="ltr"
        className={cn(
          'react-scan-inspector-overlay',
          'fixed inset-0 w-screen h-screen',
          'pointer-events-none',
          'z-[214748367]',
        )}
      />
    </>
  );
};
</file>

<file path="src/web/views/inspector/timeline/index.tsx">
import { isInstrumentationActive } from 'bippy';
import { memo } from 'preact/compat';
import { useCallback, useEffect, useMemo, useRef } from 'preact/hooks';
import { Icon } from '~web/components/icon';
import { Slider } from '~web/components/slider';
import type { useMergedRefs } from '~web/hooks/use-merged-refs';
import { timelineActions, timelineState } from '../states';
import { calculateSliderValues } from '../utils';

interface TimelineProps {
  refSticky?:
    | ReturnType<typeof useMergedRefs<HTMLElement>>
    | ((node: HTMLElement | null) => void);
}

export const Timeline = /* @__PURE__ */ memo(({ refSticky }: TimelineProps) => {
  const refPlayInterval = useRef<number | null>(null);

  const { currentIndex, isVisible, totalUpdates, updates } =
    timelineState.value;

  const sliderValues = useMemo(() => {
    return calculateSliderValues(totalUpdates, currentIndex);
  }, [totalUpdates, currentIndex]);

  const handleSliderChange = async (e: Event) => {
    const target = e.target as HTMLInputElement;
    const value = Number.parseInt(target.value, 10);

    const newIndex = Math.min(updates.length - 1, Math.max(0, value));

    let isViewingHistory = false;
    if (newIndex > 0 && newIndex < updates.length - 1) {
      isViewingHistory = true;
    }
    timelineActions.updateFrame(newIndex, isViewingHistory);
  };

  useEffect(() => {
    return () => {
      if (refPlayInterval.current) {
        clearInterval(refPlayInterval.current);
      }
    };
  }, []);

  const handleShowTimeline = useCallback(() => {
    if (!isVisible) {
      timelineActions.showTimeline();
    }
  }, [isVisible]);

  const handleHideTimeline = useCallback((e: Event) => {
    e.preventDefault();
    e.stopPropagation();
    if (refPlayInterval.current) {
      clearInterval(refPlayInterval.current);
      refPlayInterval.current = null;
    }
    timelineActions.hideTimeline();
  }, []);

  if (!isInstrumentationActive()) {
    return null;
  }

  if (totalUpdates <= 1) {
    return null;
  }

  return (
    <button
      ref={refSticky}
      type="button"
      onClick={handleShowTimeline}
      className="react-section-header"
      data-disable-scroll="true"
    >
      <button
        type="button"
        onClick={isVisible ? handleHideTimeline : undefined}
        title={
          isVisible ? 'Hide Re-renders History' : 'View Re-renders History'
        }
        className="w-4 h-4 flex items-center justify-center"
      >
        <Icon name="icon-gallery-horizontal-end" size={12} />
      </button>
      {isVisible ? (
        <>
          <div className="text-xs text-gray-500">{sliderValues.leftValue}</div>
          <Slider
            min={sliderValues.min}
            max={sliderValues.max}
            value={sliderValues.value}
            onChange={handleSliderChange}
            className="flex-1"
            totalUpdates={sliderValues.rightValue + 1}
          />
          <div className="text-xs text-gray-500">{sliderValues.rightValue}</div>
        </>
      ) : (
        'View Re-renders History'
      )}
    </button>
  );
});
</file>

<file path="src/web/views/inspector/timeline/utils.ts">
import {
  ClassComponentTag,
  type ContextDependency,
  type Fiber,
  ForwardRefTag,
  FunctionComponentTag,
  MemoComponentTag,
  type MemoizedState,
  SimpleMemoComponentTag,
} from 'bippy';
import { isEqual } from '~core/utils';
import { getChangedPropsDetailed, isPromise } from '../utils';

interface ChangeTrackingInfo {
  count: number;
  currentValue: unknown;
  previousValue: unknown;
  lastUpdated: number;
}

type ChangeKey = string | number;

const propsTracker = new Map<string, ChangeTrackingInfo>();
const stateTracker = new Map<ChangeKey, ChangeTrackingInfo>();
const contextTracker = new Map<string, ChangeTrackingInfo>();
let lastComponentType: unknown = null;

const STATE_NAME_REGEX = /\[(?<name>\w+),\s*set\w+\]/g;
const PROPS_ORDER_REGEX = /\(\s*{\s*(?<props>[^}]+)\s*}\s*\)/;

export const getStateNames = (fiber: Fiber): Array<string> => {
  const componentSource = fiber.type?.toString?.() || '';
  return componentSource
    ? Array.from(
        componentSource.matchAll(STATE_NAME_REGEX),
        (m: RegExpMatchArray) => m.groups?.name ?? '',
      )
    : [];
};

export const resetTracking = () => {
  propsTracker.clear();
  stateTracker.clear();
  contextTracker.clear();
  lastComponentType = null;
};

export const isInitialComponentUpdate = (fiber: Fiber): boolean => {
  const isNewComponent = fiber.type !== lastComponentType;
  lastComponentType = fiber.type;
  return isNewComponent;
};

export const trackChange = (
  tracker: Map<ChangeKey, ChangeTrackingInfo>,
  key: ChangeKey,
  currentValue: unknown,
  previousValue: unknown,
): { hasChanged: boolean; count: number } => {
  const existing = tracker.get(key);
  const isInitialValue = tracker === propsTracker || tracker === contextTracker;
  const hasChanged = !isEqual(currentValue, previousValue);

  if (!existing) {
    // For props and context, start with count 1 if there's a change
    tracker.set(key, {
      count: hasChanged && isInitialValue ? 1 : 0,
      currentValue,
      previousValue,
      lastUpdated: Date.now(),
    });

    return {
      hasChanged,
      count: hasChanged && isInitialValue ? 1 : isInitialValue ? 0 : 1,
    };
  }

  if (!isEqual(existing.currentValue, currentValue)) {
    const newCount = existing.count + 1;
    tracker.set(key, {
      count: newCount,
      currentValue,
      previousValue: existing.currentValue,
      lastUpdated: Date.now(),
    });
    return { hasChanged: true, count: newCount };
  }

  return { hasChanged: false, count: existing.count };
};

export { propsTracker, stateTracker, contextTracker };

export interface SectionData {
  current: Array<{ name: string | number; value: unknown }>;
  changes: Set<string | number>;
  changesCounts: Map<string | number, number>;
}

export interface InspectorData {
  fiberProps: SectionData;
  fiberState: SectionData;
  fiberContext: SectionData;
}

export const getStateFromFiber = (
  fiber: Fiber,
): Record<string | number, unknown> => {
  if (!fiber) return {};

  if (
    fiber.tag === FunctionComponentTag ||
    fiber.tag === ForwardRefTag ||
    fiber.tag === SimpleMemoComponentTag ||
    fiber.tag === MemoComponentTag
  ) {
    let memoizedState: MemoizedState | null = fiber.memoizedState;
    const state: Record<number, unknown> = {};
    let index = 0;

    while (memoizedState) {
      if (memoizedState.queue && memoizedState.memoizedState !== undefined) {
        state[index] = memoizedState.memoizedState;
      }
      memoizedState = memoizedState.next;
      index++;
    }

    return state;
  }

  if (fiber.tag === ClassComponentTag) {
    return fiber.memoizedState || {};
  }

  return {};
};

/**
 * Used to preserve the order of the fiber's props as represented in source code
 */
export const getPropsOrder = (fiber: Fiber): Array<string> => {
  const componentSource = fiber.type?.toString?.() || '';
  const match = componentSource.match(PROPS_ORDER_REGEX);
  if (!match?.groups?.props) return [];

  return match.groups.props
    .split(',')
    .map((prop: string) => prop.trim().split(':')[0].split('=')[0].trim())
    .filter(Boolean);
};

export interface InspectorDataResult {
  data: InspectorData;
  shouldUpdate: boolean;
}

interface BaseChange {
  name: string | number;
  value: unknown;
  prevValue: unknown;
}

interface PropChange extends BaseChange {
  name: string;
}

interface StateChange extends BaseChange {
  name: string | number;
}

interface ContextChange extends BaseChange {
  name: string;
  contextType: unknown;
}

interface CollectorResult<T extends BaseChange = BaseChange> {
  current: Record<string | number, unknown>;
  prev: Record<string | number, unknown>;
  changes: Array<T>;
}

export const collectPropsChanges = (
  fiber: Fiber,
): CollectorResult<PropChange> => {
  const currentProps = fiber.memoizedProps || {};
  const prevProps = fiber.alternate?.memoizedProps || {};

  const current: Record<string, unknown> = {};
  const prev: Record<string, unknown> = {};

  const allProps = Object.keys(currentProps);
  for (const key of allProps) {
    if (key in currentProps) {
      current[key] = currentProps[key];
      prev[key] = prevProps[key];
    }
  }

  const changes = getChangedPropsDetailed(fiber).map((change) => ({
    name: change.name,
    value: change.value,
    prevValue: change.prevValue,
  }));

  return { current, prev, changes };
};

export const collectStateChanges = (
  fiber: Fiber,
): CollectorResult<StateChange> => {
  const current = getStateFromFiber(fiber);
  const prev = fiber.alternate ? getStateFromFiber(fiber.alternate) : {};
  const changes: Array<StateChange> = [];

  for (const [index, value] of Object.entries(current)) {
    const stateKey = fiber.tag === ClassComponentTag ? index : Number(index);
    if (fiber.alternate && !isEqual(prev[index], value)) {
      changes.push({
        name: stateKey,
        value,
        prevValue: prev[index],
      });
    }
  }

  return { current, prev, changes };
};

export const collectContextChanges = (
  fiber: Fiber,
): CollectorResult<ContextChange> => {
  const currentContexts = getAllFiberContexts(fiber);
  const prevContexts = fiber.alternate
    ? getAllFiberContexts(fiber.alternate)
    : new Map();

  const current: Record<string, unknown> = {};
  const prev: Record<string, unknown> = {};
  const changes: Array<ContextChange> = [];

  const seenContexts = new Set<unknown>();
  for (const [contextType, ctx] of currentContexts) {
    const name = ctx.displayName;
    const contextKey = contextType;

    if (seenContexts.has(contextKey)) continue;
    seenContexts.add(contextKey);

    current[name] = ctx.value;

    const prevCtx = prevContexts.get(contextType);
    if (prevCtx) {
      prev[name] = prevCtx.value;
      if (!isEqual(prevCtx.value, ctx.value)) {
        changes.push({
          name,
          value: ctx.value,
          prevValue: prevCtx.value,
          contextType,
        });
      }
    }
  }

  return { current, prev, changes };
};

export const collectInspectorData = (fiber: Fiber): InspectorDataResult => {
  const emptySection = (): SectionData => ({
    current: [],
    changes: new Set<string | number>(),
    changesCounts: new Map<string | number, number>(),
  });

  if (!fiber) {
    return {
      data: {
        fiberProps: emptySection(),
        fiberState: emptySection(),
        fiberContext: emptySection(),
      },
      shouldUpdate: false,
    };
  }

  let hasNewChanges = false;
  const isInitialUpdate = isInitialComponentUpdate(fiber);

  const propsData = emptySection();
  if (fiber.memoizedProps) {
    const { current, changes } = collectPropsChanges(fiber);

    for (const [key, value] of Object.entries(current)) {
      propsData.current.push({
        name: key,
        value: isPromise(value)
          ? { type: 'promise', displayValue: 'Promise' }
          : value,
      });
    }

    for (const change of changes) {
      const { hasChanged, count } = trackChange(
        propsTracker,
        change.name,
        change.value,
        change.prevValue,
      );

      if (hasChanged) {
        hasNewChanges = true;
        propsData.changes.add(change.name);
        propsData.changesCounts.set(change.name, count);
      }
    }
  }

  const stateData = emptySection();
  const { current: stateCurrent, changes: stateChanges } =
    collectStateChanges(fiber);

  for (const [index, value] of Object.entries(stateCurrent)) {
    const stateKey = fiber.tag === ClassComponentTag ? index : Number(index);
    stateData.current.push({ name: stateKey, value });
  }

  for (const change of stateChanges) {
    const { hasChanged, count } = trackChange(
      stateTracker,
      change.name,
      change.value,
      change.prevValue,
    );

    if (hasChanged) {
      hasNewChanges = true;
      stateData.changes.add(change.name);
      stateData.changesCounts.set(change.name, count);
    }
  }

  const contextData = emptySection();
  const { current: contextCurrent, changes: contextChanges } =
    collectContextChanges(fiber);

  for (const [name, value] of Object.entries(contextCurrent)) {
    contextData.current.push({ name, value });
  }

  if (!isInitialUpdate) {
    for (const change of contextChanges) {
      const { hasChanged, count } = trackChange(
        contextTracker,
        change.name,
        change.value,
        change.prevValue,
      );

      if (hasChanged) {
        hasNewChanges = true;
        contextData.changes.add(change.name);
        contextData.changesCounts.set(change.name, count);
      }
    }
  }

  if (!hasNewChanges && !isInitialUpdate) {
    propsData.changes.clear();
    stateData.changes.clear();
    contextData.changes.clear();
  }

  return {
    data: {
      fiberProps: propsData,
      fiberState: stateData,
      fiberContext: contextData,
    },
    shouldUpdate: hasNewChanges || isInitialUpdate,
  };
};

interface ContextInfo {
  value: unknown;
  displayName: string;
  contextType: unknown;
}
// hm we potentially want to revalidate this if a fiber has new context's, i'm not sure how we can do that reactively
// i suppose we can do one traversal on render (or during the existing traversal) that checks if any new context providers were mounted
// and when that happens we revalidate this cache

// i suppose a case this breaks is if a fiber changes ancestors through a key but doesn't remount
// then it would have new parents... and that new parent may have new context
// may be a fine trade off
// the motivation is this fiber traversal on every rendering fiber is extremely expensive
const fiberContextsCache = new WeakMap<Fiber, Map<unknown, ContextInfo>>();

export const getAllFiberContexts = (
  fiber: Fiber,
): Map<unknown, ContextInfo> => {
  if (!fiber) {
    return new Map<unknown, ContextInfo>();
  }

  // todo validate this works

  const cachedContexts = fiberContextsCache.get(fiber);
  if (cachedContexts) {
    return cachedContexts;
  }

  const contexts = new Map<unknown, ContextInfo>();
  let currentFiber: Fiber | null = fiber;

  while (currentFiber) {
    const dependencies = currentFiber.dependencies;

    if (dependencies?.firstContext) {
      let contextItem: ContextDependency<unknown> | null =
        dependencies.firstContext;

      while (contextItem) {
        const memoizedValue = contextItem.memoizedValue;
        const displayName = contextItem.context?.displayName;

        if (!contexts.has(memoizedValue)) {
          contexts.set(contextItem.context, {
            value: memoizedValue,
            displayName: displayName ?? 'UnnamedContext',
            contextType: null,
          });
        }

        if (contextItem === contextItem.next) {
          break;
        }

        contextItem = contextItem.next;
      }
    }

    currentFiber = currentFiber.return;
  }

  // Cache the result for this fiber
  fiberContextsCache.set(fiber, contexts);

  return contexts;
};

export const collectInspectorDataWithoutCounts = (fiber: Fiber) => {
  const emptySection = (): SectionData => ({
    current: [],
    changes: new Set<string | number>(),
    changesCounts: new Map<string | number, number>(),
  });

  if (!fiber) {
    return {
      fiberProps: emptySection(),
      fiberState: emptySection(),
      fiberContext: emptySection(),
    };
  }

  // let hasNewChanges = false;

  const propsData = emptySection();
  if (fiber.memoizedProps) {
    const { current, changes } = collectPropsChanges(fiber);

    for (const [key, value] of Object.entries(current)) {
      propsData.current.push({
        name: key,
        value: isPromise(value)
          ? { type: 'promise', displayValue: 'Promise' }
          : value,
      });
    }

    for (const change of changes) {
      // hasNewChanges = true;
      propsData.changes.add(change.name);
      propsData.changesCounts.set(change.name, 1);
    }
  }

  const stateData = emptySection();
  if (fiber.memoizedState) {
    const { current, changes } = collectStateChanges(fiber);

    for (const [key, value] of Object.entries(current)) {
      stateData.current.push({
        name: key,
        value: isPromise(value)
          ? { type: 'promise', displayValue: 'Promise' }
          : value,
      });
    }

    for (const change of changes) {
      // hasNewChanges = true;
      stateData.changes.add(change.name);
      stateData.changesCounts.set(change.name, 1);
    }
  }

  const contextData = emptySection();
  const { current, changes } = collectContextChanges(fiber);

  for (const [key, value] of Object.entries(current)) {
    contextData.current.push({
      name: key,
      value: isPromise(value)
        ? { type: 'promise', displayValue: 'Promise' }
        : value,
    });
  }

  for (const change of changes) {
    // hasNewChanges = true;
    contextData.changes.add(change.name);
    contextData.changesCounts.set(change.name, 1);
  }
  // todo: is isInitialUpdate correct? Is this necessary:
  // if (!hasNewChanges && !isInitialUpdate) {
  //   propsData.changes.clear();
  //   stateData.changes.clear();
  //   contextData.changes.clear();
  // }

  return {
    // data: {
    fiberProps: propsData,
    fiberState: stateData,
    fiberContext: contextData,
    // },
  };
};
</file>

<file path="src/web/views/inspector/whats-changed/use-change-store.ts">
import { useEffect, useRef, useState } from 'preact/hooks';
import {
  ChangesListener,
  ChangesPayload,
  ContextChange,
  Store,
} from '~core/index';
import { Fiber, getFiberId } from 'bippy';
import { isEqual } from '~core/utils';
import { signal } from '@preact/signals';

const CHANGES_QUEUE_INTERVAL = 50;

interface SectionData {
  current: Array<{ name: string; value: unknown }>;
  changes: Set<string>;
}

export interface InspectorData {
  fiberProps: SectionData;
  fiberState: SectionData;
  fiberContext: SectionData;
}
interface InspectorState extends InspectorData {
  fiber: Fiber | null;
}

export const inspectorState = signal<InspectorState>({
  fiber: null,
  fiberProps: { current: [], changes: new Set() },
  fiberState: { current: [], changes: new Set() },
  fiberContext: { current: [], changes: new Set() },
});

export type AggregatedChanges = {
  count: number;
  currentValue: unknown;
  previousValue: unknown;
  name: string;
  lastUpdated: number;
  id: string;
};

export type AllAggregatedChanges = {
  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
  propsChanges: Map<any, AggregatedChanges>;
  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
  stateChanges: Map<any, AggregatedChanges>;
  contextChanges: Map<
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    any,
    | { changes: AggregatedChanges; kind: 'initialized' }
    | {
        // this looks weird, because it is
        // its a work around to allow context changes to be sent impotently
        // (react-scan internals do not yet handle sending context changes the render they change)
        kind: 'partially-initialized';
        value: unknown;
        name: string;
        lastUpdated: number;
        id: string;
      }
  >;
};

const getContextChangesValue = (
  discriminated:
    | { kind: 'partially-initialized'; value: unknown }
    | { kind: 'initialized'; changes: AggregatedChanges },
) => {
  switch (discriminated.kind) {
    case 'initialized': {
      return discriminated.changes.currentValue;
    }
    case 'partially-initialized': {
      return discriminated.value;
    }
  }
};
const processChanges = (
  changes: Array<{ name: string; value: unknown; prevValue?: unknown }>,
  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
  targetMap: Map<any, AggregatedChanges>,
) => {
  for (const change of changes) {
    const existing = targetMap.get(change.name);

    if (existing) {
      targetMap.set(existing.name, {
        count: existing.count + 1,
        currentValue: change.value,
        id: existing.name,
        lastUpdated: Date.now(),
        name: existing.name,
        previousValue: change.prevValue,
      });
      continue;
    }

    targetMap.set(change.name, {
      count: 1,
      currentValue: change.value,
      id: change.name,
      lastUpdated: Date.now(),
      name: change.name,
      previousValue: change.prevValue,
    });
  }
};

const processContextChanges = (
  contextChanges: Array<ContextChange>,
  aggregatedChanges: AllAggregatedChanges,
) => {
  for (const change of contextChanges) {
    const existing = aggregatedChanges.contextChanges.get(change.contextType);

    if (existing) {
      if (isEqual(getContextChangesValue(existing), change.value)) {
        continue;
      }
      if (existing.kind === 'partially-initialized') {
        aggregatedChanges.contextChanges.set(change.contextType, {
          kind: 'initialized',
          changes: {
            count: 1,
            currentValue: change.value,
            id: change.contextType.toString(), // come back to this why was this ever expected to be a number?
            lastUpdated: Date.now(),
            name: change.name,
            previousValue: existing.value,
          },
        });
        continue;
      }

      aggregatedChanges.contextChanges.set(change.contextType, {
        kind: 'initialized',
        changes: {
          count: existing.changes.count + 1,
          currentValue: change.value,
          id: change.contextType.toString(),
          lastUpdated: Date.now(),
          name: change.name,
          previousValue: existing.changes.currentValue,
        },
      });

      continue;
    }

    aggregatedChanges.contextChanges.set(change.contextType, {
      kind: 'partially-initialized',
      id: change.contextType.toString(),
      lastUpdated: Date.now(),
      name: change.name,
      value: change.value,
    });
  }
};

const collapseQueue = (queue: Array<ChangesPayload>) => {
  const localAggregatedChanges: AllAggregatedChanges = {
    contextChanges: new Map(),
    propsChanges: new Map(),
    stateChanges: new Map(),
  };

  queue.forEach((changes) => {
    // context is a special case since we don't send precise diffs and need to be idempotent
    processContextChanges(changes.contextChanges, localAggregatedChanges);

    processChanges(changes.stateChanges, localAggregatedChanges.stateChanges);

    processChanges(changes.propsChanges, localAggregatedChanges.propsChanges);
  });

  return localAggregatedChanges;
};
const mergeSimpleChanges = <
  T extends
    | AllAggregatedChanges['propsChanges']
    | AllAggregatedChanges['stateChanges'],
>(
  existingChanges: T,
  incomingChanges: T,
): T => {
  const mergedChanges = new Map();

  existingChanges.forEach((value, key) => {
    mergedChanges.set(key, value);
  });

  incomingChanges.forEach((incomingChange, key) => {
    const existing = mergedChanges.get(key);

    if (!existing) {
      mergedChanges.set(key, incomingChange);
      return;
    }

    mergedChanges.set(key, {
      count: existing.count + incomingChange.count,
      currentValue: incomingChange.currentValue,
      id: incomingChange.id,
      lastUpdated: incomingChange.lastUpdated,
      name: incomingChange.name,
      previousValue: incomingChange.previousValue,
    });
  });

  return mergedChanges as T;
};

const mergeContextChanges = (
  existing: AllAggregatedChanges,
  incoming: AllAggregatedChanges,
) => {
  const contextChanges: AllAggregatedChanges['contextChanges'] = new Map();

  existing.contextChanges.forEach((value, key) => {
    contextChanges.set(key, value);
  });

  incoming.contextChanges.forEach((incomingChange, key) => {
    const existingChange = contextChanges.get(key);

    if (!existingChange) {
      contextChanges.set(key, incomingChange);
      return;
    }
    if (
      getContextChangesValue(incomingChange) ===
      getContextChangesValue(existingChange)
    ) {
      // we do this for a second time just in context merge to handle the partial initialization case (the collapsed queue will not have the information to remove the partially initialized set of changes)
      return;
    }

    switch (existingChange.kind) {
      case 'initialized': {
        switch (incomingChange.kind) {
          case 'initialized': {
            const preInitEntryOffset = 1;
            contextChanges.set(key, {
              kind: 'initialized',
              changes: {
                ...incomingChange.changes,
                // if existing was initialized, the pre-initialization done by the collapsed queue was not necessary, so we need to increment count to account for the preInit entry
                count:
                  incomingChange.changes.count +
                  existingChange.changes.count +
                  preInitEntryOffset,
                currentValue: incomingChange.changes.currentValue,

                previousValue: incomingChange.changes.previousValue, // we always want to show this value, since this will be the true state transition (if you make the previousValue the last seen currentValue, u will have weird behavior with primitive state updates)
              },
            });
            return;
          }
          case 'partially-initialized': {
            contextChanges.set(key, {
              kind: 'initialized',
              changes: {
                count: existingChange.changes.count + 1,
                currentValue: incomingChange.value,
                id: incomingChange.id,
                lastUpdated: incomingChange.lastUpdated,
                name: incomingChange.name,
                previousValue: existingChange.changes.currentValue,
              },
            });
            return;
          }
        }
      }
      case 'partially-initialized': {
        switch (incomingChange.kind) {
          case 'initialized': {
            contextChanges.set(key, {
              kind: 'initialized',
              changes: {
                count: incomingChange.changes.count + 1,
                currentValue: incomingChange.changes.currentValue,
                id: incomingChange.changes.id,
                lastUpdated: incomingChange.changes.lastUpdated,
                name: incomingChange.changes.name,
                previousValue: existingChange.value,
              },
            });
            return;
          }
          case 'partially-initialized': {
            contextChanges.set(key, {
              kind: 'initialized',
              changes: {
                count: 1,
                currentValue: incomingChange.value,
                id: incomingChange.id,
                lastUpdated: incomingChange.lastUpdated,
                name: incomingChange.name,
                previousValue: existingChange.value,
              },
            });
            return;
          }
        }
      }
    }
  });

  return contextChanges;
};

const mergeChanges = (
  existing: AllAggregatedChanges,
  incoming: AllAggregatedChanges,
): AllAggregatedChanges => {
  const contextChanges = mergeContextChanges(existing, incoming);

  const propChanges = mergeSimpleChanges(
    existing.propsChanges,
    incoming.propsChanges,
  );
  const stateChanges = mergeSimpleChanges(
    existing.stateChanges,
    incoming.stateChanges,
  );

  return {
    contextChanges,
    propsChanges: propChanges,
    stateChanges,
  };
};

/**
 * Calculate total count of changes across props, state and context
 */
export const calculateTotalChanges = (changes: AllAggregatedChanges) => {
  return (
    Array.from(changes.propsChanges.values()).reduce(
      (acc, change) => acc + change.count,
      0,
    ) +
    Array.from(changes.stateChanges.values()).reduce(
      (acc, change) => acc + change.count,
      0,
    ) +
    Array.from(changes.contextChanges.values())
      .filter(
        (change): change is Extract<typeof change, { kind: 'initialized' }> =>
          change.kind === 'initialized',
      )
      .reduce((acc, change) => acc + change.changes.count, 0)
  );
};

export const useInspectedFiberChangeStore = (opts?: {
  onChangeUpdate?: (countUpdated: number) => void;
}) => {
  const pendingChanges = useRef<{ queue: ChangesPayload[] }>({ queue: [] });
  // flushed state read from queue stream
  const [aggregatedChanges, setAggregatedChanges] =
    useState<AllAggregatedChanges>({
      propsChanges: new Map(),
      stateChanges: new Map(),
      contextChanges: new Map(),
    });

  const fiber =
    Store.inspectState.value.kind === 'focused'
      ? Store.inspectState.value.fiber
      : null;
  const fiberId = fiber ? getFiberId(fiber) : null;

  // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>
  useEffect(() => {
    const interval = setInterval(() => {
      // optimization to avoid unconditional renders
      if (pendingChanges.current.queue.length === 0) return;

      setAggregatedChanges((prevAggregatedChanges) => {
        const queueChanges = collapseQueue(pendingChanges.current.queue);
        const merged = mergeChanges(prevAggregatedChanges, queueChanges);
        const prevTotal = calculateTotalChanges(prevAggregatedChanges);
        const newTotal = calculateTotalChanges(merged);
        const changeCount = newTotal - prevTotal;
        opts?.onChangeUpdate?.(changeCount);

        return merged;
      });

      pendingChanges.current.queue = [];
    }, CHANGES_QUEUE_INTERVAL);

    return () => {
      clearInterval(interval);
    };
  }, [fiber]);

  // un-throttled subscription
  useEffect(() => {
    if (!fiberId) {
      return;
    }
    const listener: ChangesListener = (change) => {
      pendingChanges.current?.queue.push(change);
    };

    let listeners = Store.changesListeners.get(fiberId);

    if (!listeners) {
      listeners = [];
      Store.changesListeners.set(fiberId, listeners);
    }

    listeners.push(listener);

    return () => {
      setAggregatedChanges({
        propsChanges: new Map(),
        stateChanges: new Map(),
        contextChanges: new Map(),
      });
      pendingChanges.current.queue = [];
      Store.changesListeners.set(
        fiberId,
        Store.changesListeners.get(fiberId)?.filter((l) => l !== listener) ??
          [],
      );
    };
  }, [fiberId]);

  // cleanup
  // biome-ignore lint/correctness/useExhaustiveDependencies: component should really remount when fiber changes, but instead we just re-run effects (should fix)
  useEffect(() => {
    return () => {
      setAggregatedChanges({
        propsChanges: new Map(),
        stateChanges: new Map(),
        contextChanges: new Map(),
      });
      pendingChanges.current.queue = [];
    };
  }, [fiberId]);

  return aggregatedChanges;
};
</file>

<file path="src/web/views/inspector/diff-value.tsx">
import { useState } from 'preact/hooks';
import { CopyToClipboard } from '~web/components/copy-to-clipboard';
import { Icon } from '~web/components/icon';
import { cn } from '~web/utils/helpers';
import { formatForClipboard, formatValuePreview, safeGetValue } from './utils';

const ArrayHeader = ({
  length,
  expanded,
  onToggle,
  isNegative,
}: {
  length: number;
  expanded: boolean;
  onToggle: () => void;
  isNegative: boolean;
}) => (
  <div className="flex items-center gap-1">
    <button
      type="button"
      onClick={onToggle}
      className="flex items-center p-0 opacity-50"
    >
      <Icon
        name="icon-chevron-right"
        size={12}
        className={cn(
          'transition-[color,transform]',
          isNegative ? 'text-[#f87171]' : 'text-[#4ade80]',
          expanded && 'rotate-90',
        )}
      />
    </button>
    <span>Array({length})</span>
  </div>
);

const TreeNode = ({
  value,
  path,
  isNegative,
}: {
  value: unknown;
  path: string;
  isNegative: boolean;
}) => {
  const [isExpanded, setIsExpanded] = useState(false);
  const canExpand = value !== null &&
    typeof value === 'object' &&
    !(value instanceof Date);

  if (!canExpand) {
    return (
      <div className="flex items-center gap-1">
        <span className="text-gray-500">{path}:</span>
        <span className="truncate">{formatValuePreview(value)}</span>
      </div>
    );
  }

  const entries = Object.entries(value as object);

  return (
    <div className="flex flex-col">
      <div className="flex items-center gap-1">
        <button
          type="button"
          onClick={() => setIsExpanded(!isExpanded)}
          className="flex items-center p-0 opacity-50"
        >
          <Icon
            name="icon-chevron-right"
            size={12}
            className={cn(
              'transition-[color,transform]',
              isNegative ? 'text-[#f87171]' : 'text-[#4ade80]',
              isExpanded && 'rotate-90',
            )}
          />
        </button>
        <span className="text-gray-500">{path}:</span>
        {!isExpanded && (
          <span className="truncate">
            {value instanceof Date ? formatValuePreview(value) : `{${Object.keys(value).join(', ')}}`}
          </span>
        )}
      </div>
      {isExpanded && (
        <div className="pl-5 border-l border-[#333] mt-0.5 ml-1 flex flex-col gap-0.5">
          {entries.map(([key, val]) => (
            <TreeNode
              key={key}
              value={val}
              path={key}
              isNegative={isNegative}
            />
          ))}
        </div>
      )}
    </div>
  );
};

export const DiffValueView = ({
  value,
  expanded,
  onToggle,
  isNegative,
}: {
  value: unknown;
  expanded: boolean;
  onToggle: () => void;
  isNegative: boolean;
}) => {
  const { value: safeValue, error } = safeGetValue(value);

  if (error) {
    return <span className="text-gray-500 font-italic">{error}</span>;
  }

  const isExpandable =
    safeValue !== null &&
    typeof safeValue === 'object' &&
    !(safeValue instanceof Promise);

  if (!isExpandable) {
    return <span>{formatValuePreview(safeValue)}</span>;
  }

  if (Array.isArray(safeValue)) {
    return (
      <div className="flex flex-col gap-1 relative">
        <ArrayHeader
          length={safeValue.length}
          expanded={expanded}
          onToggle={onToggle}
          isNegative={isNegative}
        />
        {expanded && (
          <div className="pl-2 border-l border-[#333] mt-0.5 ml-1 flex flex-col gap-0.5">
            {safeValue.map((item, index) => (
              <TreeNode
                key={index.toString()}
                value={item}
                path={index.toString()}
                isNegative={isNegative}
              />
            ))}
          </div>
        )}
        <CopyToClipboard
          text={formatForClipboard(safeValue)}
          className="absolute top-0.5 right-0.5 opacity-0 transition-opacity group-hover:opacity-100 self-end"
        >
          {({ ClipboardIcon }) => <>{ClipboardIcon}</>}
        </CopyToClipboard>
      </div>
    );
  }

  // Handle objects
  return (
    <div className="flex items-start gap-1 relative">
      <button
        type="button"
        onClick={onToggle}
        className={cn('flex items-center', 'p-0 mt-0.5 mr-1', 'opacity-50')}
      >
        <Icon
          name="icon-chevron-right"
          size={12}
          className={cn(
            'transition-[color,transform]',
            isNegative ? 'text-[#f87171]' : 'text-[#4ade80]',
            expanded && 'rotate-90',
          )}
        />
      </button>
      <div className="flex-1">
        {!expanded ? (
          <span>{formatValuePreview(safeValue)}</span>
        ) : (
            <div className="pl-2 border-l border-[#333] mt-0.5 ml-1 flex flex-col gap-0.5">
              {Object.entries(safeValue as object).map(([key, val]) => (
                <TreeNode
                  key={key}
                  value={val}
                  path={key}
                  isNegative={isNegative}
                />
              ))}
            </div>
        )}
      </div>
      <CopyToClipboard
        text={formatForClipboard(safeValue)}
        className="absolute top-0.5 right-0.5 opacity-0 transition-opacity group-hover:opacity-100 self-end"
      >
        {({ ClipboardIcon }) => <>{ClipboardIcon}</>}
      </CopyToClipboard>
    </div>
  );
};
</file>

<file path="src/web/views/inspector/flash-overlay.ts">
interface FlashEntry {
  element: HTMLElement;
  overlay: HTMLElement;
  scrollCleanup?: () => void;
}

const fadeOutTimers = new WeakMap<HTMLElement, ReturnType<typeof setTimeout>>();

const trackElementPosition = (
  element: Element,
  callback: (element: Element) => void,
): (() => void) => {
  const handleScroll = callback.bind(null, element);

  document.addEventListener('scroll', handleScroll, {
    passive: true,
    capture: true,
  });

  return () => {
    document.removeEventListener('scroll', handleScroll, { capture: true });
  };
};

export const flashManager = {
  activeFlashes: new Map<HTMLElement, FlashEntry>(),

  create(container: HTMLElement) {
    const existingOverlay = container.querySelector(
      '.react-scan-flash-overlay',
    );

    const overlay =
      existingOverlay instanceof HTMLElement
        ? existingOverlay
        : (() => {
            const newOverlay = document.createElement('div');
            newOverlay.className = 'react-scan-flash-overlay';
            container.appendChild(newOverlay);

            const scrollCleanup = trackElementPosition(container, () => {
              if (container.querySelector('.react-scan-flash-overlay')) {
                this.create(container);
              }
            });

            this.activeFlashes.set(container, {
              element: container,
              overlay: newOverlay,
              scrollCleanup,
            });

            return newOverlay;
          })();

    const existingTimer = fadeOutTimers.get(overlay);
    if (existingTimer) {
      clearTimeout(existingTimer);
      fadeOutTimers.delete(overlay);
    }

    requestAnimationFrame(() => {
      overlay.style.transition = 'none';
      overlay.style.opacity = '0.9';

      const timerId = setTimeout(() => {
        overlay.style.transition = 'opacity 150ms ease-out';
        overlay.style.opacity = '0';

        const cleanupTimer = setTimeout(() => {
          if (overlay.parentNode) {
            overlay.parentNode.removeChild(overlay);
          }
          const entry = this.activeFlashes.get(container);
          if (entry?.scrollCleanup) {
            entry.scrollCleanup();
          }
          this.activeFlashes.delete(container);
          fadeOutTimers.delete(overlay);
        }, 150);

        fadeOutTimers.set(overlay, cleanupTimer);
      }, 300);

      fadeOutTimers.set(overlay, timerId);
    });
  },

  cleanup(container: HTMLElement) {
    const entry = this.activeFlashes.get(container);
    if (entry) {
      const existingTimer = fadeOutTimers.get(entry.overlay);
      if (existingTimer) {
        clearTimeout(existingTimer);
        fadeOutTimers.delete(entry.overlay);
      }
      if (entry.overlay.parentNode) {
        entry.overlay.parentNode.removeChild(entry.overlay);
      }
      if (entry.scrollCleanup) {
        entry.scrollCleanup();
      }
      this.activeFlashes.delete(container);
    }
  },

  cleanupAll() {
    for (const [, entry] of this.activeFlashes) {
      this.cleanup(entry.element);
    }
  },
};
</file>

<file path="src/web/views/inspector/header.tsx">
import { computed, untracked, useSignalEffect } from '@preact/signals';
import type { Fiber } from 'bippy';
import { useMemo, useRef, useState } from 'preact/hooks';
import { Store } from '~core/index';
import { signalIsSettingsOpen } from '~web/state';
import { cn, getExtendedDisplayName } from '~web/utils/helpers';
import { timelineState } from './states';

const headerInspectClassName = computed(() =>
  cn(
    'absolute inset-0 flex items-center gap-x-2',
    'translate-y-0',
    'transition-transform duration-300',
    signalIsSettingsOpen.value && '-translate-y-[200%]',
  ),
);

export const HeaderInspect = () => {
  const refReRenders = useRef<HTMLSpanElement>(null);
  const refTiming = useRef<HTMLSpanElement>(null);
  const [currentFiber, setCurrentFiber] = useState<Fiber | null>(null);

  useSignalEffect(() => {
    const state = Store.inspectState.value;

    if (state.kind === 'focused') {
      setCurrentFiber(state.fiber);
    }
  });

  useSignalEffect(() => {
    const state = timelineState.value;
    untracked(() => {
      if (Store.inspectState.value.kind !== 'focused') return;
      if (!refReRenders.current || !refTiming.current) return;

      const { totalUpdates, currentIndex, updates, isVisible, windowOffset } =
        state;

      const reRenders = Math.max(0, totalUpdates - 1);
      const headerText = isVisible
        ? `#${windowOffset + currentIndex} Re-render`
        : reRenders > 0
          ? `${reRenders}`
          : '';

      let formattedTime: string | undefined;
      if (reRenders > 0 && currentIndex >= 0 && currentIndex < updates.length) {
        const time = updates[currentIndex]?.fiberInfo?.selfTime;
        formattedTime =
          time > 0
            ? time < 0.1 - Number.EPSILON
              ? '< 0.1ms'
              : `${Number(time.toFixed(1))}ms`
            : undefined;
      }

      // TODO(Alexis): can be computed signal
      refReRenders.current.dataset.text = headerText ? `  ${headerText}` : '';
      refTiming.current.dataset.text = formattedTime
        ? `  ${formattedTime}`
        : '';
    });
  });

  const componentName = useMemo(() => {
    if (!currentFiber) return null;
    const { name, wrappers, wrapperTypes } =
      getExtendedDisplayName(currentFiber);

    const title = wrappers.length
      ? `${wrappers.join('(')}(${name})${')'.repeat(wrappers.length)}`
      : (name ?? '');

    const firstWrapperType = wrapperTypes[0];
    return (
      <span title={title} className="flex items-center gap-x-1">
        {name ?? 'Unknown'}
        <span
          title={firstWrapperType?.title}
          className="flex items-center gap-x-1 text-[10px] text-purple-400"
        >
          {!!firstWrapperType && (
            <>
              <span
                key={firstWrapperType.type}
                className={cn(
                  'rounded py-[1px] px-1',
                  'truncate',
                  firstWrapperType.compiler && 'bg-purple-800 text-neutral-400',
                  !firstWrapperType.compiler &&
                    'bg-neutral-700 text-neutral-300',
                  firstWrapperType.type === 'memo' && 'bg-[#5f3f9a] text-white',
                )}
              >
                {firstWrapperType.type}
              </span>
              {firstWrapperType.compiler && (
                <span className="text-yellow-300"></span>
              )}
            </>
          )}
        </span>
        {wrapperTypes.length > 1 && (
          <span className="text-[10px] text-neutral-400">
            {wrapperTypes.length - 1}
          </span>
        )}
      </span>
    );
  }, [currentFiber]);

  return (
    <div className={headerInspectClassName}>
      {componentName}
      {/* useless info */}
      <div className="flex items-center gap-x-2 mr-auto text-xs text-[#888]">
        <span
          ref={refReRenders}
          className="with-data-text cursor-pointer !overflow-visible"
          title="Click to toggle between rerenders and total renders"
        />
        <span ref={refTiming} className="with-data-text !overflow-visible" />
      </div>
    </div>
  );
};
</file>

<file path="src/web/views/inspector/index.tsx">
import { computed, untracked, useSignalEffect } from '@preact/signals';
import type { Fiber } from 'bippy';
import { Component } from 'preact';
import { useEffect, useRef } from 'preact/hooks';
import { Store } from '~core/index';
import { Icon } from '~web/components/icon';
import { signalIsSettingsOpen, signalWidgetViews } from '~web/state';
import { cn } from '~web/utils/helpers';
import { constant } from '~web/utils/preact/constant';
import { ComponentsTree } from './components-tree';
import { flashManager } from './flash-overlay';
import {
  type TimelineUpdate,
  inspectorUpdateSignal,
  timelineActions,
} from './states';
import {
  collectInspectorData,
  getStateNames,
  resetTracking,
} from './timeline/utils';
import { extractMinimalFiberInfo, getCompositeFiberFromElement } from './utils';
import { WhatChanged } from './what-changed';

export const globalInspectorState = {
  lastRendered: new Map<string, unknown>(),
  expandedPaths: new Set<string>(),
  cleanup: () => {
    globalInspectorState.lastRendered.clear();
    globalInspectorState.expandedPaths.clear();
    flashManager.cleanupAll();
    resetTracking();
    timelineActions.reset();
  },
};

// todo: add reset button and error message
class InspectorErrorBoundary extends Component {
  state: { error: Error | null; hasError: boolean } = {
    hasError: false,
    error: null,
  };

  static getDerivedStateFromError(e: Error) {
    return { hasError: true, error: e };
  }

  handleReset = () => {
    this.setState({ hasError: false, error: null });
    globalInspectorState.cleanup();
  };

  render() {
    if (this.state.hasError) {
      return (
        <div className="p-4 bg-red-950/50 h-screen backdrop-blur-sm">
          <div className="flex items-center gap-2 mb-3 text-red-400 font-medium">
            <Icon name="icon-flame" className="text-red-500" size={16} />
            Something went wrong in the inspector
          </div>
          <div className="p-3 bg-black/40 rounded font-mono text-xs text-red-300 mb-4 break-words">
            {this.state.error?.message || JSON.stringify(this.state.error)}
          </div>
          <button
            type="button"
            onClick={this.handleReset}
            className="px-4 py-2 bg-red-500 hover:bg-red-600 text-white rounded-md text-sm font-medium transition-colors flex items-center justify-center gap-2"
          >
            Reset Inspector
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

const inspectorContainerClassName = computed(() =>
  cn(
    'react-scan-inspector',
    'flex-1',
    'opacity-0',
    'overflow-y-auto overflow-x-hidden',
    'transition-opacity delay-0',
    'pointer-events-none',
    !signalIsSettingsOpen.value && 'opacity-100 delay-300 pointer-events-auto',
  ),
);

const Inspector = /* @__PURE__ */ constant(() => {
  const refLastInspectedFiber = useRef<Fiber | null>(null);

  // NOTE(Alexis): no need for useCallback
  const processUpdate = (fiber: Fiber) => {
    if (!fiber) return;

    refLastInspectedFiber.current = fiber;
    const { data: inspectorData, shouldUpdate } = collectInspectorData(fiber);

    if (shouldUpdate) {
      const update: TimelineUpdate = {
        timestamp: Date.now(),
        fiberInfo: extractMinimalFiberInfo(fiber),
        props: inspectorData.fiberProps,
        state: inspectorData.fiberState,
        context: inspectorData.fiberContext,
        stateNames: getStateNames(fiber),
      };

      timelineActions.addUpdate(update, fiber);
    }
  };

  useSignalEffect(() => {
    const state = Store.inspectState.value;
    untracked(() => {
      if (state.kind !== 'focused' || !state.focusedDomElement) {
        refLastInspectedFiber.current = null;
        globalInspectorState.cleanup();
        return;
      }

      if (state.kind === 'focused') {
        signalIsSettingsOpen.value = false;
      }

      const { parentCompositeFiber } = getCompositeFiberFromElement(
        state.focusedDomElement,
        state.fiber,
      );

      if (!parentCompositeFiber) {
        Store.inspectState.value = {
          kind: 'inspect-off',
        };
        signalWidgetViews.value = {
          view: 'none',
        };
        return;
      }

      const isNewComponent =
        refLastInspectedFiber.current?.type !== parentCompositeFiber.type;

      if (isNewComponent) {
        refLastInspectedFiber.current = parentCompositeFiber;
        globalInspectorState.cleanup();
        processUpdate(parentCompositeFiber);
      }
    });
  });

  useSignalEffect(() => {
    // NOTE(Alexis): just track
    inspectorUpdateSignal.value;
    untracked(() => {
      const inspectState = Store.inspectState.value;
      if (inspectState.kind !== 'focused' || !inspectState.focusedDomElement) {
        refLastInspectedFiber.current = null;
        globalInspectorState.cleanup();
        return;
      }

      const { parentCompositeFiber } = getCompositeFiberFromElement(
        inspectState.focusedDomElement,
        inspectState.fiber,
      );

      if (!parentCompositeFiber) {
        Store.inspectState.value = {
          kind: 'inspect-off',
        };
        signalWidgetViews.value = {
          view: 'none',
        };
        return;
      }

      processUpdate(parentCompositeFiber);

      if (!inspectState.focusedDomElement.isConnected) {
        refLastInspectedFiber.current = null;
        globalInspectorState.cleanup();
        Store.inspectState.value = {
          kind: 'inspecting',
          hoveredDomElement: null,
        };
      }
    });
  });

  useEffect(() => {
    return () => {
      globalInspectorState.cleanup();
    };
  }, []);

  return (
    <InspectorErrorBoundary>
      <div className={inspectorContainerClassName}>
        <div className="w-full h-full">
          <WhatChanged />
        </div>
      </div>
    </InspectorErrorBoundary>
  );
});

export const ViewInspector = /* @__PURE__ */ constant(() => {
  if (Store.inspectState.value.kind !== 'focused') return null;
  return (
    <InspectorErrorBoundary>
      <Inspector />
      <ComponentsTree />
    </InspectorErrorBoundary>
  );
});
</file>

<file path="src/web/views/inspector/logging.ts">
/**
 * Safely stringifies any value, handling circular references and special types
 */
export function safeStringify(value: unknown): string {
  const seen = new WeakSet();

  return JSON.stringify(
    value,
    (_key, value) => {
      if (typeof value === 'function') {
        return '[Function]';
      }
      if (value instanceof Error) {
        return `[Error: ${value.message}]`;
      }
      if (value instanceof RegExp) {
        return value.toString();
      }
      if (value instanceof Map) {
        return `Map(${value.size})`;
      }
      if (value instanceof Set) {
        return `Set(${value.size})`;
      }
      if (typeof value === 'object' && value !== null) {
        if (seen.has(value)) {
          return '[Circular]';
        }
        seen.add(value);
      }
      return value;
    },
    2,
  );
}
</file>

<file path="src/web/views/inspector/properties.tsx">
import { getDisplayName } from 'bippy';
import {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'preact/hooks';

import { isEqual } from '~core/utils';
import { CopyToClipboard } from '~web/components/copy-to-clipboard';
import { Icon } from '~web/components/icon';
import { useMergedRefs } from '~web/hooks/use-merged-refs';
import { cn, tryOrElse } from '~web/utils/helpers';
import { globalInspectorState } from '.';
import { flashManager } from './flash-overlay';
import { timelineState } from './states';
import {
  detectValueType,
  formatForClipboard,
  formatInitialValue,
  formatValue,
  getOverrideMethods,
  getPath,
  isEditableValue,
  isExpandable,
  isPromise,
  sanitizeString,
  updateNestedValue,
} from './utils';

interface ValueMetadata {
  type: string;
  displayValue: string;
  value?: unknown;
  size?: number;
  length?: number;
  byteLength?: number;
  entries?: Record<string, ValueMetadata>;
  items?: Array<ValueMetadata>;
}
interface PropertyElementProps {
  name: string;
  value: unknown | ValueMetadata;
  section: string;
  level: number;
  parentPath?: string;
  objectPathMap?: WeakMap<object, Set<string>>;
  changedKeys?: Set<string | number>;
  allowEditing?: boolean;
}

interface PropertySectionProps {
  refSticky?:
    | ReturnType<typeof useMergedRefs<HTMLElement>>
    | ((node: HTMLElement | null) => void);
  isSticky?: boolean;
  section: 'props' | 'state' | 'context';
}

interface EditableValueProps {
  value: unknown;
  onSave: (newValue: unknown) => void;
  onCancel: () => void;
}

export const EditableValue = ({
  value,
  onSave,
  onCancel,
}: EditableValueProps) => {
  const refInput = useRef<HTMLInputElement>(null);
  const [editValue, setEditValue] = useState('');

  useEffect(() => {
    let initialValue = '';
    try {
      if (value instanceof Date) {
        initialValue = value.toISOString().slice(0, 16);
      } else if (
        value instanceof Map ||
        value instanceof Set ||
        value instanceof RegExp ||
        value instanceof Error ||
        value instanceof ArrayBuffer ||
        ArrayBuffer.isView(value) ||
        (typeof value === 'object' && value !== null)
      ) {
        initialValue = formatValue(value);
      } else {
        initialValue = formatInitialValue(value);
      }
    } catch {
      initialValue = String(value);
    }
    const sanitizedValue = sanitizeString(initialValue);
    setEditValue(sanitizedValue);

    requestAnimationFrame(() => {
      if (!refInput.current) return;
      refInput.current.focus();
      if (typeof value === 'string') {
        refInput.current.setSelectionRange(1, sanitizedValue.length - 1);
      } else {
        refInput.current.select();
      }
    });
  }, [value]);

  const handleChange = useCallback((e: Event) => {
    const target = e.target as HTMLInputElement;
    if (target) {
      setEditValue(target.value);
    }
  }, []);

  const handleKeyDown = (e: KeyboardEvent) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      try {
        let newValue: unknown;
        if (value instanceof Date) {
          const date = new Date(editValue);
          if (Number.isNaN(date.getTime())) {
            throw new Error('Invalid date');
          }
          newValue = date;
        } else {
          const detected = detectValueType(editValue);
          newValue = detected.value;
        }
        onSave(newValue);
      } catch {
        onCancel();
      }
    } else if (e.key === 'Escape') {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      onCancel();
    }
  };

  return (
    <input
      ref={refInput}
      type={value instanceof Date ? 'datetime-local' : 'text'}
      className="react-scan-input flex-1"
      value={editValue}
      onChange={handleChange}
      onKeyDown={handleKeyDown}
      onBlur={onCancel}
      step={value instanceof Date ? 1 : undefined}
    />
  );
};

export const PropertyElement = ({
  name,
  value,
  section,
  level,
  parentPath,
  objectPathMap = new WeakMap(),
  changedKeys = new Set(),
  allowEditing = true,
}: PropertyElementProps) => {
  const { updates, currentIndex } = timelineState.value;
  const currentUpdate = updates[currentIndex];
  const fiberInfo = currentUpdate?.fiberInfo;
  const refElement = useRef<HTMLDivElement>(null);

  const currentPath = getPath(
    fiberInfo.displayName,
    section,
    parentPath ?? '',
    name,
  );
  const [isExpanded, setIsExpanded] = useState(
    globalInspectorState.expandedPaths.has(currentPath),
  );
  const [isEditing, setIsEditing] = useState(false);

  const prevValue = globalInspectorState.lastRendered.get(currentPath);
  const isChanged = !isEqual(prevValue, value);

  useEffect(() => {
    if (name === 'children') {
      return;
    }
    if (section === 'context') {
      // we avoid flashing context purple to avoid confusion to user that this causes a render
      // it may be the case context changes but a fiber does not a depend on it, and the fiber is memoized
      return;
    }

    const isFirstRender = !globalInspectorState.lastRendered.has(currentPath);
    const shouldFlash = isChanged && refElement.current && !isFirstRender;

    globalInspectorState.lastRendered.set(currentPath, value);

    if (shouldFlash && refElement.current && level === 0) {
      flashManager.create(refElement.current);
    }
  }, [value, isChanged, currentPath, level, name, section]);

  const handleToggleExpand = useCallback(() => {
    setIsExpanded((prevState: boolean) => {
      const newIsExpanded = !prevState;
      if (newIsExpanded) {
        globalInspectorState.expandedPaths.add(currentPath);
      } else {
        globalInspectorState.expandedPaths.delete(currentPath);
      }
      return newIsExpanded;
    });
  }, [currentPath]);

  const valuePreview = useMemo(() => {
    if (typeof value === 'object' && value !== null) {
      if ('displayValue' in value) {
        return String(value.displayValue);
      }
    }
    return formatValue(value);
  }, [value]);

  const clipboardText = useMemo(() => {
    if (typeof value === 'object' && value !== null) {
      if ('value' in value) {
        return String(formatForClipboard(value.value));
      }
      if ('displayValue' in value) {
        return String(value.displayValue);
      }
    }
    return String(formatForClipboard(value));
  }, [value]);

  const isExpandableValue = useMemo(() => {
    if (!value || typeof value !== 'object') return false;

    if ('type' in value) {
      const metadata = value as ValueMetadata;
      switch (metadata.type) {
        case 'array':
        case 'Map':
        case 'Set':
          return (metadata.size ?? metadata.length ?? 0) > 0;
        case 'object':
          return (metadata.size ?? 0) > 0;
        case 'ArrayBuffer':
        case 'DataView':
          return (metadata.byteLength ?? 0) > 0;
        case 'circular':
        case 'promise':
        case 'function':
        case 'error':
          return false;
        default:
          if ('entries' in metadata || 'items' in metadata) {
            return true;
          }
          return false;
      }
    }

    return isExpandable(value);
  }, [value]);

  const { overrideProps, overrideHookState } = getOverrideMethods();
  const canEdit = useMemo(() => {
    if (!allowEditing) return false;
    if (section === 'props') return !!overrideProps && name !== 'children';
    if (section === 'state') return !!overrideHookState;
    return false;
  }, [section, overrideProps, overrideHookState, allowEditing, name]);

  const handleEdit = useCallback(() => {
    if (canEdit) {
      setIsEditing(true);
    }
  }, [canEdit]);

  const handleSave = (section: string, name: string, value: unknown) => {
    const { updates, currentIndex, latestFiber } = timelineState.value;
    const currentUpdate = updates[currentIndex];
    if (!latestFiber) return;

    const { overrideProps, overrideHookState } = getOverrideMethods();
    if (!overrideProps || !overrideHookState) return;

    if (section === 'props') {
      tryOrElse(() => {
        const currentProps = latestFiber.memoizedProps || {};
        let currentValue: unknown;
        let path: string[];

        if (parentPath) {
          const parts = parentPath.split('.');
          path = parts.filter(
            (part) =>
              part !== 'props' && part !== getDisplayName(latestFiber.type),
          );
          path.push(name);
          currentValue = path.reduce(
            (obj: Record<string, unknown>, key) =>
              obj && typeof obj === 'object'
                ? (obj[key] as Record<string, unknown>)
                : {},
            currentProps as Record<string, unknown>,
          );
        } else {
          path = [name];
          currentValue = currentProps[name];
        }

        if (!isEqual(currentValue, value)) {
          overrideProps(latestFiber, path, value);

          // @pivanov: on first render, the alternate is null and we can't update it
          if (latestFiber.alternate) {
            overrideProps(latestFiber.alternate, path, value);
          }
        }
      }, null);
    } else if (section === 'state') {
      tryOrElse(() => {
        if (!parentPath) {
          const stateNames = currentUpdate.stateNames;
          const namedStateIndex = stateNames.indexOf(name);
          const hookId =
            namedStateIndex !== -1 ? namedStateIndex.toString() : name;
          overrideHookState(latestFiber, hookId, [], value);
        } else {
          const fullPathParts = parentPath.split('.');
          const stateIndex = fullPathParts.indexOf('state');
          if (stateIndex === -1) return;

          const statePath = fullPathParts.slice(stateIndex + 1);
          const baseStateKey = statePath[0];
          const stateNames = currentUpdate.stateNames;
          const namedStateIndex = stateNames.indexOf(baseStateKey);
          const hookId =
            namedStateIndex !== -1 ? namedStateIndex.toString() : '0';

          const currentState = currentUpdate.state.current;
          if (
            !currentState ||
            !currentState.find((item) => item.name === Number(baseStateKey))
          ) {
            return;
          }

          const updatedState = updateNestedValue(
            currentState.find((item) => item.name === Number(baseStateKey))
              ?.value,
            statePath.slice(1).concat(name),
            value,
          );
          overrideHookState(latestFiber, hookId, [], updatedState);
        }
      }, null);
    }

    setIsEditing(false);
  };

  const checkCircularInValue = useMemo((): boolean => {
    if (!value || typeof value !== 'object' || isPromise(value)) return false;

    return 'type' in value && value.type === 'circular';
  }, [value]);

  const renderNestedProperties = useCallback(
    (obj: unknown): preact.ComponentChildren => {
      if (!obj || typeof obj !== 'object') return null;

      if ('type' in obj) {
        const metadata = obj as ValueMetadata;
        if ('entries' in metadata && metadata.entries) {
          const entries = Object.entries(metadata.entries);
          if (entries.length === 0) return null;

          return (
            <div className="react-scan-nested">
              {entries.map(([key, val]) => (
                <PropertyElement
                  key={`${currentPath}-entry-${key}`}
                  name={key}
                  value={val}
                  section={section}
                  level={level + 1}
                  parentPath={currentPath}
                  objectPathMap={objectPathMap}
                  changedKeys={changedKeys}
                  allowEditing={allowEditing}
                />
              ))}
            </div>
          );
        }

        if ('items' in metadata && Array.isArray(metadata.items)) {
          if (metadata.items.length === 0) return null;
          return (
            <div className="react-scan-nested">
              {metadata.items.map((item, i) => {
                const itemKey = `${currentPath}-item-${item.type}-${i}`;
                return (
                  <PropertyElement
                    key={itemKey}
                    name={`${i}`}
                    value={item}
                    section={section}
                    level={level + 1}
                    parentPath={currentPath}
                    objectPathMap={objectPathMap}
                    changedKeys={changedKeys}
                    allowEditing={allowEditing}
                  />
                );
              })}
            </div>
          );
        }
        return null;
      }

      let entries: Array<[key: string | number, value: unknown]>;

      if (obj instanceof ArrayBuffer) {
        const view = new Uint8Array(obj);
        entries = Array.from(view).map((v, i) => [i, v]);
      } else if (obj instanceof DataView) {
        const view = new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength);
        entries = Array.from(view).map((v, i) => [i, v]);
      } else if (ArrayBuffer.isView(obj)) {
        if (obj instanceof BigInt64Array || obj instanceof BigUint64Array) {
          entries = Array.from({ length: obj.length }, (_, i) => [i, obj[i]]);
        } else {
          const typedArray = obj as unknown as ArrayLike<number>;
          entries = Array.from(typedArray).map((v, i) => [i, v]);
        }
      } else if (obj instanceof Map) {
        entries = Array.from(obj.entries()).map(([k, v]) => [String(k), v]);
      } else if (obj instanceof Set) {
        entries = Array.from(obj).map((v, i) => [i, v]);
      } else if (Array.isArray(obj)) {
        entries = obj.map((value, index) => [`${index}`, value]);
      } else {
        entries = Object.entries(obj);
      }

      if (entries.length === 0) return null;

      const canEditChildren = !(
        obj instanceof DataView ||
        obj instanceof ArrayBuffer ||
        ArrayBuffer.isView(obj)
      );

      return (
        <div className="react-scan-nested">
          {entries.map(([key, val]) => {
            const itemKey = `${currentPath}-${typeof key === 'number' ? `item-${key}` : key}`;
            return (
              <PropertyElement
                key={itemKey}
                name={String(key)}
                value={val}
                section={section}
                level={level + 1}
                parentPath={currentPath}
                objectPathMap={objectPathMap}
                changedKeys={changedKeys}
                allowEditing={canEditChildren}
              />
            );
          })}
        </div>
      );
    },
    [section, level, currentPath, objectPathMap, changedKeys, allowEditing],
  );

  if (checkCircularInValue) {
    return (
      <div className="react-scan-property">
        <div className="react-scan-property-content">
          <div className="react-scan-preview-line">
            <div className="react-scan-key">{name}:</div>
            <span className="text-yellow-500">[Circular Reference]</span>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div ref={refElement} className="react-scan-property">
      <div className="react-scan-property-content">
        {isExpandableValue && (
          <button
            type="button"
            onClick={handleToggleExpand}
            className="react-scan-arrow"
          >
            <Icon
              name="icon-chevron-right"
              size={12}
              className={cn(isExpanded && 'rotate-90')}
            />
          </button>
        )}

        <div
          className={cn(
            'group',
            'react-scan-preview-line',
            isChanged && 'react-scan-highlight',
          )}
        >
          <div className="react-scan-key">{name}:</div>
          {isEditing && isEditableValue(value, parentPath) ? (
            <EditableValue
              value={value}
              onSave={(newValue) => handleSave(section, name, newValue)}
              onCancel={() => setIsEditing(false)}
            />
          ) : (
            <button type="button" className="truncate" onClick={handleEdit}>
              {valuePreview}
            </button>
          )}
          <CopyToClipboard
            text={clipboardText}
            className="opacity-0 transition-opacity group-hover:opacity-100"
          >
            {({ ClipboardIcon }) => <>{ClipboardIcon}</>}
          </CopyToClipboard>
        </div>
        <div
          className={cn(
            'react-scan-expandable',
            isExpanded && 'react-scan-expanded',
          )}
        >
          {isExpandableValue && isExpanded && (
            <div className="react-scan-nested">
              {renderNestedProperties(value)}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export const PropertySection = ({
  refSticky,
  isSticky,
  section,
}: PropertySectionProps) => {
  const refStickyElement = useRef<HTMLElement | null>(null);
  const { updates, currentIndex } = timelineState.value;
  const [isExpanded, setIsExpanded] = useState(true);

  const refs = useMergedRefs(refStickyElement, refSticky);

  const pathMap = useMemo(() => new WeakMap<object, Set<string>>(), []);
  const { currentData, changedKeys } = useMemo(() => {
    const data = updates[currentIndex] ?? {
      props: { current: {}, changes: new Set() },
      state: { current: {}, changes: new Set() },
      context: { current: {}, changes: new Set() },
    };

    switch (section) {
      case 'props':
        return {
          currentData: data.props.current,
          changedKeys: data.props.changes,
        };
      case 'state':
        return {
          currentData: data.state.current,
          changedKeys: data.state.changes,
        };
      case 'context':
        return {
          currentData: data.context.current,
          changedKeys: data.context.changes,
        };
      default:
        return {
          currentData: {},
          changedKeys: new Set<string>(),
        };
    }
  }, [section, currentIndex, updates]);

  const toggleExpanded = useCallback(() => {
    setIsExpanded((state) => {
      if (isSticky && isExpanded) {
        return state;
      }
      return !state;
    });
  }, [isExpanded, isSticky]);

  if (
    !currentData ||
    (Array.isArray(currentData)
      ? currentData.length === 0
      : Object.keys(currentData).length === 0)
  ) {
    return null;
  }

  const propertyCount = Array.isArray(currentData)
    ? currentData.length
    : Object.keys(currentData).length;

  return (
    <>
      <button
        ref={refs}
        type="button"
        onClick={toggleExpanded}
        data-sticky
        className="react-section-header"
      >
        <div className="w-4 h-4 flex items-center justify-center">
          <Icon
            name="icon-chevron-right"
            size={12}
            className={cn(
              isExpanded && 'rotate-90',
              isSticky && isExpanded && 'rotate-0',
            )}
          />
        </div>
        <span className="capitalize">
          {section} {!isExpanded && propertyCount > 0 && `(${propertyCount})`}
        </span>
      </button>
      <div className="react-scan-section">
        <div
          className={cn(
            'react-scan-expandable',
            isExpanded && 'react-scan-expanded',
          )}
        >
          <div className="overflow-hidden">
            {Array.isArray(currentData)
              ? currentData.map(({ name, value }) => (
                  <PropertyElement
                    key={name}
                    name={name}
                    value={value}
                    section={section}
                    level={0}
                    objectPathMap={pathMap}
                    changedKeys={changedKeys}
                  />
                ))
              : Object.entries(currentData).map(([key, value]) => (
                  <PropertyElement
                    key={key}
                    name={key}
                    value={value}
                    section={section}
                    level={0}
                    objectPathMap={pathMap}
                    changedKeys={changedKeys}
                  />
                ))}
          </div>
        </div>
      </div>
    </>
  );
};
</file>

<file path="src/web/views/inspector/states.ts">
import { signal } from '@preact/signals';
import type { Fiber } from 'bippy';
import type { ComponentType } from 'preact';
import { flashManager } from './flash-overlay';
import { type SectionData, resetTracking } from './timeline/utils';

export interface MinimalFiberInfo {
  id?: string | number;
  key: string | null;
  type: ComponentType<unknown> | string;
  displayName: string;
  selfTime: number;
  totalTime: number;
}

export interface TimelineUpdate {
  timestamp: number;
  fiberInfo: MinimalFiberInfo;
  props: SectionData;
  state: SectionData;
  context: SectionData;
  stateNames: string[];
}

export interface TimelineState {
  updates: Array<TimelineUpdate>;
  currentFiber: Fiber | null;
  totalUpdates: number;
  windowOffset: number;
  currentIndex: number;
  isViewingHistory: boolean;
  latestFiber: Fiber | null;
  isVisible: boolean;
  playbackSpeed: 1 | 2 | 4;
}

export const TIMELINE_MAX_UPDATES = 1000;

export const timelineStateDefault: TimelineState = {
  updates: [],
  currentFiber: null,
  totalUpdates: 0,
  windowOffset: 0,
  currentIndex: 0,
  isViewingHistory: false,
  latestFiber: null,
  isVisible: false,
  playbackSpeed: 1,
};

export const timelineState = signal<TimelineState>(timelineStateDefault);

export const inspectorUpdateSignal = signal<number>(0);

let pendingUpdates: Array<{ update: TimelineUpdate; fiber: Fiber | null }> = [];
let batchTimeout: ReturnType<typeof setTimeout> | null = null;

const batchUpdates = () => {
  if (pendingUpdates.length === 0) return;

  const batchedUpdates = [...pendingUpdates];

  const { updates, totalUpdates, currentIndex, isViewingHistory } =
    timelineState.value;
  const newUpdates = [...updates];
  let newTotalUpdates = totalUpdates;

  for (const { update } of batchedUpdates) {
    if (newUpdates.length >= TIMELINE_MAX_UPDATES) {
      newUpdates.shift();
    }
    newUpdates.push(update);
    newTotalUpdates++;
  }

  const newWindowOffset = Math.max(0, newTotalUpdates - TIMELINE_MAX_UPDATES);

  let newCurrentIndex: number;
  if (isViewingHistory) {
    if (currentIndex === totalUpdates - 1) {
      newCurrentIndex = newUpdates.length - 1;
    } else if (currentIndex === 0) {
      newCurrentIndex = 0;
    } else {
      if (newWindowOffset === 0) {
        newCurrentIndex = currentIndex;
      } else {
        newCurrentIndex = currentIndex - 1;
      }
    }
  } else {
    newCurrentIndex = newUpdates.length - 1;
  }

  const lastUpdate = batchedUpdates[batchedUpdates.length - 1];

  timelineState.value = {
    ...timelineState.value,
    latestFiber: lastUpdate.fiber,
    updates: newUpdates,
    totalUpdates: newTotalUpdates,
    windowOffset: newWindowOffset,
    currentIndex: newCurrentIndex,
    isViewingHistory,
  };

  // Only after signal is updated, remove the processed updates
  pendingUpdates = pendingUpdates.slice(batchedUpdates.length);
};

export const timelineActions = {
  showTimeline: () => {
    timelineState.value = {
      ...timelineState.value,
      isVisible: true,
    };
  },

  hideTimeline: () => {
    timelineState.value = {
      ...timelineState.value,
      isVisible: false,
      currentIndex: timelineState.value.updates.length - 1,
    };
  },

  updateFrame: (index: number, isViewingHistory: boolean) => {
    timelineState.value = {
      ...timelineState.value,
      currentIndex: index,
      isViewingHistory,
    };
  },

  updatePlaybackSpeed: (speed: TimelineState['playbackSpeed']) => {
    timelineState.value = {
      ...timelineState.value,
      playbackSpeed: speed,
    };
  },

  addUpdate: (update: TimelineUpdate, latestFiber: Fiber | null) => {
    pendingUpdates.push({ update, fiber: latestFiber });

    if (!batchTimeout) {
      const processBatch = () => {
        batchUpdates();

        batchTimeout = null;

        if (pendingUpdates.length > 0) {
          batchTimeout = setTimeout(processBatch, 96);
        }
      };

      batchTimeout = setTimeout(processBatch, 96);
    }
  },

  reset: () => {
    if (batchTimeout) {
      clearTimeout(batchTimeout);
      batchTimeout = null;
    }
    pendingUpdates = [];
    timelineState.value = timelineStateDefault;
  },
};

export const globalInspectorState = {
  lastRendered: new Map<string, unknown>(),
  expandedPaths: new Set<string>(),
  cleanup: () => {
    globalInspectorState.lastRendered.clear();
    globalInspectorState.expandedPaths.clear();
    flashManager.cleanupAll();
    resetTracking();
    timelineState.value = timelineStateDefault;
  },
};
</file>

<file path="src/web/views/inspector/utils.ts">
import {
  type Fiber,
  FunctionComponentTag,
  type MemoizedState,
  getDisplayName,
  getTimings,
  isCompositeFiber,
  isHostFiber,
  traverseFiber,
} from 'bippy';
import { type PropsChange, ReactScanInternals } from '~core/index';
import { ChangeReason } from '~core/instrumentation';
import { isEqual } from '~core/utils';
import { batchGetBoundingRects } from '~web/utils/outline';
import { globalInspectorState } from '.';
import type { ExtendedReactRenderer } from '../../../types';
import { TIMELINE_MAX_UPDATES } from './states';
import type { MinimalFiberInfo } from './states';
import { getAllFiberContexts, getStateNames } from './timeline/utils';

interface StateItem {
  name: string;
  value: unknown;
}

// todo, change this to currently focused fiber
export type States =
  | {
      kind: 'inspecting';
      hoveredDomElement: Element | null;
    }
  | {
      kind: 'inspect-off';
    }
  | {
      kind: 'focused';
      focusedDomElement: Element;
      fiber: Fiber;
    }
  | {
      kind: 'uninitialized';
    };

interface ReactRootContainer {
  _reactRootContainer?: {
    _internalRoot?: {
      current?: {
        child: Fiber;
      };
    };
  };
}

interface ReactInternalProps {
  [key: string]: Fiber;
}

export const getFiberFromElement = (element: Element): Fiber | null => {
  if ('__REACT_DEVTOOLS_GLOBAL_HOOK__' in window) {
    const hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!hook?.renderers) return null;

    for (const [, renderer] of Array.from(hook.renderers)) {
      try {
        const fiber = renderer.findFiberByHostInstance?.(element);
        if (fiber) return fiber;
      } catch {
        // If React is mid-render, references to previous nodes may disappear
      }
    }
  }

  if ('_reactRootContainer' in element) {
    const elementWithRoot = element as unknown as ReactRootContainer;
    const rootContainer = elementWithRoot._reactRootContainer;
    return rootContainer?._internalRoot?.current?.child ?? null;
  }

  for (const key in element) {
    if (
      key.startsWith('__reactInternalInstance$') ||
      key.startsWith('__reactFiber')
    ) {
      const elementWithFiber = element as unknown as ReactInternalProps;
      return elementWithFiber[key];
    }
  }
  return null;
};

export const getFirstStateNode = (fiber: Fiber): Element | null => {
  let current: Fiber | null = fiber;
  while (current) {
    if (current.stateNode instanceof Element) {
      return current.stateNode;
    }

    if (!current.child) {
      break;
    }
    current = current.child;
  }

  while (current) {
    if (current.stateNode instanceof Element) {
      return current.stateNode;
    }

    if (!current.return) {
      break;
    }
    current = current.return;
  }
  return null;
};

export const getNearestFiberFromElement = (
  element: Element | null,
): Fiber | null => {
  if (!element) return null;

  try {
    const fiber = getFiberFromElement(element);
    if (!fiber) return null;

    const res = getParentCompositeFiber(fiber);
    return res ? res[0] : null;
  } catch {
    return null;
  }
};

export const getParentCompositeFiber = (
  fiber: Fiber,
): readonly [Fiber, Fiber | null] | null => {
  let current: Fiber | null = fiber;
  let prevHost: Fiber | null = null;

  while (current) {
    if (isCompositeFiber(current)) return [current, prevHost] as const;
    if (isHostFiber(current) && !prevHost) prevHost = current;
    current = current.return;
  }

  return null;
};


const isFiberInTree = (fiber: Fiber, root: Fiber): boolean => {
  {
    // const root= fiberRootCache.get(fiber) || (fiber.alternate && fiberRootCache.get(fiber.alternate) )
    // if (root){
    //   return root
    // }
    const res = !!traverseFiber(root, (searchFiber) => searchFiber === fiber);

    return res;
  }
};

export const isCurrentTree = (fiber: Fiber) => {
  let curr: Fiber | null = fiber;
  let rootFiber: Fiber | null = null;

  while (curr) {
    // todo: make sure removing null check doesn't break
    // todo: document that fiber stores root in stateNode
    if (!curr.stateNode) {
      curr = curr.return;
      continue;
    }
    // if the app never rendered then fiber roots will always return false, but thats fine since we don't care which
    // fiber we read from when there never has been a re-render
    // todo: document that better
    if (ReactScanInternals.instrumentation?.fiberRoots.has(curr.stateNode)) {
      rootFiber = curr;

      break;
    }

    curr = curr.return;
  }

  if (!rootFiber) {
    return false;
  }

  const fiberRoot = rootFiber.stateNode;
  const currentRootFiber = fiberRoot.current;

  return isFiberInTree(fiber, currentRootFiber);
};

export const getAssociatedFiberRect = async (element: Element) => {
  const associatedFiber = getNearestFiberFromElement(element);

  if (!associatedFiber) return null;
  const stateNode = getFirstStateNode(associatedFiber);
  if (!stateNode) return null;

  const rect = (await batchGetBoundingRects([stateNode])).get(stateNode);
  if (!rect) return null;
  return rect;
};

// todo-before-stable(rob): refactor these
export const getCompositeComponentFromElement = (element: Element) => {
  const associatedFiber = getNearestFiberFromElement(element);

  if (!associatedFiber) return {};

  const stateNode = getFirstStateNode(associatedFiber);
  if (!stateNode) return {};
  const parentCompositeFiberInfo = getParentCompositeFiber(associatedFiber);
  if (!parentCompositeFiberInfo) {
    return {};
  }
  const [parentCompositeFiber] = parentCompositeFiberInfo;

  return {
    parentCompositeFiber,
  };
};

export const getCompositeFiberFromElement = (
  element: Element,
  knownFiber?: Fiber,
) => {
  if (!element.isConnected) return {};

  let fiber = knownFiber ?? getNearestFiberFromElement(element);
  if (!fiber) return {};

  // Find root once and cache it
  let curr: Fiber | null = fiber;
  let rootFiber: Fiber | null = null;
  let currentRootFiber: Fiber | null = null;

  while (curr) {
    if (!curr.stateNode) {
      curr = curr.return;
      continue;
    }
    if (ReactScanInternals.instrumentation?.fiberRoots.has(curr.stateNode)) {
      rootFiber = curr;
      currentRootFiber = curr.stateNode.current;
      break;
    }
    curr = curr.return;
  }

  if (!rootFiber || !currentRootFiber) return {};

  // Get the current associated fiber using cached root
  fiber = isFiberInTree(fiber, currentRootFiber)
    ? fiber
    : (fiber.alternate ?? fiber);
  if (!fiber) return {};

  if (!getFirstStateNode(fiber)) return {};

  // Get parent composite fiber
  const parentCompositeFiber = getParentCompositeFiber(fiber)?.[0];
  if (!parentCompositeFiber) return {};

  // Use cached root to check parent fiber
  return {
    parentCompositeFiber: isFiberInTree(parentCompositeFiber, currentRootFiber)
      ? parentCompositeFiber
      : (parentCompositeFiber.alternate ?? parentCompositeFiber),
  };
};

export const getChangedPropsDetailed = (fiber: Fiber): Array<PropsChange> => {
  const currentProps = fiber.memoizedProps ?? {};
  const previousProps = fiber.alternate?.memoizedProps ?? {};
  const changes: Array<PropsChange> = [];

  for (const key in currentProps) {
    if (key === 'children') continue;

    const currentValue = currentProps[key];
    const prevValue = previousProps[key];

    if (!isEqual(currentValue, prevValue)) {
      changes.push({
        name: key,
        value: currentValue,
        prevValue,
        type: ChangeReason.Props,
      });
    }
  }

  return changes;
};

export interface OverrideMethods {
  overrideProps:
    | ((fiber: Fiber, path: string[], value: unknown) => void)
    | null;
  overrideHookState:
    | ((fiber: Fiber, id: string, path: string[], value: unknown) => void)
    | null;
  overrideContext:
    | ((fiber: Fiber, contextType: unknown, value: unknown) => void)
    | null;
}

const isRecord = (value: unknown): value is Record<string, unknown> => {
  return value !== null && typeof value === 'object';
};

export const getOverrideMethods = (): OverrideMethods => {
  let overrideProps: OverrideMethods['overrideProps'] = null;
  let overrideHookState: OverrideMethods['overrideHookState'] = null;
  let overrideContext: OverrideMethods['overrideContext'] = null;

  if ('__REACT_DEVTOOLS_GLOBAL_HOOK__' in window) {
    const hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!hook?.renderers) {
      return {
        overrideProps: null,
        overrideHookState: null,
        overrideContext: null,
      };
    }

    for (const [, renderer] of Array.from(hook.renderers)) {
      try {
        const devToolsRenderer = renderer as ExtendedReactRenderer;

        if (overrideHookState) {
          const prevOverrideHookState = overrideHookState;
          overrideHookState = (
            fiber: Fiber,
            id: string,
            path: string[],
            value: unknown,
          ) => {
            // Find the hook
            let current = fiber.memoizedState;
            for (let i = 0; i < Number(id); i++) {
              if (!current?.next) break;
              current = current.next;
            }

            if (current?.queue) {
              // Update through React's queue mechanism
              const queue = current.queue;
              if (isRecord(queue) && 'dispatch' in queue) {
                const dispatch = queue.dispatch as (value: unknown) => void;
                dispatch(value);
                return;
              }
            }

            // Chain updates through all renderers to ensure consistency across different React renderers
            // (e.g., React DOM + React Native Web in the same app)
            prevOverrideHookState(fiber, id, path, value);
            devToolsRenderer.overrideHookState?.(fiber, id, path, value);
          };
        } else if (devToolsRenderer.overrideHookState) {
          overrideHookState = devToolsRenderer.overrideHookState;
        }

        if (overrideProps) {
          const prevOverrideProps = overrideProps;
          overrideProps = (
            fiber: Fiber,
            path: Array<string>,
            value: unknown,
          ) => {
            // Chain updates through all renderers to maintain consistency
            prevOverrideProps(fiber, path, value);
            devToolsRenderer.overrideProps?.(fiber, path, value);
          };
        } else if (devToolsRenderer.overrideProps) {
          overrideProps = devToolsRenderer.overrideProps;
        }

        // For context, we don't need the chaining pattern since we're using overrideProps internally
        // to update the context provider's value prop, which already handles the chaining
        overrideContext = (
          fiber: Fiber,
          contextType: unknown,
          value: unknown,
        ) => {
          // Find the provider fiber for this context
          let current: Fiber | null = fiber;
          while (current) {
            const type = current.type as { Provider?: unknown };
            if (type === contextType || type?.Provider === contextType) {
              // Found the provider, update both current and alternate fibers
              if (overrideProps) {
                overrideProps(current, ['value'], value);
                if (current.alternate) {
                  overrideProps(current.alternate, ['value'], value);
                }
              }
              break;
            }
            current = current.return;
          }
        };
      } catch {
        /**/
      }
    }
  }

  return { overrideProps, overrideHookState, overrideContext };
};

export const nonVisualTags = new Set([
  'HTML',
  'HEAD',
  'META',
  'TITLE',
  'BASE',
  'SCRIPT',
  'SCRIPT',
  'STYLE',
  'LINK',
  'NOSCRIPT',
  'SOURCE',
  'TRACK',
  'EMBED',
  'OBJECT',
  'PARAM',
  'TEMPLATE',
  'PORTAL',
  'SLOT',
  'AREA',
  'XML',
  'DOCTYPE',
  'COMMENT',
]);

export const findComponentDOMNode = (
  fiber: Fiber,
  excludeNonVisualTags = true,
): HTMLElement | null => {
  if (fiber.stateNode && 'nodeType' in fiber.stateNode) {
    const element = fiber.stateNode as HTMLElement;
    if (
      excludeNonVisualTags &&
      element.tagName &&
      nonVisualTags.has(element.tagName.toLowerCase())
    ) {
      return null;
    }
    return element;
  }

  let child = fiber.child;
  while (child) {
    const result = findComponentDOMNode(child, excludeNonVisualTags);
    if (result) return result;
    child = child.sibling;
  }

  return null;
};

export interface InspectableElement {
  element: HTMLElement;
  depth: number;
  name: string;
  fiber: Fiber;
}

export const getInspectableElements = (
  root: HTMLElement = document.body,
): Array<InspectableElement> => {
  const result: Array<InspectableElement> = [];

  const findInspectableFiber = (
    element: HTMLElement | null,
  ): HTMLElement | null => {
    if (!element) return null;

    const { parentCompositeFiber } = getCompositeComponentFromElement(element);
    if (!parentCompositeFiber) return null;

    const componentRoot = findComponentDOMNode(parentCompositeFiber);
    return componentRoot === element ? element : null;
  };

  const traverse = (element: HTMLElement, depth = 0) => {
    const inspectable = findInspectableFiber(element);
    if (inspectable) {
      const { parentCompositeFiber } =
        getCompositeComponentFromElement(inspectable);

      if (!parentCompositeFiber) return;

      result.push({
        element: inspectable,
        depth,
        name: getDisplayName(parentCompositeFiber.type) ?? 'Unknown',
        fiber: parentCompositeFiber,
      });
    }

    // Traverse children first (depth-first)
    for (const child of Array.from(element.children)) {
      traverse(child as HTMLElement, inspectable ? depth + 1 : depth);
    }
  };

  traverse(root);
  return result;
};

const fiberMap = new WeakMap<HTMLElement, Fiber>();

export const getInspectableAncestors = (
  element: HTMLElement,
): Array<InspectableElement> => {
  const result: Array<InspectableElement> = [];

  const findInspectableFiber = (
    element: HTMLElement | null,
  ): HTMLElement | null => {
    if (!element) return null;
    const { parentCompositeFiber } = getCompositeComponentFromElement(element);
    if (!parentCompositeFiber) return null;

    const componentRoot = findComponentDOMNode(parentCompositeFiber);
    if (componentRoot === element) {
      // Store the fiber reference in WeakMap
      fiberMap.set(element, parentCompositeFiber);
      return element;
    }
    return null;
  };

  let current: HTMLElement | null = element;
  while (current && current !== document.body) {
    const inspectable = findInspectableFiber(current);
    if (inspectable) {
      // Get fiber from WeakMap
      const fiber = fiberMap.get(inspectable);
      if (fiber) {
        result.unshift({
          element: inspectable,
          depth: 0,
          name: getDisplayName(fiber.type) ?? 'Unknown',
          fiber,
        });
      }
    }
    current = current.parentElement;
  }

  return result;
};

type DiffResult = {
  type: 'primitive' | 'reference' | 'object';
  changes: Array<{
    path: string[];
    prevValue: unknown;
    currentValue: unknown;
    sameFunction?: boolean;
  }>;
  hasDeepChanges: boolean;
};

type DiffChange = {
  path: string[];
  prevValue: unknown;
  currentValue: unknown;
  sameFunction?: boolean;
};

type InspectableValue =
  | Record<string, unknown>
  | Array<unknown>
  | Map<unknown, unknown>
  | Set<unknown>
  | ArrayBuffer
  | DataView
  | Int8Array
  | Uint8Array
  | Uint8ClampedArray
  | Int16Array
  | Uint16Array
  | Int32Array
  | Uint32Array
  | Float32Array
  | Float64Array
  | BigInt64Array
  | BigUint64Array;

export type AggregatedChanges = {
  count: number;
  // unstable: boolean;
  currentValue: unknown;
  previousValue: unknown;
  // displayName?:string
  name: string;
};

export const isExpandable = (value: unknown): value is InspectableValue => {
  if (value === null || typeof value !== 'object' || isPromise(value)) {
    return false;
  }

  if (value instanceof ArrayBuffer) {
    return true;
  }

  if (value instanceof DataView) {
    return true;
  }

  if (ArrayBuffer.isView(value)) {
    return true;
  }

  if (value instanceof Map || value instanceof Set) {
    return value.size > 0;
  }

  if (Array.isArray(value)) {
    return value.length > 0;
  }

  return Object.keys(value).length > 0;
};

export const isEditableValue = (
  value: unknown,
  parentPath?: string,
): boolean => {
  if (value == null) return true;

  if (isPromise(value)) return false;

  if (typeof value === 'function') {
    return false;
  }

  if (parentPath) {
    const parts = parentPath.split('.');
    let currentPath = '';
    for (const part of parts) {
      currentPath = currentPath ? `${currentPath}.${part}` : part;
      const obj = globalInspectorState.lastRendered.get(currentPath);
      if (
        obj instanceof DataView ||
        obj instanceof ArrayBuffer ||
        ArrayBuffer.isView(obj)
      ) {
        return false;
      }
    }
  }

  switch (value.constructor) {
    case Date:
    case RegExp:
    case Error:
      return true;
    default:
      switch (typeof value) {
        case 'string':
        case 'number':
        case 'boolean':
        case 'bigint':
          return true;
        default:
          return false;
      }
  }
};

export const getPath = (
  componentName: string,
  section: string,
  parentPath: string,
  key: string,
): string => {
  if (parentPath) {
    return `${componentName}.${parentPath}.${key}`;
  }

  if (section === 'context' && !key.startsWith('context.')) {
    return `${componentName}.${section}.context.${key}`;
  }

  return `${componentName}.${section}.${key}`;
};

export const sanitizeString = (value: string): string => {
  return value
    .replace(/[<>]/g, '')
    .replace(/javascript:/gi, '')
    .replace(/data:/gi, '')
    .replace(/on\w+=/gi, '')
    .slice(0, 50000);
};

export const sanitizeErrorMessage = (error: string): string => {
  return error
    .replace(/[<>]/g, '')
    .replace(/&/g, '&amp;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;')
    .replace(/\//g, '&#x2F;');
};

export const formatValue = (value: unknown): string => {
  const metadata = ensureRecord(value);
  return metadata.displayValue as string;
};

export const formatForClipboard = (value: unknown): string => {
  try {
    if (value === null) return 'null';
    if (value === undefined) return 'undefined';
    if (isPromise(value)) return 'Promise';

    if (typeof value === 'function') {
      const fnStr = value.toString();
      try {
        const formatted = fnStr
          .replace(/\s+/g, ' ') // Normalize whitespace
          .replace(/{\s+/g, '{\n  ') // Add newline after {
          .replace(/;\s+/g, ';\n  ') // Add newline after ;
          .replace(/}\s*$/g, '\n}') // Add newline before final }
          .replace(/\(\s+/g, '(') // Remove space after (
          .replace(/\s+\)/g, ')') // Remove space before )
          .replace(/,\s+/g, ', '); // Normalize comma spacing

        return formatted;
      } catch {
        return fnStr;
      }
    }

    switch (true) {
      case value instanceof Date:
        return value.toISOString();
      case value instanceof RegExp:
        return value.toString();
      case value instanceof Error:
        return `${value.name}: ${value.message}`;
      case value instanceof Map:
        return JSON.stringify(Array.from(value.entries()), null, 2);
      case value instanceof Set:
        return JSON.stringify(Array.from(value), null, 2);
      case value instanceof DataView:
        return JSON.stringify(
          Array.from(new Uint8Array(value.buffer)),
          null,
          2,
        );
      case value instanceof ArrayBuffer:
        return JSON.stringify(Array.from(new Uint8Array(value)), null, 2);
      case ArrayBuffer.isView(value) && 'length' in value:
        return JSON.stringify(
          Array.from(value as unknown as ArrayLike<number>),
          null,
          2,
        );
      case Array.isArray(value):
        return JSON.stringify(value, null, 2);
      case typeof value === 'object':
        return JSON.stringify(value, null, 2);
      default:
        return String(value);
    }
  } catch {
    return String(value);
  }
};

export const parseArrayValue = (value: string): Array<unknown> => {
  if (value.trim() === '[]') return [];

  const result: Array<unknown> = [];
  let current = '';
  let depth = 0;
  let inString = false;
  let escapeNext = false;

  for (let i = 0; i < value.length; i++) {
    const char = value[i];

    if (escapeNext) {
      current += char;
      escapeNext = false;
      continue;
    }

    if (char === '\\') {
      escapeNext = true;
    }

    if (char === '"') {
      inString = !inString;
      current += char;
      continue;
    }

    if (inString) {
      current += char;
      continue;
    }

    if (char === '[' || char === '{') {
      depth++;
      current += char;
      continue;
    }

    if (char === ']' || char === '}') {
      depth--;
      current += char;
      continue;
    }

    if (char === ',' && depth === 0) {
      if (current.trim()) {
        result.push(parseValue(current.trim(), ''));
      }
      current = '';
      continue;
    }

    current += char;
  }

  if (current.trim()) {
    result.push(parseValue(current.trim(), ''));
  }

  return result;
};

export const parseValue = (value: string, currentType: unknown): unknown => {
  try {
    switch (typeof currentType) {
      case 'number':
        return Number(value);
      case 'string':
        return value;
      case 'boolean':
        return value === 'true';
      case 'bigint':
        return BigInt(value);
      case 'undefined':
        return undefined;
      case 'object': {
        if (!currentType) {
          return null;
        }

        if (Array.isArray(currentType)) {
          return parseArrayValue(value.slice(1, -1));
        }

        if (currentType instanceof RegExp) {
          try {
            const match = /^\/(?<pattern>.*)\/(?<flags>[gimuy]*)$/.exec(value);
            if (match?.groups) {
              return new RegExp(match.groups.pattern, match.groups.flags);
            }
            return new RegExp(value);
          } catch {
            return currentType;
          }
        }

        if (currentType instanceof Map) {
          const entries = value
            .slice(1, -1)
            .split(', ')
            .map((entry) => {
              const [key, val] = entry.split(' => ');
              return [parseValue(key, ''), parseValue(val, '')] as [
                unknown,
                unknown,
              ];
            });
          return new Map(entries);
        }

        if (currentType instanceof Set) {
          const values = value
            .slice(1, -1)
            .split(', ')
            .map((v) => parseValue(v, ''));
          return new Set(values);
        }
        const entries = value
          .slice(1, -1)
          .split(', ')
          .map((entry) => {
            const [key, val] = entry.split(': ');
            return [key, parseValue(val, '')];
          });
        return Object.fromEntries(entries);
      }
    }

    return value;
  } catch {
    return currentType;
  }
};

export const detectValueType = (
  value: string,
): {
  type: 'string' | 'number' | 'undefined' | 'null' | 'boolean';
  value: unknown;
} => {
  const trimmed = value.trim();

  switch (trimmed) {
    case 'undefined':
      return { type: 'undefined', value: undefined };
    case 'null':
      return { type: 'null', value: null };
    case 'true':
      return { type: 'boolean', value: true };
    case 'false':
      return { type: 'boolean', value: false };
  }

  if (/^".*"$/.test(trimmed)) {
    return { type: 'string', value: trimmed.slice(1, -1) };
  }

  if (/^-?\d+(?:\.\d+)?$/.test(trimmed)) {
    return { type: 'number', value: Number(trimmed) };
  }

  return { type: 'string', value: `"${trimmed}"` };
};

export const formatInitialValue = (value: unknown): string => {
  if (value === undefined) return 'undefined';
  if (value === null) return 'null';
  if (typeof value === 'string') return `"${value}"`;
  return String(value);
};

export const updateNestedValue = (
  obj: unknown,
  path: Array<string>,
  value: unknown,
): unknown => {
  try {
    if (path.length === 0) return value;

    const [key, ...rest] = path;

    // Handle our special array of {name, value} pairs
    if (
      Array.isArray(obj) &&
      obj.every((item): item is StateItem => 'name' in item && 'value' in item)
    ) {
      const index = obj.findIndex((item) => item.name === key);
      if (index === -1) return obj;

      const newArray = [...obj];
      if (rest.length === 0) {
        newArray[index] = { ...newArray[index], value };
      } else {
        newArray[index] = {
          ...newArray[index],
          value: updateNestedValue(newArray[index].value, rest, value),
        };
      }
      return newArray;
    }

    if (obj instanceof Map) {
      const newMap = new Map(obj);
      if (rest.length === 0) {
        newMap.set(key, value);
      } else {
        const currentValue = newMap.get(key);
        newMap.set(key, updateNestedValue(currentValue, rest, value));
      }
      return newMap;
    }

    if (Array.isArray(obj)) {
      const index = Number.parseInt(key, 10);
      const newArray = [...obj];
      if (rest.length === 0) {
        newArray[index] = value;
      } else {
        newArray[index] = updateNestedValue(obj[index], rest, value);
      }
      return newArray;
    }

    if (obj && typeof obj === 'object') {
      if (rest.length === 0) {
        return { ...obj, [key]: value };
      }
      return {
        ...obj,
        [key]: updateNestedValue(
          (obj as Record<string, unknown>)[key],
          rest,
          value,
        ),
      };
    }

    return value;
  } catch {
    return obj;
  }
};

export const areFunctionsEqual = (prev: unknown, current: unknown): boolean => {
  try {
    // Check if both values are actually functions
    if (typeof prev !== 'function' || typeof current !== 'function') {
      return false;
    }

    // Now we know both are functions, we can safely call toString()
    return prev.toString() === current.toString();
  } catch {
    return false;
  }
};

export const getObjectDiff = (
  prev: unknown,
  current: unknown,
  path: string[] = [],
  seen = new WeakSet(),
): DiffResult => {
  if (prev === current) {
    return { type: 'primitive', changes: [], hasDeepChanges: false };
  }

  if (typeof prev === 'function' && typeof current === 'function') {
    const isSameFunction = areFunctionsEqual(prev, current);
    return {
      type: 'primitive',
      changes: [
        {
          path,
          prevValue: prev,
          currentValue: current,
          sameFunction: isSameFunction,
        },
      ],
      hasDeepChanges: !isSameFunction,
    };
  }

  if (
    prev === null ||
    current === null ||
    prev === undefined ||
    current === undefined ||
    typeof prev !== 'object' ||
    typeof current !== 'object'
  ) {
    return {
      type: 'primitive',
      changes: [{ path, prevValue: prev, currentValue: current }],
      hasDeepChanges: true,
    };
  }

  if (seen.has(prev) || seen.has(current)) {
    return {
      type: 'object',
      changes: [{ path, prevValue: '[Circular]', currentValue: '[Circular]' }],
      hasDeepChanges: false,
    };
  }

  seen.add(prev);
  seen.add(current);

  const prevObj = prev as Record<string, unknown>;
  const currentObj = current as Record<string, unknown>;
  const allKeys = new Set([
    ...Object.keys(prevObj),
    ...Object.keys(currentObj),
  ]);
  const changes: Array<DiffChange> = [];
  let hasDeepChanges = false;

  for (const key of allKeys) {
    const prevValue = prevObj[key];
    const currentValue = currentObj[key];

    if (prevValue !== currentValue) {
      if (
        typeof prevValue === 'object' &&
        typeof currentValue === 'object' &&
        prevValue !== null &&
        currentValue !== null
      ) {
        const nestedDiff = getObjectDiff(
          prevValue,
          currentValue,
          [...path, key],
          seen,
        );
        changes.push(...nestedDiff.changes);
        if (nestedDiff.hasDeepChanges) {
          hasDeepChanges = true;
        }
      } else {
        changes.push({
          path: [...path, key],
          prevValue,
          currentValue,
        });
        hasDeepChanges = true;
      }
    }
  }

  return {
    type: 'object',
    changes,
    hasDeepChanges,
  };
};

export const formatPath = (path: string[]): string => {
  if (path.length === 0) return '';

  return path.reduce((acc, segment, i) => {
    // Check if segment is a number (array index)
    if (/^\d+$/.test(segment)) {
      return `${acc}[${segment}]`;
    }
    // Add dot separator only if not first segment and previous segment wasn't an array index
    return i === 0 ? segment : `${acc}.${segment}`;
  }, '');
};

export const formatFunctionBody = (body: string): string => {
  // Remove newlines and extra spaces
  let formatted = body.replace(/\s+/g, ' ').trim();

  // Add newlines after {, ; and before }
  formatted = formatted
    .replace(/{/g, '{\n  ')
    .replace(/;/g, ';\n  ')
    .replace(/}/g, '\n}')
    .replace(/{\s+}/g, '{ }'); // Clean up empty blocks

  // Clean up arrow functions
  formatted = formatted.replace(/=> {\n/g, '=> {').replace(/\n\s*}\s*$/g, ' }');

  return formatted;
};

export function hackyJsFormatter(code: string) {
  //
  // 1) Collapse runs of whitespace to single spaces
  //
  const normalizedCode = code.replace(/\s+/g, ' ').trim();

  //
  // 2) Tokenize
  //    We'll separate out:
  //    - parentheses: ( )
  //    - braces: { }
  //    - brackets: [ ]
  //    - angle brackets: < >
  //    - semicolon: ;
  //    - comma: ,
  //    - arrow =>
  //    - colon :
  //    - question mark ?
  //    - exclamation mark ! (for TS non-null etc.)
  //
  //    We'll also try to combine () or [] or {} or <> if they appear empty.
  //
  const rawTokens = [];
  let current = '';
  for (let i = 0; i < normalizedCode.length; i++) {
    const c = normalizedCode[i];

    // Detect arrow =>
    if (c === '=' && normalizedCode[i + 1] === '>') {
      if (current.trim()) rawTokens.push(current.trim());
      rawTokens.push('=>');
      current = '';
      i++;
      continue;
    }

    // Single/double char punctuation
    if (/[(){}[\];,<>:\?!]/.test(c)) {
      // If we had something in current, push it
      if (current.trim()) {
        rawTokens.push(current.trim());
      }
      rawTokens.push(c);
      current = '';
    } else if (/\s/.test(c)) {
      // whitespace ends the current token
      if (current.trim()) {
        rawTokens.push(current.trim());
      }
      current = '';
    } else {
      current += c;
    }
  }
  if (current.trim()) {
    rawTokens.push(current.trim());
  }

  //
  // 3) Combine immediate pairs of empty brackets, e.g. '(' + ')' => '()'
  //    This helps keep arrow param empty parens on one line, etc.
  //
  const merged: Array<string> = [];
  for (let i = 0; i < rawTokens.length; i++) {
    const t = rawTokens[i];
    const n = rawTokens[i + 1];
    if (
      (t === '(' && n === ')') ||
      (t === '[' && n === ']') ||
      (t === '{' && n === '}') ||
      (t === '<' && n === '>')
    ) {
      merged.push(t + n); // '()', '[]', '{}', '<>'
      i++;
    } else {
      merged.push(t);
    }
  }

  //
  // 4) We want to detect arrow param lists:
  //    i.e. "(" ... ")" immediately followed by "=>"
  //    so we can keep them on one line.
  //
  //    Also, detect generic param lists:
  //    i.e. identifier "<" ... ">" (then maybe "(" ) for function calls or type declarations
  //
  //    We'll store indexes in sets: arrowParamSet, genericSet
  //
  const arrowParamSet = new Set(); // indexes inside arrow param lists
  const genericSet = new Set(); // indexes inside generics <...>

  function findMatchingPair(
    openTok: string,
    closeTok: string,
    startIndex: number,
  ) {
    // e.g. openTok = '(', closeTok = ')'
    let depth = 0;
    for (let j = startIndex; j < merged.length; j++) {
      const token = merged[j];
      if (token === openTok) depth++;
      else if (token === closeTok) {
        depth--;
        if (depth === 0) return j;
      }
    }
    return -1;
  }

  // Detect arrow param sets
  for (let i = 0; i < merged.length; i++) {
    const t = merged[i];
    if (t === '(') {
      const closeIndex = findMatchingPair('(', ')', i);
      if (closeIndex !== -1 && merged[closeIndex + 1] === '=>') {
        // Mark all tokens from i..closeIndex as arrow param
        for (let k = i; k <= closeIndex; k++) {
          arrowParamSet.add(k);
        }
      }
    }
  }

  // Detect generics, e.g. foo<...> or MyType<...>
  // We do a naive approach: if we see something that looks like an identifier
  // followed immediately by '<', we assume it's a generic.
  for (let i = 1; i < merged.length; i++) {
    const prev = merged[i - 1];
    const t = merged[i];
    // If prev is an identifier and t is '<', find matching '>'
    if (/^[a-zA-Z0-9_$]+$/.test(prev) && t === '<') {
      const closeIndex = findMatchingPair('<', '>', i);
      if (closeIndex !== -1) {
        // Mark i..closeIndex as generic
        for (let k = i; k <= closeIndex; k++) {
          genericSet.add(k);
        }
      }
    }
  }

  //
  // 5) Build lines with indentation. We maintain a stack for open brackets.
  //
  let indentLevel = 0;
  const indentStr = '  '; // 2 spaces
  const lines: Array<string> = [];
  let line = '';

  function pushLine() {
    if (line.trim()) {
      lines.push(line.replace(/\s+$/, ''));
    }
    line = '';
  }
  function newLine() {
    pushLine();
    line = indentStr.repeat(indentLevel);
  }

  const stack: Array<string> = [];
  function stackTop() {
    return stack.length ? stack[stack.length - 1] : null;
  }

  function placeToken(tok: string, noSpaceBefore = false) {
    if (!line.trim()) {
      // line is empty aside from indentation
      line += tok;
    } else {
      if (noSpaceBefore || /^[),;:\].}>]$/.test(tok)) {
        line += tok;
      } else {
        line += ` ${tok}`;
      }
    }
  }

  for (let i = 0; i < merged.length; i++) {
    const tok = merged[i];
    const next = merged[i + 1] || '';

    // Open brackets
    if (['(', '{', '[', '<'].includes(tok)) {
      placeToken(tok);
      stack.push(tok);

      // If '{', definitely newline + indent
      if (tok === '{') {
        indentLevel++;
        newLine();
      } else if (tok === '(' || tok === '[' || tok === '<') {
        // If we are in arrowParamSet or genericSet, keep it on one line
        if (
          (arrowParamSet.has(i) && tok === '(') ||
          (genericSet.has(i) && tok === '<')
        ) {
          // Don't break lines after commas etc.
          // We won't do multiline logic for these.
        } else {
          // If next is not a direct close, go multiline
          const directClose = {
            '(': ')',
            '[': ']',
            '<': '>',
          }[tok];
          if (
            next !== directClose &&
            next !== '()' &&
            next !== '[]' &&
            next !== '<>'
          ) {
            indentLevel++;
            newLine();
          }
        }
      }
    }

    // Close brackets
    else if ([')', '}', ']', '>'].includes(tok)) {
      // pop stack
      const opening = stackTop();
      if (
        (tok === ')' && opening === '(') ||
        (tok === ']' && opening === '[') ||
        (tok === '>' && opening === '<')
      ) {
        // if not arrowParamSet or genericSet, multiline
        if (
          !(arrowParamSet.has(i) && tok === ')') &&
          !(genericSet.has(i) && tok === '>')
        ) {
          indentLevel = Math.max(indentLevel - 1, 0);
          newLine();
        }
      } else if (tok === '}' && opening === '{') {
        indentLevel = Math.max(indentLevel - 1, 0);
        newLine();
      }
      stack.pop();
      placeToken(tok);
      if (tok === '}') {
        // break line after }
        newLine();
      }
    }

    // Combined empty pairs like '()', '[]', '{}', '<>'
    else if (/^\(\)|\[\]|\{\}|\<\>$/.test(tok)) {
      placeToken(tok);

      // Arrow =>
    } else if (tok === '=>') {
      placeToken(tok);
      // We'll let the next token (maybe '{') handle line breaks.

      // Semicolon
    } else if (tok === ';') {
      placeToken(tok, true);
      newLine();

      // Comma
    } else if (tok === ',') {
      placeToken(tok, true);
      // If inside an arrow param set or generic set, don't break
      // Otherwise, if top is {, (, [ or <, break line
      const top = stackTop();
      if (
        !(arrowParamSet.has(i) && top === '(') &&
        !(genericSet.has(i) && top === '<')
      ) {
        if (top && ['{', '[', '(', '<'].includes(top)) {
          newLine();
        }
      }

      // Everything else (identifiers, operators, colons, question marks, etc.)
    } else {
      placeToken(tok);
    }
  }

  pushLine();

  // Remove extra blank lines
  return lines
    .join('\n')
    .replace(/\n\s*\n+/g, '\n')
    .trim();
}

// Update the formatFunctionPreview to use the new formatter
export const formatFunctionPreview = (
  fn: { toString(): string },
  expanded = false,
): string => {
  try {
    const fnStr = fn.toString();
    const match = fnStr.match(
      /(?:function\s*)?(?:\(([^)]*)\)|([^=>\s]+))\s*=>?/,
    );
    if (!match) return '';

    const params = match[1] || match[2] || '';
    const cleanParams = params.replace(/\s+/g, '');

    if (!expanded) {
      return ` (${cleanParams}) => ...`;
    }

    // For expanded view, use the new formatter
    return hackyJsFormatter(fnStr);
  } catch {
    return '';
  }
};

export const formatValuePreview = (value: unknown): string => {
  if (value === null) return 'null';
  if (value === undefined) return 'undefined';
  if (typeof value === 'string')
    return `"${value.length > 150 ? `${value.slice(0, 20)}...` : value}"`;
  if (typeof value === 'number' || typeof value === 'boolean')
    return String(value);
  if (typeof value === 'function') return formatFunctionPreview(value);
  if (Array.isArray(value)) return `Array(${value.length})`;
  if (value instanceof Map) return `Map(${value.size})`;
  if (value instanceof Set) return `Set(${value.size})`;
  if (value instanceof Date) return value.toISOString();
  if (value instanceof RegExp) return value.toString();
  if (value instanceof Error) return `${value.name}: ${value.message}`;
  if (typeof value === 'object') {
    const keys = Object.keys(value as object);
    return `{${keys.length > 2 ? `${keys.slice(0, 2).join(', ')}, ...` : keys.join(', ')}}`;
  }
  return String(value);
};

export const safeGetValue = (
  value: unknown,
): { value: unknown; error?: string } => {
  if (value === null || value === undefined) return { value };
  if (typeof value === 'function') return { value };
  if (typeof value !== 'object') return { value };

  if (value instanceof Promise) {
    // Handle promises without accessing them
    return { value: 'Promise' };
  }

  try {
    // Handle potential proxy traps or getter errors
    const proto = Object.getPrototypeOf(value);
    if (proto === Promise.prototype || proto?.constructor?.name === 'Promise') {
      return { value: 'Promise' };
    }

    return { value };
  } catch {
    return { value: null, error: 'Error accessing value' };
  }
};

export interface TimelineSliderValues {
  leftValue: number;
  min: number;
  max: number;
  value: number;
  rightValue: number;
}

export const calculateSliderValues = (
  totalUpdates: number,
  currentIndex: number,
): TimelineSliderValues => {
  if (totalUpdates <= TIMELINE_MAX_UPDATES) {
    return {
      leftValue: 0,
      min: 0,
      max: totalUpdates - 1,
      value: currentIndex,
      rightValue: totalUpdates - 1,
    };
  }

  return {
    leftValue: totalUpdates - TIMELINE_MAX_UPDATES,
    min: 0,
    max: TIMELINE_MAX_UPDATES - 1,
    value: currentIndex,
    rightValue: totalUpdates - 1,
  };
};

// be careful, this is an implementation detail is not stable or reliable across all react versions https://github.com/facebook/react/pull/15124
// type UpdateQueue<S, A> = {
//   last: Update<S, A> | null,
//   dispatch: (A => mixed) | null,
//   eagerReducer: ((S, A) => S) | null,
//   eagerState: S | null,
// };

interface ExtendedMemoizedState extends MemoizedState {
  queue?: {
    lastRenderedState: unknown;
  } | null;
  element?: unknown;
}

export const isDirectComponent = (fiber: Fiber): boolean => {
  if (!fiber || !fiber.type) return false;

  const isFunctionalComponent = typeof fiber.type === 'function';
  const isClassComponent = fiber.type?.prototype?.isReactComponent ?? false;

  if (!(isFunctionalComponent || isClassComponent)) return false;

  if (isClassComponent) {
    return true;
  }

  let memoizedState = fiber.memoizedState;
  while (memoizedState) {
    if (memoizedState.queue) {
      return true;
    }
    const nextState: ExtendedMemoizedState | null = memoizedState.next;
    if (!nextState) break;
    memoizedState = nextState;
  }

  return false;
};

export const isPromise = (value: unknown): value is Promise<unknown> => {
  return (
    !!value &&
    (value instanceof Promise || (typeof value === 'object' && 'then' in value))
  );
};

export const ensureRecord = (
  value: unknown,
  maxDepth = 2,
  seen = new WeakSet<object>(),
): Record<string, unknown> => {
  if (isPromise(value)) {
    return { type: 'promise', displayValue: 'Promise' };
  }

  if (value === null) {
    return { type: 'null', displayValue: 'null' };
  }

  if (value === undefined) {
    return { type: 'undefined', displayValue: 'undefined' };
  }

  switch (typeof value) {
    case 'object': {
      if (seen.has(value)) {
        return { type: 'circular', displayValue: '[Circular Reference]' };
      }

      if (!value) return { type: 'null', displayValue: 'null' };

      seen.add(value);

      try {
        const result: Record<string, unknown> = {};

        if (value instanceof Element) {
          result.type = 'Element';
          result.tagName = value.tagName.toLowerCase();
          result.displayValue = value.tagName.toLowerCase();
          return result;
        }

        if (value instanceof Map) {
          result.type = 'Map';
          result.size = value.size;
          result.displayValue = `Map(${value.size})`;

          if (maxDepth > 0) {
            const entries: Record<string, unknown> = {};
            let index = 0;
            for (const [key, val] of value.entries()) {
              if (index >= 50) break;
              try {
                entries[String(key)] = ensureRecord(val, maxDepth - 1, seen);
              } catch {
                entries[String(index)] = {
                  type: 'error',
                  displayValue: 'Error accessing Map entry',
                };
              }
              index++;
            }
            result.entries = entries;
          }
          return result;
        }

        if (value instanceof Set) {
          result.type = 'Set';
          result.size = value.size;
          result.displayValue = `Set(${value.size})`;

          if (maxDepth > 0) {
            const items = [];
            let count = 0;
            for (const item of value) {
              if (count >= 50) break;
              items.push(ensureRecord(item, maxDepth - 1, seen));
              count++;
            }
            result.items = items;
          }
          return result;
        }

        if (value instanceof Date) {
          result.type = 'Date';
          result.value = value.toISOString();
          result.displayValue = value.toLocaleString();
          return result;
        }

        if (value instanceof RegExp) {
          result.type = 'RegExp';
          result.value = value.toString();
          result.displayValue = value.toString();
          return result;
        }

        if (value instanceof Error) {
          result.type = 'Error';
          result.name = value.name;
          result.message = value.message;
          result.displayValue = `${value.name}: ${value.message}`;
          return result;
        }

        if (value instanceof ArrayBuffer) {
          result.type = 'ArrayBuffer';
          result.byteLength = value.byteLength;
          result.displayValue = `ArrayBuffer(${value.byteLength})`;
          return result;
        }

        if (value instanceof DataView) {
          result.type = 'DataView';
          result.byteLength = value.byteLength;
          result.displayValue = `DataView(${value.byteLength})`;
          return result;
        }

        if (ArrayBuffer.isView(value)) {
          const typedArray = value as unknown as {
            length: number;
            constructor: { name: string };
            buffer: ArrayBuffer;
          };
          result.type = typedArray.constructor.name;
          result.length = typedArray.length;
          result.byteLength = typedArray.buffer.byteLength;
          result.displayValue = `${typedArray.constructor.name}(${typedArray.length})`;
          return result;
        }

        if (Array.isArray(value)) {
          result.type = 'array';
          result.length = value.length;
          result.displayValue = `Array(${value.length})`;

          if (maxDepth > 0) {
            result.items = value
              .slice(0, 50)
              .map((item) => ensureRecord(item, maxDepth - 1, seen));
          }
          return result;
        }

        const keys = Object.keys(value);
        result.type = 'object';
        result.size = keys.length;
        result.displayValue =
          keys.length <= 5
            ? `{${keys.join(', ')}}`
            : `{${keys.slice(0, 5).join(', ')}, ...${keys.length - 5}}`;

        if (maxDepth > 0) {
          const entries: Record<string, unknown> = {};
          for (const key of keys.slice(0, 50)) {
            try {
              entries[key] = ensureRecord(
                (value as Record<string, unknown>)[key],
                maxDepth - 1,
                seen,
              );
            } catch {
              entries[key] = {
                type: 'error',
                displayValue: 'Error accessing property',
              };
            }
          }
          result.entries = entries;
        }
        return result;
      } finally {
        seen.delete(value);
      }
    }
    case 'string':
      return {
        type: 'string',
        value,
        displayValue: `"${value}"`,
      };
    case 'function':
      return {
        type: 'function',
        displayValue: '()',
        name: value.name || 'anonymous',
      };
    default:
      return {
        type: typeof value,
        value,
        displayValue: String(value),
      };
  }
};

export const getCurrentFiberState = (
  fiber: Fiber,
): Record<string, unknown> | null => {
  if (fiber.tag !== FunctionComponentTag || !isDirectComponent(fiber)) {
    return null;
  }

  const currentIsNewer = fiber.alternate
    ? (fiber.actualStartTime ?? 0) > (fiber.alternate.actualStartTime ?? 0)
    : true;

  const memoizedState: ExtendedMemoizedState | null = currentIsNewer
    ? fiber.memoizedState
    : (fiber.alternate?.memoizedState ?? fiber.memoizedState);

  if (!memoizedState) return null;

  return memoizedState;
};

export const replayComponent = async (fiber: Fiber): Promise<void> => {
  const { overrideProps, overrideHookState, overrideContext } =
    getOverrideMethods();
  if (!overrideProps || !overrideHookState || !fiber) return;

  try {
    // Handle props updates
    const currentProps = fiber.memoizedProps || {};
    const propKeys = Object.keys(currentProps).filter((key) => {
      const value = currentProps[key];
      if (Array.isArray(value) || typeof value === 'string') {
        return !Number.isInteger(Number(key)) && key !== 'length';
      }
      return true;
    });

    for (const key of propKeys) {
      try {
        const value = currentProps[key];
        // For arrays and objects, we need to clone to trigger updates
        const propValue = Array.isArray(value)
          ? [...value]
          : typeof value === 'object' && value !== null
            ? { ...value }
            : value;
        overrideProps(fiber, [key], propValue);
      } catch {}
    }

    // Handle state updates
    const currentState = getCurrentFiberState(fiber);
    if (currentState) {
      const stateNames = getStateNames(fiber);

      // First, handle named state hooks
      for (const [key, value] of Object.entries(currentState)) {
        try {
          const namedStateIndex = stateNames.indexOf(key);
          if (namedStateIndex !== -1) {
            const hookId = namedStateIndex.toString();
            // For arrays and objects, we need to clone to trigger updates
            const stateValue = Array.isArray(value)
              ? [...value]
              : typeof value === 'object' && value !== null
                ? { ...value }
                : value;
            overrideHookState(fiber, hookId, [], stateValue);
          }
        } catch {}
      }

      // Then handle unnamed state hooks
      let hookIndex = 0;
      let currentHook = fiber.memoizedState;
      while (currentHook !== null) {
        try {
          const hookId = hookIndex.toString();
          const value = currentHook.memoizedState;

          // Only update if this hook isn't already handled by named states
          if (!stateNames.includes(hookId)) {
            // For arrays and objects, we need to clone to trigger updates
            const stateValue = Array.isArray(value)
              ? [...value]
              : typeof value === 'object' && value !== null
                ? { ...value }
                : value;
            overrideHookState(fiber, hookId, [], stateValue);
          }
        } catch {}

        currentHook = currentHook.next as typeof currentHook;
        hookIndex++;
      }
    }

    // Handle context updates
    if (overrideContext) {
      const contexts = getAllFiberContexts(fiber);
      if (contexts) {
        for (const [contextType, ctx] of contexts) {
          try {
            // Find the provider fiber for this context
            let current: Fiber | null = fiber;
            while (current) {
              const type = current.type as { Provider?: unknown };
              if (type === contextType || type?.Provider === contextType) {
                // Get the value we want to update to
                const newValue = ctx.value;
                if (newValue === undefined || newValue === null) break;

                // Only update if the value has actually changed
                const currentValue = current.memoizedProps?.value;
                if (isEqual(currentValue, newValue)) break;

                // Update the provider's value prop
                overrideProps(current, ['value'], newValue);
                if (current.alternate) {
                  overrideProps(current.alternate, ['value'], newValue);
                }
                break;
              }
              current = current.return;
            }
          } catch {}
        }
      }
    }

    // Recursively handle children
    let child = fiber.child;
    while (child) {
      await replayComponent(child);
      child = child.sibling;
    }
  } catch {}
};

export const extractMinimalFiberInfo = (fiber: Fiber): MinimalFiberInfo => {
  const timings = getTimings(fiber);
  return {
    displayName: getDisplayName(fiber) || 'Unknown',
    type: fiber.type,
    key: fiber.key,
    id: fiber.index,
    selfTime: timings?.selfTime ?? null,
    totalTime: timings?.totalTime ?? null,
  };
};
</file>

<file path="src/web/views/inspector/what-changed.tsx">
import { type ReactNode, memo } from 'preact/compat';
import {
  type Dispatch,
  type StateUpdater,
  useEffect,
  useRef,
  useState,
} from 'preact/hooks';
import { CopyToClipboard } from '~web/components/copy-to-clipboard';
import { Icon } from '~web/components/icon';
import { cn, throttle } from '~web/utils/helpers';
import { DiffValueView } from './diff-value';
import { timelineState } from './states';
import {
  AggregatedChanges,
  formatFunctionPreview,
  formatPath,
  getObjectDiff,
  isPromise,
} from './utils';
import {
  calculateTotalChanges,
  useInspectedFiberChangeStore,
} from './whats-changed/use-change-store';
import { getDisplayName, getType } from 'bippy';
import { Store } from '~core/index';

export type Setter<T> = Dispatch<StateUpdater<T>>;

const safeGetValue = (value: unknown): { value: unknown; error?: string } => {
  if (value === null || value === undefined) return { value };
  if (typeof value === 'function') return { value };
  if (typeof value !== 'object') return { value };

  if (isPromise(value)) {
    return { value: 'Promise' };
  }

  try {
    const proto = Object.getPrototypeOf(value);
    if (proto === Promise.prototype || proto?.constructor?.name === 'Promise') {
      return { value: 'Promise' };
    }

    return { value };
  } catch {
    return { value: null, error: 'Error accessing value' };
  }
};

export const WhatChanged = /* @__PURE__ */ memo(() => {
  const [isExpanded, setIsExpanded] = useState(true);
  const aggregatedChanges = useInspectedFiberChangeStore();

  const [hasInitialized, setHasInitialized] = useState(false);
  const hasAnyChanges = calculateTotalChanges(aggregatedChanges) > 0;
  useEffect(() => {
    if (!hasInitialized && hasAnyChanges) {
      const timer = setTimeout(() => {
        setHasInitialized(true);
        requestAnimationFrame(() => {
          setIsExpanded(true);
        });
      }, 0);
      return () => clearTimeout(timer);
    }
  }, [hasInitialized, hasAnyChanges]);

  const initializedContextChanges = new Map(
    Array.from(aggregatedChanges.contextChanges.entries())
      .filter(([, value]) => value.kind === 'initialized')
      .map(([key, value]) => [
        key,
        // biome-ignore lint/style/noNonNullAssertion: <explanation>
        value.kind === 'partially-initialized' ? null! : value.changes,
      ]),
  );

  const fiber =
    Store.inspectState.value.kind === 'focused'
      ? Store.inspectState.value.fiber
      : null;

  if (!fiber) {
    // invariant
    return;
  }
  return (
    <>
      <WhatsChangedHeader />

      <div className="overflow-hidden h-full flex flex-col gap-y-2">
        <div className="flex flex-col gap-2 px-3 pt-2">
          <span className="text-sm font-medium text-[#888]">
            Why did{' '}
            <span className="text-[#A855F7]">{getDisplayName(fiber)}</span>{' '}
            render?
          </span>
          {!hasAnyChanges && (
            <div className="text-sm text-[#737373] bg-[#1E1E1E] rounded-md p-4 flex flex-col gap-4">
              <div>No changes detected since selecting</div>
              <div>
                The props, state, and context changes within your component will
                be reported here
              </div>
            </div>
          )}
        </div>
        <div
          className={cn(
            'flex flex-col gap-y-2 pl-3 relative overflow-y-auto h-full',
          )}
        >
          <Section
            changes={aggregatedChanges.propsChanges}
            title="Changed Props"
            isExpanded={isExpanded}
          />
          <Section
            renderName={(name) =>
              renderStateName(
                name,
                getDisplayName(getType(fiber)) ?? 'Unknown Component',
              )
            }
            changes={aggregatedChanges.stateChanges}
            title="Changed State"
            isExpanded={isExpanded}
          />
          <Section
            changes={initializedContextChanges}
            title="Changed Context"
            isExpanded={isExpanded}
          />
        </div>
      </div>
    </>
  );
});

const renderStateName = (key: string, componentName: string) => {
  if (Number.isNaN(Number(key))) {
    return key;
  }

  const n = Number.parseInt(key);
  const getOrdinalSuffix = (num: number) => {
    const lastDigit = num % 10;
    const lastTwoDigits = num % 100;
    if (lastTwoDigits >= 11 && lastTwoDigits <= 13) {
      return 'th';
    }
    switch (lastDigit) {
      case 1:
        return 'st';
      case 2:
        return 'nd';
      case 3:
        return 'rd';
      default:
        return 'th';
    }
  };

  return (
    <span className="truncate">
      <span className="text-white">
        {n}
        {getOrdinalSuffix(n)} hook{' '}
      </span>
      <span style={{ color: '#666' }}>
        called in <i className="text-[#A855F7] truncate">{componentName}</i>
      </span>
    </span>
  );
};

const WhatsChangedHeader = memo(() => {
  const refProps = useRef<HTMLDivElement>(null);
  const refState = useRef<HTMLDivElement>(null);
  const refContext = useRef<HTMLDivElement>(null);

  const refStats = useRef<{
    isPropsChanged: boolean;
    isStateChanged: boolean;
    isContextChanged: boolean;
  }>({
    isPropsChanged: false,
    isStateChanged: false,
    isContextChanged: false,
  });

  useEffect(() => {
    const flash = throttle(() => {
      const flashElements = [];
      if (refProps.current?.dataset.flash === 'true') {
        flashElements.push(refProps.current);
      }
      if (refState.current?.dataset.flash === 'true') {
        flashElements.push(refState.current);
      }
      if (refContext.current?.dataset.flash === 'true') {
        flashElements.push(refContext.current);
      }

      for (const element of flashElements) {
        element.classList.remove('count-flash-white');
        void element.offsetWidth;
        element.classList.add('count-flash-white');
      }
    }, 400);

    const unsubscribe = timelineState.subscribe((state) => {
      if (!refProps.current || !refState.current || !refContext.current) {
        return;
      }

      const { currentIndex, updates } = state;
      const currentUpdate = updates[currentIndex];

      if (!currentUpdate || currentIndex === 0) {
        return;
      }

      flash();

      refStats.current = {
        isPropsChanged: (currentUpdate.props?.changes?.size ?? 0) > 0,
        isStateChanged: (currentUpdate.state?.changes?.size ?? 0) > 0,
        isContextChanged: (currentUpdate.context?.changes?.size ?? 0) > 0,
      };

      if (refProps.current.dataset.flash !== 'true') {
        refProps.current.dataset.flash =
          refStats.current.isPropsChanged.toString();
      }
      if (refState.current.dataset.flash !== 'true') {
        refState.current.dataset.flash =
          refStats.current.isStateChanged.toString();
      }
      if (refContext.current.dataset.flash !== 'true') {
        refContext.current.dataset.flash =
          refStats.current.isContextChanged.toString();
      }
    });

    return unsubscribe;
  }, []);

  return (
    <button
      type="button"
      className={cn(
        'react-section-header',
        'overflow-hidden',
        'max-h-0',
        'transition-[max-height]',
      )}
    >
      <div className={cn('flex-1 react-scan-expandable')}>
        <div className="overflow-hidden">
          <div className="flex items-center whitespace-nowrap">
            <div className="flex items-center gap-x-2">What changed?</div>

            <div
              className={cn(
                'ml-auto',
                'change-scope',
                'transition-opacity duration-300 delay-150',
              )}
            >
              <div ref={refProps}>props</div>
              <div ref={refState}>state</div>
              <div ref={refContext}>context</div>
            </div>
          </div>
        </div>
      </div>
    </button>
  );
});

interface SectionProps {
  title: string;
  isExpanded: boolean;
  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
  changes: Map<any, AggregatedChanges>;
  renderName?: (name: string) => ReactNode;
}
const identity = <T,>(x: T) => x;
const Section = /* @__PURE__ */ memo(
  ({ title, changes, renderName = identity }: SectionProps) => {
    const [expandedFns, setExpandedFns] = useState(new Set<string>());
    const [expandedEntries, setExpandedEntries] = useState(new Set<string>());

    const entries = Array.from(changes.entries());

    if (changes.size === 0) {
      return null;
    }
    return (
      <div>
        <div className="text-xs text-[#888] mb-1.5">{title}</div>
        <div className="flex flex-col gap-2">
          {entries.map(([entryKey, change]) => {
            const isEntryExpanded = expandedEntries.has(String(entryKey));
            const { value: prevValue, error: prevError } = safeGetValue(
              change.previousValue,
            );
            const { value: currValue, error: currError } = safeGetValue(
              change.currentValue,
            );

            const diff = getObjectDiff(prevValue, currValue);

            return (
              <div key={entryKey}>
                <button
                  onClick={() => {
                    setExpandedEntries((prev) => {
                      const next = new Set(prev);
                      if (next.has(String(entryKey))) {
                        next.delete(String(entryKey));
                      } else {
                        next.add(String(entryKey));
                      }
                      return next;
                    });
                  }}
                  className="flex items-center gap-2 w-full bg-transparent border-none p-0 cursor-pointer text-white text-xs"
                >
                  <div className="flex items-center gap-1.5 flex-1">
                    <Icon
                      name="icon-chevron-right"
                      size={12}
                      className={cn(
                        'text-[#666] transition-transform duration-200 ease-[cubic-bezier(0.25,0.1,0.25,1)]',
                        {
                          'rotate-90': isEntryExpanded,
                        },
                      )}
                    />
                    <div className="whitespace-pre-wrap break-words text-left font-medium flex items-center gap-x-1.5">
                      {renderName(change.name)}

                      <CountBadge
                        count={change.count}
                        isFunction={typeof change.currentValue === 'function'}
                        showWarning={diff.changes.length === 0}
                        forceFlash
                        // showFlame={diff.changes.length === 0}
                        // showFn={typeof change.currentValue === 'function'}
                      />
                    </div>
                  </div>
                </button>
                <div
                  className={cn('react-scan-expandable', {
                    'react-scan-expanded': isEntryExpanded,
                  })}
                >
                  <div className="pl-3 text-xs font-mono border-l-1 border-[#333]">
                    <div className="flex flex-col gap-0.5">
                      {prevError || currError ? (
                        <AccessError
                          currError={currError}
                          prevError={prevError}
                        />
                      ) : diff.changes.length > 0 ? (
                        <DiffChange
                          change={change}
                          diff={diff}
                          expandedFns={expandedFns}
                          renderName={renderName}
                          setExpandedFns={setExpandedFns}
                          title={title}
                        />
                      ) : (
                        <ReferenceOnlyChange
                          currValue={currValue}
                          entryKey={entryKey}
                          expandedFns={expandedFns}
                          prevValue={prevValue}
                          setExpandedFns={setExpandedFns}
                        />
                      )}
                    </div>
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      </div>
    );
  },
);

const AccessError = ({
  prevError,
  currError,
}: {
  prevError?: string;
  currError?: string;
}) => {
  return (
    <>
      {prevError && (
        <div className="text-[#f87171] bg-[#2a1515] pr-1.5 py-[3px] rounded italic">
          {prevError}
        </div>
      )}
      {currError && (
        <div className="text-[#4ade80] bg-[#1a2a1a] pr-1.5 py-[3px] rounded italic mt-0.5">
          {currError}
        </div>
      )}
    </>
  );
};

const DiffChange = ({
  diff,
  title,
  renderName,
  change,
  expandedFns,
  setExpandedFns,
}: {
  diff: {
    changes: {
      path: string[];
      prevValue: unknown;
      currentValue: unknown;
    }[];
  };
  title: string;
  renderName: (name: string) => ReactNode;
  change: { name: string };
  expandedFns: Set<string>;
  setExpandedFns: (updater: (prev: Set<string>) => Set<string>) => void;
}) => {
  return diff.changes.map((diffChange, i) => {
    const { value: prevDiffValue, error: prevDiffError } = safeGetValue(
      diffChange.prevValue,
    );
    const { value: currDiffValue, error: currDiffError } = safeGetValue(
      diffChange.currentValue,
    );

    const isFunction =
      typeof prevDiffValue === 'function' ||
      typeof currDiffValue === 'function';

    let path: string | undefined;

    if (title === 'Props') {
      path =
        diffChange.path.length > 0
          ? `${renderName(String(change.name))}.${formatPath(diffChange.path)}`
          : undefined;
    }
    if (title === 'State' && diffChange.path.length > 0) {
      path = `state.${formatPath(diffChange.path)}`;
    }

    if (!path) {
      path = formatPath(diffChange.path);
    }

    return (
      <div
        key={`${path}-${change.name}-${i}`}
        className={cn(
          'flex flex-col gap-y-1',
          i < diff.changes.length - 1 && 'mb-4',
        )}
      >
        {path && <div className="text-[#666] text-[10px]">{path}</div>}
        <button
          type="button"
          className={cn(
            'group',
            'flex items-start',
            'py-[3px] px-1.5',
            'text-left text-[#f87171] bg-[#2a1515]',
            'rounded',
            'overflow-hidden break-all',
            isFunction && 'cursor-pointer',
          )}
          onClick={
            isFunction
              ? () => {
                  const fnKey = `${formatPath(diffChange.path)}-prev`;
                  setExpandedFns((prev) => {
                    const next = new Set(prev);
                    if (next.has(fnKey)) {
                      next.delete(fnKey);
                    } else {
                      next.add(fnKey);
                    }
                    return next;
                  });
                }
              : undefined
          }
        >
          <span className="w-3 flex items-center justify-center opacity-50">
            -
          </span>
          <span className="flex-1 whitespace-nowrap font-mono">
            {prevDiffError ? (
              <span className="italic text-[#f87171]">{prevDiffError}</span>
            ) : isFunction ? (
              <div className="flex gap-1 items-start flex-col">
                <div className="flex gap-1 items-start w-full">
                  <span className="flex-1 max-h-40">
                    {formatFunctionPreview(
                      prevDiffValue as (...args: unknown[]) => unknown,
                      expandedFns.has(`${formatPath(diffChange.path)}-prev`),
                    )}
                  </span>
                  {typeof prevDiffValue === 'function' && (
                    <CopyToClipboard
                      text={prevDiffValue.toString()}
                      className="opacity-0 transition-opacity group-hover:opacity-100"
                    >
                      {({ ClipboardIcon }) => <>{ClipboardIcon}</>}
                    </CopyToClipboard>
                  )}
                </div>
                {prevDiffValue?.toString() === currDiffValue?.toString() && (
                  <div className="text-[10px] text-[#666] italic">
                    Function reference changed
                  </div>
                )}
              </div>
            ) : (
              <DiffValueView
                value={prevDiffValue}
                expanded={expandedFns.has(
                  `${formatPath(diffChange.path)}-prev`,
                )}
                onToggle={() => {
                  const key = `${formatPath(diffChange.path)}-prev`;
                  setExpandedFns((prev) => {
                    const next = new Set(prev);
                    if (next.has(key)) {
                      next.delete(key);
                    } else {
                      next.add(key);
                    }
                    return next;
                  });
                }}
                isNegative={true}
              />
            )}
          </span>
        </button>
        <button
          type="button"
          className={cn(
            'group',
            'flex items-start',
            'py-[3px] px-1.5',
            'text-left text-[#4ade80] bg-[#1a2a1a]',
            'rounded',
            'overflow-hidden break-all',
            isFunction && 'cursor-pointer',
          )}
          onClick={
            isFunction
              ? () => {
                  const fnKey = `${formatPath(diffChange.path)}-current`;
                  setExpandedFns((prev) => {
                    const next = new Set(prev);
                    if (next.has(fnKey)) {
                      next.delete(fnKey);
                    } else {
                      next.add(fnKey);
                    }
                    return next;
                  });
                }
              : undefined
          }
        >
          <span className="w-3 flex items-center justify-center opacity-50">
            +
          </span>
          <span className="flex-1 whitespace-pre-wrap font-mono">
            {currDiffError ? (
              <span className="italic text-[#4ade80]">{currDiffError}</span>
            ) : isFunction ? (
              <div className="flex gap-1 items-start flex-col">
                <div className="flex gap-1 items-start w-full">
                  <span className="flex-1">
                    {formatFunctionPreview(
                      currDiffValue as (...args: unknown[]) => unknown,
                      expandedFns.has(`${formatPath(diffChange.path)}-current`),
                    )}
                  </span>
                  {typeof currDiffValue === 'function' && (
                    <CopyToClipboard
                      text={currDiffValue.toString()}
                      className="opacity-0 transition-opacity group-hover:opacity-100"
                    >
                      {({ ClipboardIcon }) => <>{ClipboardIcon}</>}
                    </CopyToClipboard>
                  )}
                </div>
                {prevDiffValue?.toString() === currDiffValue?.toString() && (
                  <div className="text-[10px] text-[#666] italic">
                    Function reference changed
                  </div>
                )}
              </div>
            ) : (
              <DiffValueView
                value={currDiffValue}
                expanded={expandedFns.has(
                  `${formatPath(diffChange.path)}-current`,
                )}
                onToggle={() => {
                  const key = `${formatPath(diffChange.path)}-current`;
                  setExpandedFns((prev) => {
                    const next = new Set(prev);
                    if (next.has(key)) {
                      next.delete(key);
                    } else {
                      next.add(key);
                    }
                    return next;
                  });
                }}
                isNegative={false}
              />
            )}
          </span>
        </button>
      </div>
    );
  });
};

const ReferenceOnlyChange = ({
  prevValue,
  currValue,
  entryKey,
  expandedFns,
  setExpandedFns,
}: {
  prevValue: unknown;
  currValue: unknown;
  entryKey: string | number;
  expandedFns: Set<string>;
  setExpandedFns: (updater: (prev: Set<string>) => Set<string>) => void;
}) => {
  return (
    <>
      <div className="group flex gap-0.5 items-start text-[#f87171] bg-[#2a1515] py-[3px] px-1.5 rounded">
        <span className="w-3 flex items-center justify-center opacity-50">
          -
        </span>
        <span className="flex-1 overflow-hidden whitespace-pre-wrap font-mono">
          <DiffValueView
            value={prevValue}
            expanded={expandedFns.has(`${String(entryKey)}-prev`)}
            onToggle={() => {
              const key = `${String(entryKey)}-prev`;
              setExpandedFns((prev) => {
                const next = new Set(prev);
                if (next.has(key)) {
                  next.delete(key);
                } else {
                  next.add(key);
                }
                return next;
              });
            }}
            isNegative={true}
          />
        </span>
      </div>
      <div className="group flex gap-0.5 items-start text-[#4ade80] bg-[#1a2a1a] py-[3px] px-1.5 rounded mt-0.5">
        <span className="w-3 flex items-center justify-center opacity-50">
          +
        </span>
        <span className="flex-1 overflow-hidden whitespace-pre-wrap font-mono">
          <DiffValueView
            value={currValue}
            expanded={expandedFns.has(`${String(entryKey)}-current`)}
            onToggle={() => {
              const key = `${String(entryKey)}-current`;
              setExpandedFns((prev) => {
                const next = new Set(prev);
                if (next.has(key)) {
                  next.delete(key);
                } else {
                  next.add(key);
                }
                return next;
              });
            }}
            isNegative={false}
          />
        </span>
      </div>
      {typeof currValue === 'object' && currValue !== null && (
        <div className="text-[#666] text-[10px] italic mt-1 flex items-center gap-x-1">
          <Icon
            name="icon-triangle-alert"
            className="text-yellow-500 mb-px"
            size={14}
          />
          <span>Reference changed but objects are structurally the same</span>
        </div>
      )}
    </>
  );
};

const CountBadge = ({
  count,
  forceFlash,
  isFunction,
  showWarning,
}: {
  count: number;
  forceFlash: boolean;
  isFunction: boolean;
  showWarning: boolean;
}) => {
  const refIsFirstRender = useRef(true);
  const refBadge = useRef<HTMLDivElement>(null);
  const refPrevCount = useRef(count);

  useEffect(() => {
    const element = refBadge.current;
    if (!element || refPrevCount.current === count) {
      return;
    }

    element.classList.remove('count-flash');
    void element.offsetWidth;
    element.classList.add('count-flash');

    refPrevCount.current = count;
  }, [count]);

  useEffect(() => {
    if (refIsFirstRender.current) {
      refIsFirstRender.current = false;
      return;
    }

    if (forceFlash) {
      let timer = setTimeout(() => {
        refBadge.current?.classList.add('count-flash-white');
        timer = setTimeout(() => {
          refBadge.current?.classList.remove('count-flash-white');
        }, 300);
      }, 500);
      return () => {
        clearTimeout(timer);
      };
    }
  }, [forceFlash]);

  return (
    <div ref={refBadge} className="count-badge">
      {showWarning && (
        <Icon
          name="icon-triangle-alert"
          className="text-yellow-500 mb-px"
          size={14}
        />
      )}
      {isFunction && (
        <Icon name="icon-function" className="text-[#A855F7] mb-px" size={14} />
      )}
      x{count}
    </div>
  );
};
</file>

<file path="src/web/views/notifications/collapsed-event.tsx">
import { useEffect, useRef, useState } from 'preact/hooks';
import {
  DroppedFramesEvent,
  getComponentName,
  getEventSeverity,
  InteractionEvent,
} from './data';
import { SlowdownHistoryItem } from './slowdown-history';
import { ChevronRight } from './icons';
import { cn } from '~web/utils/helpers';

export type CollapsedDroppedFrame = {
  kind: 'collapsed-frame-drops';
  events: Array<DroppedFramesEvent>;
  timestamp: number;
};

type CollapsedKeyboardInput = {
  kind: 'collapsed-keyboard';
  events: Array<InteractionEvent>;
  timestamp: number;
};
const useNestedFlash = ({
  flashingItemsCount,
  totalEvents,
}: {
  totalEvents: number; // this breaks if you have constant 1 item flashing, but the actual item is different over time (it's fine for now)
  flashingItemsCount: number;
}) => {
  const [newFlash, setNewFlash] = useState(false);
  const flashedFor = useRef(0);
  const lastFlashTime = useRef<number>(0);

  // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>
  useEffect(() => {
    if (flashedFor.current >= totalEvents) {
      return;
    }

    const now = Date.now();
    const debounceTime = 250;
    const timeSinceLastFlash = now - lastFlashTime.current;

    if (timeSinceLastFlash >= debounceTime) {
      setNewFlash(false);
      const timeout = setTimeout(() => {
        flashedFor.current = totalEvents;
        lastFlashTime.current = Date.now();
        setNewFlash(true);
        // horrible, don't look at this, move along
        setTimeout(() => {
          setNewFlash(false);
        }, 2000);
      }, 50);
      return () => clearTimeout(timeout);
    } else {
      const delayNeeded = debounceTime - timeSinceLastFlash;
      const timeout = setTimeout(() => {
        setNewFlash(false);
        setTimeout(() => {
          flashedFor.current = totalEvents;
          lastFlashTime.current = Date.now();
          setNewFlash(true);
          // horrible, don't look at this, move along
          setTimeout(() => {
            setNewFlash(false);
          }, 2000);
        }, 50);
      }, delayNeeded);
      return () => clearTimeout(timeout);
    }
  }, [flashingItemsCount]);

  return newFlash;
};

export const CollapsedItem = ({
  item,
  shouldFlash,
}: {
  item: CollapsedDroppedFrame | CollapsedKeyboardInput;
  shouldFlash: (id: string) => boolean;
}) => {
  const [expanded, setExpanded] = useState(false);

  const severity = item.events.map(getEventSeverity).reduce((prev, curr) => {
    switch (curr) {
      case 'high': {
        return 'high';
      }
      case 'needs-improvement': {
        return prev === 'high' ? 'high' : 'needs-improvement';
      }
      case 'low': {
        return prev;
      }
    }
  }, 'low');
  const flashingItemsCount = item.events.reduce(
    (prev, curr) => (shouldFlash(curr.id) ? prev + 1 : prev),
    0,
  );

  const shouldFlashAgain = useNestedFlash({
    flashingItemsCount,
    totalEvents: item.events.length,
  });

  return (
    <div className={cn(['flex flex-col gap-y-0.5'])}>
      <button
        onClick={() => setExpanded((expanded) => !expanded)}
        className={cn([
          'pl-2 py-1.5  text-sm flex items-center rounded-sm hover:bg-[#18181B] relative overflow-hidden',
          shouldFlashAgain &&
            !expanded &&
            'after:absolute after:inset-0 after:bg-purple-500/30 after:animate-[fadeOut_1s_ease-out_forwards]',
        ])}
      >
        <div
          className={cn([
            'w-4/5 flex items-center justify-start h-full text-xs truncate gap-x-1.5',
          ])}
        >
          <span className={cn(['min-w-fit'])}>
            <ChevronRight
              key={`chevron-${item.timestamp}`}
              className={cn([
                'text-[#A1A1AA] transition-transform',
                expanded ? 'rotate-90' : '',
              ])}
              size={14}
            />
          </span>

          <span className={cn(['text-xs'])}>
            {item.kind === 'collapsed-frame-drops'
              ? 'FPS Drops'
              : getComponentName(item.events.at(0)?.componentPath ?? [])}
          </span>
        </div>
        <div
          className={cn(['ml-auto min-w-fit flex justify-end items-center'])}
        >
          <div
            style={{
              lineHeight: '10px',
            }}
            className={cn([
              'w-fit flex items-center text-[10px] justify-center h-full text-white px-1 py-1 rounded-sm font-semibold',
              severity === 'low' && 'bg-green-500/60',
              severity === 'needs-improvement' && 'bg-[#b77116] text-[10px]',
              severity === 'high' && 'bg-[#b94040]',
            ])}
          >
            x{item.events.length}
          </div>
        </div>
      </button>
      {expanded && (
        <IndentedContent>
          {item.events
            .toSorted((a, b) => b.timestamp - a.timestamp)
            .map((event) => (
              <SlowdownHistoryItem
                event={event}
                shouldFlash={shouldFlash(event.id)}
              />
            ))}
        </IndentedContent>
      )}
    </div>
  );
};

const IndentedContent = ({
  children,
}: { children: JSX.Element | JSX.Element[] }) => (
  <div className="relative pl-6 flex flex-col gap-y-1">
    <div className="absolute left-3 top-0 bottom-0 w-px bg-[#27272A]" />
    {children}
  </div>
);
</file>

<file path="src/web/views/notifications/data.ts">
import { createContext } from 'preact';
import { SetStateAction } from 'preact/compat';
import { Dispatch, useContext } from 'preact/hooks';
import { HIGH_SEVERITY_FPS_DROP_TIME } from '~core/notifications/event-tracking';

export type GroupedFiberRender = {
  id: string;
  name: string;
  count: number;
  changes: {
    props: Array<{ name: string; count: number }>;
    state: Array<{ index: number; count: number }>;
    context: Array<{ name: string; count: number }>;
  };
  // fixme: incorrect assumption, make this nullable
  /** Not available when running in production, but we will not render notifications in production */
  totalTime: number;
  elements: Array<Element>; // can't do a weak set because need to iterate over them......
  deletedAll: boolean;
  parents: Set<string>;
};
export const getComponentName = (path: Array<string>) => {
  const filteredPath = path.filter((item) => item.length > 2);
  // in production, all names can be minified
  if (filteredPath.length === 0) {
    return path.at(-1) ?? 'Unknown';
  }
  // biome-ignore lint/style/noNonNullAssertion: invariant
  return filteredPath.at(-1)!;
};

export const getTotalTime = (
  timing: InteractionTiming | DroppedFramesTiming,
) => {
  switch (timing.kind) {
    case 'interaction': {
      const {
        renderTime,
        otherJSTime,
        framePreparation,
        frameConstruction,
        frameDraw,
      } = timing;
      return (
        renderTime +
        otherJSTime +
        framePreparation +
        frameConstruction +
        (frameDraw ?? 0)
      );
    }
    case 'dropped-frames': {
      return timing.otherTime + timing.renderTime;
    }
  }
};

export type DroppedFramesTiming = {
  kind: 'dropped-frames';
  renderTime: number;
  otherTime: number;
};
export type InteractionTiming = {
  kind: 'interaction';
  renderTime: number;
  otherJSTime: number;
  /** After JS, before paint. Things like layerize, css style recalcs */
  framePreparation: number;
  /** paint/commit. This is where the browser constructs the data structure that represents what will be drawn to screen */
  frameConstruction: number;
  /** GPU/compositing/rasterization. This is where, off the main thread, the data structure built is used to draw the next frame. This value is not available on safari due to lack of PerformanceEntry API */
  frameDraw: number | null;
};

export const isRenderMemoizable = (gropedFiberRender: GroupedFiberRender) => {
  return (
    gropedFiberRender.changes.context.length === 0 &&
    gropedFiberRender.changes.props.length === 0 &&
    gropedFiberRender.changes.state.length === 0
  );
};

export const getTimeSplit = (
  timing: DroppedFramesTiming | InteractionTiming,
) => {
  switch (timing.kind) {
    case 'dropped-frames': {
      return {
        render: timing.renderTime,
        other: timing.otherTime,
      };
    }
    case 'interaction': {
      return {
        render: timing.renderTime,
        other: getTotalTime(timing) + timing.renderTime,
      };
    }
  }
};

export type InteractionEvent = {
  kind: 'interaction';
  type: 'click' | 'keyboard';
  id: string;
  componentPath: Array<string>;
  groupedFiberRenders: Array<GroupedFiberRender>;
  timing: InteractionTiming;
  /** Not available in safari, and API used to get value is not stable on chrome */
  memory: number | null;
  timestamp: number;
};
export type DroppedFramesEvent = {
  kind: 'dropped-frames';
  id: string;
  groupedFiberRenders: Array<GroupedFiberRender>;
  timing: DroppedFramesTiming;
  /** Not available in safari, and API used to get value is not stable on chrome */
  memory: number | null;
  timestamp: number;
  fps: number;
};
export type NotificationEvent = InteractionEvent | DroppedFramesEvent;

export type NotificationsState = {
  events: Array<NotificationEvent>;
  // todo: discriminated union this all, i don't want to do it yet till i stabilize the data i need/ implement it all
  selectedEvent: NotificationEvent | null;
  filterBy: 'severity' | 'latest';
  selectedFiber: NotificationEvent['groupedFiberRenders'][number] | null;
  detailsExpanded: boolean;
  moreInfoExpanded: boolean;
  route:
    | 'render-visualization'
    | 'other-visualization'
    // | "render-guide"
    | 'render-explanation'
    // | "other-guide"
    | 'optimize';
  /**
   * Conceptually a synthetic query parameter
   */
  routeMessage: null | {
    kind: 'auto-open-overview-accordion';
    name:
      | 'other-not-javascript'
      | 'other-javascript'
      | 'render'
      | 'other-frame-drop';
  };
  audioNotificationsOptions:
    | {
        audioContext: null;
        enabled: false;
      }
    | {
        enabled: true;
        audioContext: AudioContext;
      };
};

export const getEventSeverity = (event: NotificationEvent) => {
  const totalTime = getTotalTime(event.timing);
  switch (event.kind) {
    case 'interaction': {
      if (totalTime < 200) return 'low';
      if (totalTime < 500) return 'needs-improvement';
      return 'high';
    }
    case 'dropped-frames': {
      if (totalTime < 50) return 'low';
      if (totalTime < HIGH_SEVERITY_FPS_DROP_TIME) return 'needs-improvement';
      return 'high';
    }
  }
};

export const getReadableSeverity = (
  severity: 'low' | 'needs-improvement' | 'high',
) => {
  switch (severity) {
    case 'high': {
      return 'Poor';
    }
    case 'needs-improvement': {
      return 'Laggy';
    }
    case 'low': {
      return 'Good';
    }
  }
};
export const NOTIFICATIONS_BORDER = '#27272A';
export const useNotificationsContext = () =>
  useContext(NotificationStateContext);

export const NotificationStateContext = createContext<{
  notificationState: NotificationsState;
  setNotificationState: Dispatch<SetStateAction<NotificationsState>>;
  setRoute: ({
    route,
    routeMessage,
  }: {
    route: NotificationsState['route'];
    routeMessage: NotificationsState['routeMessage'] | null;
  }) => void;
  // biome-ignore lint/style/noNonNullAssertion: we do not use default context values
}>(null!);
</file>

<file path="src/web/views/notifications/details-routes.tsx">
import { ReactNode, useEffect, useRef, useState } from 'preact/compat';
import { playNotificationSound } from '~core/utils';
import { cn } from '~web/utils/helpers';
import { useNotificationsContext } from './data';
import { CloseIcon } from './icons';
import { NotificationTabs } from './notification-tabs';
import { Optimize } from './optimize';
import { OtherVisualization } from './other-visualization';
import { RenderBarChart } from './render-bar-chart';
import { RenderExplanation } from './render-explanation';
import { signalWidgetViews } from '~web/state';

export const DetailsRoutes = () => {
  const { notificationState, setNotificationState } = useNotificationsContext();
  const [dots, setDots] = useState('...');
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const interval = setInterval(() => {
      setDots((prev) => {
        if (prev === '...') return '';
        return prev + '.';
      });
    }, 500);

    return () => clearInterval(interval);
  }, []);

  if (!notificationState.selectedEvent) {
    return (
      <div
        ref={containerRef}
        className={cn([
          'h-full w-full flex flex-col items-center justify-center relative py-2 px-4',
        ])}
      >
        <div
          className={cn([
            'p-2 flex justify-center items-center border-[#27272A] absolute top-0 right-0',
          ])}
        >
          <button
            onClick={() => {
              signalWidgetViews.value = {
                view: 'none',
              };
            }}
          >
            <CloseIcon size={18} className="text-[#6F6F78]" />
          </button>
        </div>
        <div
          className={cn([
            'flex flex-col items-start pt-5 bg-[#0A0A0A] p-5 rounded-sm max-w-md',
            ' shadow-lg',
          ])}
        >
          <div className={cn(['flex flex-col items-start gap-y-4'])}>
            <div className={cn(['flex items-center'])}>
              <span className={cn(['text-zinc-400 font-medium text-[17px]'])}>
                Scanning for slowdowns
                {dots}
              </span>
            </div>
            {notificationState.events.length !== 0 && (
              <p className={cn(['text-xs'])}>
                Click on an item in the{' '}
                <span className={cn(['text-purple-400'])}>History</span> list to
                get started
              </p>
            )}
            <p className={cn(['text-zinc-600 text-xs'])}>
              You don't need to keep this panel open for React Scan to record
              slowdowns
            </p>
            <p className={cn(['text-zinc-600 text-xs'])}>
              Enable audio alerts to hear a delightful ding every time a large
              slowdown is recorded
            </p>
            <button
              onClick={() => {
                if (notificationState.audioNotificationsOptions.enabled) {
                  setNotificationState((prev) => {
                    if (
                      prev.audioNotificationsOptions.audioContext?.state !==
                      'closed'
                    ) {
                      prev.audioNotificationsOptions.audioContext?.close();
                    }
                    localStorage.setItem('react-scan-notifications-audio', 'false');
                    return {
                      ...prev,
                      audioNotificationsOptions: {
                        audioContext: null,
                        enabled: false,
                      },
                    };
                  });
                  return;
                }
                localStorage.setItem('react-scan-notifications-audio', 'true');
                const audioContext = new AudioContext();
                playNotificationSound(audioContext);
                setNotificationState((prev) => ({
                  ...prev,
                  audioNotificationsOptions: {
                    enabled: true,
                    audioContext,
                  },
                }));
              }}
              className={cn([
                'px-4 py-2 bg-zinc-800 hover:bg-zinc-700 rounded-sm w-full',
                ' text-sm flex items-center gap-x-2 justify-center',
              ])}
            >
              {notificationState.audioNotificationsOptions.enabled ? (
                <>
                  <span className="flex items-center gap-x-1">
                    Disable audio alerts
                  </span>
                </>
              ) : (
                <>
                  <span className="flex items-center gap-x-1">
                    Enable audio alerts
                  </span>
                </>
              )}
            </button>
          </div>
        </div>
      </div>
    );
  }

  switch (notificationState.route) {
    case 'render-visualization': {
      return (
        <TabLayout>
          <RenderBarChart selectedEvent={notificationState.selectedEvent} />
        </TabLayout>
      );
    }
    case 'render-explanation': {
      if (!notificationState.selectedFiber) {
        // todo: dev only
        throw new Error(
          'Invariant: must have selected fiber when viewing render explanation',
        );
      }
      return (
        <TabLayout>
          <RenderExplanation
            selectedFiber={notificationState.selectedFiber}
            selectedEvent={notificationState.selectedEvent}
          />
        </TabLayout>
      );
    }

    case 'other-visualization': {
      return (
        <TabLayout>
          <div
            className={cn(['flex w-full h-full flex-col overflow-y-auto'])}
            id="overview-scroll-container"
          >
            <OtherVisualization
              selectedEvent={notificationState.selectedEvent}
            />
          </div>
        </TabLayout>
      );
    }
    case 'optimize': {
      return (
        <TabLayout>
          <Optimize selectedEvent={notificationState.selectedEvent} />
        </TabLayout>
      );
    }
  }
  // exhaustive verification
  notificationState.route satisfies never;
};

const TabLayout = ({ children }: { children: ReactNode }) => {
  const { notificationState } = useNotificationsContext();
  if (!notificationState.selectedEvent) {
    // todo: dev only
    throw new Error(
      'Invariant: d must have selected event when viewing render explanation',
    );
  }
  return (
    <div className={cn([`w-full h-full flex flex-col gap-y-2`])}>
      <div className={cn(['h-[50px] w-full'])}>
        <NotificationTabs selectedEvent={notificationState.selectedEvent} />
      </div>
      <div
        className={cn(['h-calc(100%-50px) flex flex-col overflow-y-auto px-3'])}
      >
        {children}
      </div>
    </div>
  );
};
</file>

<file path="src/web/views/notifications/icons.tsx">
import { ReactScanInternals } from '~core/index';
import { cn } from '~web/utils/helpers';

export const ChevronRight = ({
  size = 24,
  className,
}: {
  size?: number;
  className?: string;
}) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width={size}
    height={size}
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    stroke-width="2"
    stroke-linecap="round"
    stroke-linejoin="round"
    className={cn(['lucide lucide-chevron-right', className])}
  >
    <path d="m9 18 6-6-6-6" />
  </svg>
);
export const CopyX = ({
  size = 24,
  className,
}: {
  size?: number;
  className?: string;
}) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width={size}
    height={size}
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
    className={cn(['lucide lucide-copy-x', className])}
  >
    <line x1="12" x2="18" y1="12" y2="18" />
    <line x1="12" x2="18" y1="18" y2="12" />
    <rect width="14" height="14" x="8" y="8" rx="2" ry="2" />
    <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2" />
  </svg>
);

export const Notification = ({
  className = '',
  size = 24,
  events = [],
}: {
  className?: string;
  size?: number;
  events: boolean[];
}) => {
  const hasHighSeverity = events.includes(true);
  const totalSevere = events.filter((e) => e).length;
  const displayCount = totalSevere > 99 ? '>99' : totalSevere;
  const badgeSize = hasHighSeverity
    ? Math.max(size * 0.6, 14)
    : Math.max(size * 0.4, 6);


  return (
    <div className="relative">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width={size}
        height={size}
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
        className={`lucide lucide-bell ${className}`}
      >
        <path d="M10.268 21a2 2 0 0 0 3.464 0" />
        <path d="M3.262 15.326A1 1 0 0 0 4 17h16a1 1 0 0 0 .74-1.673C19.41 13.956 18 12.499 18 8A6 6 0 0 0 6 8c0 4.499-1.411 5.956-2.738 7.326" />
      </svg>
      {events.length > 0 &&
        totalSevere > 0 &&
        ReactScanInternals.options.value.showNotificationCount && (
          <div
            className={cn([
              'absolute',
              hasHighSeverity ? '-top-2.5 -right-2.5' : '-top-1 -right-1',
              'rounded-full',
              'flex items-center justify-center',
              'text-[8px] font-medium text-white',
              'aspect-square',
              hasHighSeverity ? 'bg-red-500/90' : 'bg-purple-500/90',
            ])}
            style={{
              width: `${badgeSize}px`,
              height: `${badgeSize}px`,
              padding: hasHighSeverity ? '0.5px' : '0',
            }}
          >
            {hasHighSeverity && displayCount}
          </div>
        )}
    </div>
  );
};

export const CloseIcon = ({
  className = '',
  size = 24,
}: { className?: string; size?: number }) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width={size}
    height={size}
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    stroke-width="2"
    stroke-linecap="round"
    stroke-linejoin="round"
    className={className}
  >
    <path d="M18 6 6 18" />
    <path d="m6 6 12 12" />
  </svg>
);
export const VolumeOnIcon = ({
  className = '',
  size = 24,
}: { className?: string; size?: number }) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width={size}
    height={size}
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    stroke-width="2"
    stroke-linecap="round"
    stroke-linejoin="round"
    className={className}
  >
    <path d="M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z" />
    <path d="M16 9a5 5 0 0 1 0 6" />
    <path d="M19.364 18.364a9 9 0 0 0 0-12.728" />
  </svg>
);

export const VolumeOffIcon = ({
  className = '',
  size = 24,
}: { className?: string; size?: number }) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width={size}
    height={size}
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    stroke-width="2"
    stroke-linecap="round"
    stroke-linejoin="round"
    className={className}
  >
    <path d="M16 9a5 5 0 0 1 .95 2.293" />
    <path d="M19.364 5.636a9 9 0 0 1 1.889 9.96" />
    <path d="m2 2 20 20" />
    <path d="m7 7-.587.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298V11" />
    <path d="M9.828 4.172A.686.686 0 0 1 11 4.657v.686" />
  </svg>
);

export const ArrowLeft = ({
  size = 24,
  className,
}: {
  size?: number;
  className?: string;
}) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width={size}
    height={size}
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    stroke-width="2"
    stroke-linecap="round"
    stroke-linejoin="round"
    className={cn(['lucide lucide-arrow-left', className])}
  >
    <path d="m12 19-7-7 7-7" />
    <path d="M19 12H5" />
  </svg>
);

export const PointerIcon = ({
  className = '',
  size = 24,
}: { className?: string; size?: number }) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width={size}
    height={size}
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    stroke-width="2"
    stroke-linecap="round"
    stroke-linejoin="round"
    className={className}
  >
    <path d="M14 4.1 12 6" />
    <path d="m5.1 8-2.9-.8" />
    <path d="m6 12-1.9 2" />
    <path d="M7.2 2.2 8 5.1" />
    <path d="M9.037 9.69a.498.498 0 0 1 .653-.653l11 4.5a.5.5 0 0 1-.074.949l-4.349 1.041a1 1 0 0 0-.74.739l-1.04 4.35a.5.5 0 0 1-.95.074z" />
  </svg>
);

export const KeyboardIcon = ({
  className = '',
  size = 24,
}: { className?: string; size?: number }) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width={size}
    height={size}
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    stroke-width="2"
    stroke-linecap="round"
    stroke-linejoin="round"
    className={className}
  >
    <path d="M10 8h.01" />
    <path d="M12 12h.01" />
    <path d="M14 8h.01" />
    <path d="M16 12h.01" />
    <path d="M18 8h.01" />
    <path d="M6 8h.01" />
    <path d="M7 16h10" />
    <path d="M8 12h.01" />
    <rect width="20" height="16" x="2" y="4" rx="2" />
  </svg>
);
export const ClearIcon = ({
  className = '',
  size = 24,
}: { className?: string; size?: number }) => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width={size}
      height={size}
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
      className={className}
      style={{ transform: 'rotate(180deg)' }}
    >
      <circle cx="12" cy="12" r="10" />
      <path d="m4.9 4.9 14.2 14.2" />
    </svg>
  );
};
export const TrendingDownIcon = ({
  className = '',
  size = 24,
}: { className?: string; size?: number }) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width={size}
    height={size}
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
    className={className}
  >
    <polyline points="22 17 13.5 8.5 8.5 13.5 2 7" />
    <polyline points="16 17 22 17 22 11" />
  </svg>
);
</file>

<file path="src/web/views/notifications/notification-header.tsx">
// import { signalNotificationsOpen, signalSettingsOpen } from '~web/state';
import { cn } from '~web/utils/helpers';
import {
  NotificationEvent,
  getComponentName,
  getEventSeverity,
  getTotalTime,
} from './data';
import { CloseIcon } from './icons';
import { signalWidgetViews } from '~web/state';

export const NotificationHeader = ({
  selectedEvent,
}: {
  selectedEvent: NotificationEvent;
}) => {
  const severity = getEventSeverity(selectedEvent);
  switch (selectedEvent.kind) {
    case 'interaction': {
      return (
        // h-[48px] is a hack to adjust for header size
        <div
          className={cn([`w-full flex border-b border-[#27272A] min-h-[48px]`])}
        >
          {/* todo: make css variables for colors */}
          <div
            className={cn([
              'min-w-fit w-full justify-start flex items-center border-r border-[#27272A] pl-5 pr-2 text-sm gap-x-4',
            ])}
          >
            <div className={cn(['flex items-center gap-x-2 '])}>
              <span className={cn(['text-[#5a5a5a] mr-0.5'])}>
                {selectedEvent.type === 'click' ? 'Clicked ' : 'Typed in '}
              </span>
              <span>{getComponentName(selectedEvent.componentPath)}</span>
              <div
                className={cn([
                  'w-fit flex items-center justify-center h-fit text-white px-1 rounded-sm font-semibold text-[10px] whitespace-nowrap',
                  severity === 'low' && 'bg-green-500/50',
                  severity === 'needs-improvement' && 'bg-[#b77116]',
                  severity === 'high' && 'bg-[#b94040]',
                ])}
              >
                {getTotalTime(selectedEvent.timing).toFixed(0)}ms processing
                time
              </div>
            </div>
            <div
              className={cn(['flex items-center gap-x-2  justify-end ml-auto'])}
            >
              <div
                className={cn([
                  'p-2 flex justify-center items-center border-[#27272A]',
                ])}
              >
                <button
                  onClick={() => {
                    signalWidgetViews.value = {
                      view: 'none',
                    };
                  }}
                >
                  <CloseIcon size={18} className="text-[#6F6F78]" />
                </button>
              </div>
            </div>
          </div>
        </div>
      );
    }
    case 'dropped-frames': {
      return (
        <div
          className={cn([`w-full flex border-b border-[#27272A] min-h-[48px]`])}
        >
          <div
            className={cn([
              'min-w-fit w-full justify-start flex items-center border-r border-[#27272A] pl-5 pr-2 text-sm gap-x-4',
            ])}
          >
            <div className={cn(['flex items-center gap-x-2 '])}>
              FPS Drop
              <div
                className={cn([
                  'w-fit flex items-center justify-center h-fit text-white px-1 rounded-sm font-semibold text-[10px] whitespace-nowrap',
                  severity === 'low' && 'bg-green-500/50',
                  severity === 'needs-improvement' && 'bg-[#b77116]',
                  severity === 'high' && 'bg-[#b94040]',
                ])}
              >
                dropped to {selectedEvent.fps} FPS
              </div>
            </div>

            <div
              className={cn([
                'flex items-center gap-x-2 w-2/4 justify-end ml-auto',
              ])}
            >
              <div
                className={cn([
                  'p-2 flex justify-center items-center border-[#27272A]',
                ])}
              >
                <button
                  onClick={() => {
                    signalWidgetViews.value = {
                      view: 'none',
                    };
                  }}
                >
                  <CloseIcon size={18} className="text-[#6F6F78]" />
                </button>
              </div>
            </div>
          </div>
        </div>
      );
    }
  }
};
</file>

<file path="src/web/views/notifications/notification-tabs.tsx">
import { cn } from '~web/utils/helpers';
import { NotificationEvent, useNotificationsContext } from './data';
import { Popover } from './popover';
import { VolumeOffIcon, VolumeOnIcon } from './icons';
import { playNotificationSound } from '~core/utils';

export const NotificationTabs = ({
  selectedEvent: _,
}: {
  selectedEvent: NotificationEvent;
}) => {
  const { notificationState, setNotificationState, setRoute } =
    useNotificationsContext();
  return (
    <div
      className={cn([
        'flex w-full justify-between items-center px-3 py-2 text-xs',
      ])}
    >
      <div
        className={cn([
          'bg-[#18181B] flex items-center gap-x-1 p-1 rounded-sm',
        ])}
      >
        <button
          onClick={() => {
            setRoute({
              route: 'render-visualization',
              routeMessage: null,
            });
          }}
          className={cn([
            'w-1/2 flex items-center justify-center whitespace-nowrap py-[5px] px-1 gap-x-1',
            notificationState.route === 'render-visualization' ||
            notificationState.route === 'render-explanation'
              ? 'text-white bg-[#7521c8] rounded-sm'
              : 'text-[#6E6E77] bg-[#18181B] rounded-sm',
          ])}
        >
          Ranked
        </button>
        <button
          onClick={() => {
            setRoute({
              route: 'other-visualization',
              routeMessage: null,
            });
          }}
          className={cn([
            'w-1/2 flex items-center justify-center whitespace-nowrap py-[5px] px-1 gap-x-1',
            notificationState.route === 'other-visualization'
              ? 'text-white bg-[#7521c8] rounded-sm'
              : 'text-[#6E6E77] bg-[#18181B] rounded-sm',
          ])}
        >
          Overview
        </button>
        <button
          onClick={() => {
            setRoute({
              route: 'optimize',
              routeMessage: null,
            });
          }}
          className={cn([
            'w-1/2 flex items-center justify-center whitespace-nowrap py-[5px] px-1 gap-x-1',
            notificationState.route === 'optimize'
              ? 'text-white bg-[#7521c8] rounded-sm'
              : 'text-[#6E6E77] bg-[#18181B] rounded-sm',
          ])}
        >
          <span>Prompts</span>
        </button>
      </div>
      <Popover
        triggerContent={
          <button
            onClick={() => {
              setNotificationState((prev) => {
                if (
                  prev.audioNotificationsOptions.enabled &&
                  prev.audioNotificationsOptions.audioContext.state !== 'closed'
                ) {
                  prev.audioNotificationsOptions.audioContext.close();
                }
                const prevEnabledState = prev.audioNotificationsOptions.enabled;
                localStorage.setItem(
                  'react-scan-notifications-audio',
                  String(!prevEnabledState),
                );

                const audioContext = new AudioContext();
                if (!prev.audioNotificationsOptions.enabled) {
                  playNotificationSound(audioContext);
                }
                if (prevEnabledState) {
                  audioContext.close();
                }
                return {
                  ...prev,
                  audioNotificationsOptions: prevEnabledState
                    ? {
                        audioContext: null,
                        enabled: false,
                      }
                    : {
                        audioContext,
                        enabled: true,
                      },
                };
              });
            }}
            className="ml-auto"
          >
            <div
              className={cn([
                'flex gap-x-2 justify-center items-center text-[#6E6E77]',
              ])}
            >
              <span>Alerts</span>
              {notificationState.audioNotificationsOptions.enabled ? (
                <VolumeOnIcon size={16} className="text-[#6E6E77]" />
              ) : (
                <VolumeOffIcon size={16} className="text-[#6E6E77]" />
              )}
            </div>
          </button>
        }
      >
        <>Play a chime when a slowdown is recorded</>
      </Popover>
    </div>
  );
};
</file>

<file path="src/web/views/notifications/notifications.tsx">
import { forwardRef } from 'preact/compat';
import { useEffect, useRef, useState } from 'preact/hooks';
import { not_globally_unique_generateId } from '~core/monitor/utils';
import { useToolbarEventLog } from '~core/notifications/event-tracking';
import { FiberRenders } from '~core/notifications/performance';
import { iife, invariantError } from '~core/notifications/performance-utils';
import { playNotificationSound } from '~core/utils';
import { cn } from '~web/utils/helpers';
import {
  NotificationStateContext,
  NotificationsState,
  getEventSeverity,
  getTotalTime,
  useNotificationsContext,
} from './data';
import { DetailsRoutes } from './details-routes';
import { NotificationHeader } from './notification-header';
import { fadeOutHighlights } from './render-bar-chart';
import { SlowdownHistory, useLaggedEvents } from './slowdown-history';

const getGroupedFiberRenders = (fiberRenders: FiberRenders) => {
  const res = Object.values(fiberRenders).map((render) => ({
    id: not_globally_unique_generateId(),
    totalTime: render.nodeInfo.reduce((prev, curr) => prev + curr.selfTime, 0),
    count: render.nodeInfo.length,
    name: render.nodeInfo[0].name, // invariant, at least one exists,
    deletedAll: false,
    parents: render.parents,
    // it would be nice if we calculated the % of components memoizable, but this would have to be calculated downstream before it got aggregated
    elements: render.nodeInfo.map((node) => node.element),
    changes: {
      context: render.changes.fiberContext.current
        .filter((change) =>
          render.changes.fiberContext.changesCounts.get(change.name),
        )
        .map((change) => ({
          name: String(change.name),
          count:
            render.changes.fiberContext.changesCounts.get(change.name) ?? 0,
        })),
      props: render.changes.fiberProps.current
        .filter((change) =>
          render.changes.fiberProps.changesCounts.get(change.name),
        )
        .map((change) => ({
          name: String(change.name),
          count: render.changes.fiberProps.changesCounts.get(change.name) ?? 0,
        })),
      state: render.changes.fiberState.current
        .filter((change) =>
          render.changes.fiberState.changesCounts.get(Number(change.name)),
        )
        .map((change) => ({
          index: change.name as number,
          count:
            render.changes.fiberState.changesCounts.get(Number(change.name)) ??
            0,
        })),
    },
  }));

  return res;
};

const useGarbageCollectElements = (
  notificationEvents: NotificationsState['events'],
) => {
  useEffect(() => {
    const checkElementsExistence = () => {
      notificationEvents.forEach((event) => {
        if (!event.groupedFiberRenders) return;

        event.groupedFiberRenders.forEach((render) => {
          if (render.deletedAll) return;

          if (!render.elements || render.elements.length === 0) {
            render.deletedAll = true;
            return;
          }

          const initialLength = render.elements.length;
          render.elements = render.elements.filter((element) => {
            return element && element.isConnected;
          });

          if (render.elements.length === 0 && initialLength > 0) {
            render.deletedAll = true;
          }
        });
      });
    };

    const intervalId = setInterval(checkElementsExistence, 5000);

    return () => {
      clearInterval(intervalId);
    };
  }, [notificationEvents]);
};

export const useAppNotifications = () => {
  const log = useToolbarEventLog();

  const notificationEvents: NotificationsState['events'] = [];

  useGarbageCollectElements(notificationEvents);

  log.state.events.forEach((event) => {
    const fiberRenders =
      event.kind === 'interaction'
        ? event.data.meta.detailedTiming.fiberRenders
        : event.data.meta.fiberRenders;
    const groupedFiberRenders = getGroupedFiberRenders(fiberRenders);
    const renderTime = groupedFiberRenders.reduce(
      (prev, curr) => prev + curr.totalTime,
      0,
    );
    switch (event.kind) {
      case 'interaction': {
        const { commitEnd, jsEndDetail, interactionStartDetail, rafStart } =
          event.data.meta.detailedTiming;

        // this is a known bug, js time doesn't backfill render time from async renders (or async js in general)
        // the current impl is a close enough approximation so will leave as is until there is a dedicated effort to fix it
        if (jsEndDetail - interactionStartDetail - renderTime < 0) {
          invariantError('js time must be longer than render time');
        }
        const otherJSTime = Math.max(
          0,
          jsEndDetail - interactionStartDetail - renderTime,
        );

        const frameDraw = Math.max(
          event.data.meta.latency - (commitEnd - interactionStartDetail),
          0,
        );
        notificationEvents.push({
          componentPath: event.data.meta.detailedTiming.componentPath,
          groupedFiberRenders,
          id: event.id,
          kind: 'interaction',
          memory: null,
          timestamp: event.data.startAt,
          type:
            event.data.meta.detailedTiming.interactionType === 'keyboard'
              ? 'keyboard'
              : 'click',
          timing: {
            renderTime: renderTime,
            kind: 'interaction',
            otherJSTime,
            framePreparation: rafStart - jsEndDetail,
            frameConstruction: commitEnd - rafStart,
            frameDraw,
          },
        });
        return;
      }
      case 'long-render': {
        notificationEvents.push({
          kind: 'dropped-frames',
          id: event.id,
          memory: null,
          timing: {
            kind: 'dropped-frames',
            renderTime: renderTime,
            otherTime: event.data.meta.latency,
          },
          groupedFiberRenders,
          timestamp: event.data.startAt,
          fps: event.data.meta.fps,
        });
        return;
      }
    }
  });
  return notificationEvents;
};
const timeout = 1000;
export const NotificationAudio = () => {
  const { notificationState, setNotificationState } = useNotificationsContext();
  const playedFor = useRef<number | null>(null);
  const debounceTimeout = useRef<NodeJS.Timeout | null>(null);
  const lastPlayedTime = useRef<number>(0);

  const [laggedEvents] = useLaggedEvents();

  const alertEventsCount = laggedEvents.filter(
    // todo: make this configurable
    (event) => getEventSeverity(event) === 'high',
  ).length;

  // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>
  useEffect(() => {
    // todo: sync with options
    const audioEnabledString = localStorage.getItem(
      'react-scan-notifications-audio',
    );

    if (audioEnabledString !== 'false' && audioEnabledString !== 'true') {
      localStorage.setItem('react-scan-notifications-audio', 'false');
      return;
    }

    const audioEnabled = audioEnabledString === 'false' ? false : true;

    if (audioEnabled) {
      setNotificationState((prev) => {
        if (prev.audioNotificationsOptions.enabled) {
          return prev;
        }
        return {
          ...prev,
          audioNotificationsOptions: {
            enabled: true,
            audioContext: new AudioContext(),
          },
        };
      });
      return;
    }
  }, []);

  // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>
  useEffect(() => {
    const { audioNotificationsOptions } = notificationState;
    if (!audioNotificationsOptions.enabled) {
      return;
    }
    if (alertEventsCount === 0) {
      return;
    }
    if (playedFor.current && playedFor.current >= alertEventsCount) {
      return;
    }

    if (debounceTimeout.current) {
      clearTimeout(debounceTimeout.current);
    }

    const now = Date.now();
    const timeSinceLastPlay = now - lastPlayedTime.current;
    const remainingDebounceTime = Math.max(0, timeout - timeSinceLastPlay);

    debounceTimeout.current = setTimeout(() => {
      playNotificationSound(audioNotificationsOptions.audioContext);
      playedFor.current = alertEventsCount;
      lastPlayedTime.current = Date.now();
      debounceTimeout.current = null;
    }, remainingDebounceTime);
  }, [alertEventsCount]);

  useEffect(() => {
    if (alertEventsCount !== 0) {
      return;
    }
    playedFor.current = null;
  }, [alertEventsCount]);

  useEffect(() => {
    return () => {
      if (debounceTimeout.current) {
        clearTimeout(debounceTimeout.current);
      }
    };
  }, []);

  return null;
};

export const NotificationWrapper = forwardRef<HTMLDivElement>((_, ref) => {
  const events = useAppNotifications();
  const [notificationState, setNotificationState] =
    useState<NotificationsState>({
      detailsExpanded: false,
      events,
      filterBy: 'latest',
      moreInfoExpanded: false,
      route: 'render-visualization',
      selectedEvent:
        events.toSorted((a, b) => a.timestamp - b.timestamp).at(-1) ?? null,
      selectedFiber: null,
      routeMessage: null,
      audioNotificationsOptions: {
        enabled: false,
        audioContext: null,
      },
    });

  notificationState.events = events;
  return (
    <NotificationStateContext.Provider
      value={{
        notificationState,
        setNotificationState,
        setRoute: ({ route, routeMessage }) => {
          setNotificationState((prev) => {
            const newState = { ...prev, route, routeMessage };
            switch (route) {
              case 'render-visualization': {
                fadeOutHighlights();
                return {
                  ...newState,
                  selectedFiber: null,
                };
              }
              case 'optimize': {
                fadeOutHighlights();
                return {
                  ...newState,
                  selectedFiber: null,
                };
              }
              case 'other-visualization': {
                fadeOutHighlights();
                return {
                  ...newState,
                  selectedFiber: null,
                };
              }
              case 'render-explanation': {
                // it would be ideal not to fade this out, but need to spend the time to sync the outline positions as they change in a performant (this was solved in react scan just need to follow same semantics)
                fadeOutHighlights();

                return newState;
              }
            }
            route satisfies never;
          });
        },
      }}
    >
      <NotificationAudio />
      <Notifications ref={ref} />
    </NotificationStateContext.Provider>
  );
});
export const Notifications = forwardRef<HTMLDivElement>((_, ref) => {
  const { notificationState } = useNotificationsContext();

  return (
    <div ref={ref} className={cn(['h-full w-full flex flex-col'])}>
      {notificationState.selectedEvent && (
        <div
          className={cn([
            'w-full h-[48px] flex flex-col',
            notificationState.moreInfoExpanded && 'h-[235px]',
            notificationState.moreInfoExpanded &&
              notificationState.selectedEvent.kind === 'dropped-frames' &&
              'h-[150px]',
          ])}
        >
          <NotificationHeader selectedEvent={notificationState.selectedEvent} />
          {notificationState.moreInfoExpanded && <MoreInfo />}
        </div>
      )}
      <div
        className={cn([
          'flex ',
          notificationState.selectedEvent ? 'h-[calc(100%-48px)]' : 'h-full',
          notificationState.moreInfoExpanded && 'h-[calc(100%-200px)]',
          notificationState.moreInfoExpanded &&
            notificationState.selectedEvent?.kind === 'dropped-frames' &&
            'h-[calc(100%-150px)]',
        ])}
      >
        <div className={cn(['h-full min-w-[200px]'])}>
          <SlowdownHistory />
        </div>
        <div className={cn(['w-[calc(100%-200px)] h-full overflow-y-auto'])}>
          <DetailsRoutes />
        </div>
      </div>
    </div>
  );
});

const MoreInfo = () => {
  const { notificationState } = useNotificationsContext();

  if (!notificationState.selectedEvent) {
    throw new Error('Invariant must have selected event for more info');
  }

  const event = notificationState.selectedEvent;

  return (
    <div
      className={cn([
        'px-4 py-2 border-b border-[#27272A] bg-[#18181B]/50 h-[calc(100%-40px)]',
        event.kind === 'dropped-frames' && `h-[calc(100%-25px)]`,
      ])}
    >
      <div className={cn(['flex flex-col gap-y-4 h-full'])}>
        {iife(() => {
          switch (event.kind) {
            case 'interaction': {
              return (
                <>
                  <div className={cn(['flex items-center gap-x-3'])}>
                    <span className="text-[#6F6F78] text-xs font-medium">
                      {event.type === 'click'
                        ? 'Clicked component location'
                        : 'Typed in component location'}
                    </span>
                    <div className="font-mono text-[#E4E4E7] flex items-center bg-[#27272A] pl-2 py-1 rounded-sm overflow-x-auto">
                      {event.componentPath.toReversed().map((part, i) => (
                        <>
                          <span
                            style={{
                              lineHeight: '14px',
                            }}
                            key={part}
                            className="text-[10px] whitespace-nowrap"
                          >
                            {part}
                          </span>
                          {i < event.componentPath.length - 1 && (
                            <span className="text-[#6F6F78] mx-0.5"></span>
                          )}
                        </>
                      ))}
                    </div>
                  </div>

                  <div className={cn(['flex items-center gap-x-3'])}>
                    <span className="text-[#6F6F78] text-xs font-medium">
                      Total Time
                    </span>
                    <span className="text-[#E4E4E7] bg-[#27272A] px-1.5 py-1 rounded-sm text-xs">
                      {getTotalTime(event.timing).toFixed(0)}ms
                    </span>
                  </div>
                  <div className={cn(['flex items-center gap-x-3'])}>
                    <span className="text-[#6F6F78] text-xs font-medium">
                      Occurred
                    </span>
                    <span className="text-[#E4E4E7] bg-[#27272A] px-1.5 py-1 rounded-sm text-xs">
                      {`${((Date.now() - event.timestamp) / 1000).toFixed(0)}s ago`}
                    </span>
                  </div>
                </>
              );
            }
            case 'dropped-frames': {
              return (
                <>
                  <div className={cn(['flex items-center gap-x-3'])}>
                    <span className="text-[#6F6F78] text-xs font-medium">
                      Total Time
                    </span>
                    <span className="text-[#E4E4E7] bg-[#27272A] px-1.5 py-1 rounded-sm text-xs">
                      {getTotalTime(event.timing).toFixed(0)}ms
                    </span>
                  </div>

                  <div className={cn(['flex items-center gap-x-3'])}>
                    <span className="text-[#6F6F78] text-xs font-medium">
                      Occurred
                    </span>
                    <span className="text-[#E4E4E7] bg-[#27272A] px-1.5 py-1 rounded-sm text-xs">
                      {`${((Date.now() - event.timestamp) / 1000).toFixed(0)}s ago`}
                    </span>
                  </div>
                </>
              );
            }
          }
        })}
      </div>
    </div>
  );
};
</file>

<file path="src/web/views/notifications/optimize.tsx">
import { useState } from 'preact/hooks';
import { cn } from '~web/utils/helpers';
import {
  GroupedFiberRender,
  NotificationEvent,
  getComponentName,
  getTotalTime,
} from './data';
import { iife } from '~core/notifications/performance-utils';

const formatReactData = (groupedFiberRenders: Array<GroupedFiberRender>) => {
  let text = '';

  const filteredFibers = groupedFiberRenders
    .toSorted((a, b) => b.totalTime - a.totalTime)
    .slice(0, 30)
    .filter((fiber) => fiber.totalTime > 5);

  filteredFibers.forEach((fiberRender) => {
    let localText = '';

    localText += 'Component Name:';
    localText += fiberRender.name;
    localText += '\n';

    localText += `Rendered: ${fiberRender.count} times\n`;
    localText += `Sum of self times for ${fiberRender.name} is ${fiberRender.totalTime.toFixed(0)}ms\n`;
    if (fiberRender.changes.props.length > 0) {
      localText += `Changed props for all ${fiberRender.name} instances ("name:count" pairs)\n`;
      fiberRender.changes.props.forEach((change) => {
        localText += `${change.name}:${change.count}x\n`;
      });
    }

    if (fiberRender.changes.state.length > 0) {
      localText += `Changed state for all ${fiberRender.name} instances ("hook index:count" pairs)\n`;
      fiberRender.changes.state.forEach((change) => {
        localText += `${change.index}:${change.count}x\n`;
      });
    }

    if (fiberRender.changes.context.length > 0) {
      localText += `Changed context for all ${fiberRender.name} instances ("context display name (if exists):count" pairs)\n`;
      fiberRender.changes.context.forEach((change) => {
        localText += `${change.name}:${change.count}x\n`;
      });
    }

    text += localText;
    text += '\n';
  });

  return text;
};

export const generateInteractionDataPrompt = ({
  renderTime,
  eHandlerTimeExcludingRenders,
  toRafTime,
  commitTime,
  framePresentTime,
  formattedReactData,
}: {
  renderTime: number;
  eHandlerTimeExcludingRenders: number;
  toRafTime: number;
  commitTime: number;
  framePresentTime: number | null;
  formattedReactData: string;
}) => {
  return `I will provide you with a set of high level, and low level performance data about an interaction in a React App:
### High level
- react component render time: ${renderTime.toFixed(0)}ms
- how long it took to run javascript event handlers (EXCLUDING REACT RENDERS): ${eHandlerTimeExcludingRenders.toFixed(0)}ms
- how long it took from the last event handler time, to the last request animation frame: ${toRafTime.toFixed(0)}ms
	- things like prepaint, style recalculations, layerization, async web API's like observers may occur during this time
- how long it took from the last request animation frame to when the dom was committed: ${commitTime.toFixed(0)}ms
	- during this period you will see paint, commit, potential style recalcs, and other misc browser activity. Frequently high times here imply css that makes the browser do a lot of work, or mutating expensive dom properties during the event handler stage. This can be many things, but it narrows the problem scope significantly when this is high
${framePresentTime && `- how long it took from dom commit for the frame to be presented: ${framePresentTime.toFixed(0)}ms. This is when information about how to paint the next frame is sent to the compositor threads, and when the GPU does work. If this is high, look for issues that may be a bottleneck for operations occurring during this time`}

### Low level
We also have lower level information about react components, such as their render time, and which props/state/context changed when they re-rendered.
${formattedReactData}`;
};

const generateInteractionOptimizationPrompt = ({
  interactionType,
  name,
  componentPath,
  time,
  renderTime,
  eHandlerTimeExcludingRenders,
  toRafTime,
  commitTime,
  framePresentTime,
  formattedReactData,
}: {
  interactionType: string;
  name: string;
  componentPath: string;

  time: number;
  renderTime: number;
  eHandlerTimeExcludingRenders: number;
  toRafTime: number;
  commitTime: number;
  framePresentTime: number | null;
  formattedReactData: string;
}) => `You will attempt to implement a performance improvement to a user interaction in a React app. You will be provided with data about the interaction, and the slow down.

Your should split your goals into 2 parts:
- identifying the problem
- fixing the problem
	- it is okay to implement a fix even if you aren't 100% sure the fix solves the performance problem. When you aren't sure, you should tell the user to try repeating the interaction, and feeding the "Formatted Data" in the React Scan notifications optimize tab. This allows you to start a debugging flow with the user, where you attempt a fix, and observe the result. The user may make a mistake when they pass you the formatted data, so must make sure, given the data passed to you, that the associated data ties to the same interaction you were trying to debug.


Make sure to check if the user has the react compiler enabled (project dependent, configured through build tool), so you don't unnecessarily memoize components. If it is, you do not need to worry about memoizing user components

One challenge you may face is the performance problem lies in a node_module, not in user code. If you are confident the problem originates because of a node_module, there are multiple strategies, which are context dependent:
- you can try to work around the problem, knowing which module is slow
- you can determine if its possible to resolve the problem in the node_module by modifying non node_module code
- you can monkey patch the node_module to experiment and see if it's really the problem (you can modify a functions properties to hijack the call for example)
- you can determine if it's feasible to replace whatever node_module is causing the problem with a performant option (this is an extreme)

The interaction was a ${interactionType} on the component named ${name}. This component has the following ancestors ${componentPath}. This is the path from the component, to the root. This should be enough information to figure out where this component is in the user's code base

This path is the component that was clicked, so it should tell you roughly where component had an event handler that triggered a state change.

Please note that the leaf node of this path might not be user code (if they use a UI library), and they may contain many wrapper components that just pass through children that aren't relevant to the actual click. So make you sure analyze the path and understand what the user code is doing

We have a set of high level, and low level data about the performance issue.

The click took ${time.toFixed(0)}ms from interaction start, to when a new frame was presented to a user.

We also provide you with a breakdown of what the browser spent time on during the period of interaction start to frame presentation.

- react component render time: ${renderTime.toFixed(0)}ms
- how long it took to run javascript event handlers (EXCLUDING REACT RENDERS): ${eHandlerTimeExcludingRenders.toFixed(0)}ms
- how long it took from the last event handler time, to the last request animation frame: ${toRafTime.toFixed(0)}ms
	- things like prepaint, style recalculations, layerization, async web API's like observers may occur during this time
- how long it took from the last request animation frame to when the dom was committed: ${commitTime.toFixed(0)}ms
	- during this period you will see paint, commit, potential style recalcs, and other misc browser activity. Frequently high times here imply css that makes the browser do a lot of work, or mutating expensive dom properties during the event handler stage. This can be many things, but it narrows the problem scope significantly when this is high
${framePresentTime && `- how long it took from dom commit for the frame to be presented: ${framePresentTime.toFixed(0)}ms. This is when information about how to paint the next frame is sent to the compositor threads, and when the GPU does work. If this is high, look for issues that may be a bottleneck for operations occurring during this time`}


We also have lower level information about react components, such as their render time, and which props/state/context changed when they re-rendered.

${formattedReactData}

You may notice components have many renders, but much fewer props/state/context changes. This normally implies most of the components could of been memoized to avoid computation

It's also important to remember if a component had no props/state/context change, and it was memoized, it would not render. So the flow should be:
- find the most expensive components
- see what's causing them to render
- determine how you can make those state/props/context not change for a large set of the renders
- once there are no more changes left, you can memoize the component so it no longer unnecessarily re-renders. 

An important thing to note is that if you see a lot of react renders (some components with very high render counts), but javascript excluding renders is much higher than render time, it is possible that the components with lots of renders run hooks like useEffect/useLayoutEffect, which run during the JS event handler period.

It's also good to note that react profiles hook times in development, and if many hooks are called (lets say 5,000 components all called a useEffect), it will have to profile every single one. And it may also be the case the comparison of the hooks dependency can be expensive, and that would not be tracked in render time.

If a node_module is the component with high renders, you can experiment to see if that component is the root issue (because of hooks). You should use the same instructions for node_module debugging mentioned previously.

`;
const generateFrameDropOptimizationPrompt = ({
  renderTime,
  otherTime,
  formattedReactData,
}: {
  renderTime: number;

  otherTime: number;
  formattedReactData: string;
}) => `You will attempt to implement a performance improvement to a large slowdown in a react app

Your should split your goals into 2 parts:
- identifying the problem
- fixing the problem
	- it is okay to implement a fix even if you aren't 100% sure the fix solves the performance problem. When you aren't sure, you should tell the user to try repeating the interaction, and feeding the "Formatted Data" in the React Scan notifications optimize tab. This allows you to start a debugging flow with the user, where you attempt a fix, and observe the result. The user may make a mistake when they pass you the formatted data, so must make sure, given the data passed to you, that the associated data ties to the same interaction you were trying to debug.

Make sure to check if the user has the react compiler enabled (project dependent, configured through build tool), so you don't unnecessarily memoize components. If it is, you do not need to worry about memoizing user components

One challenge you may face is the performance problem lies in a node_module, not in user code. If you are confident the problem originates because of a node_module, there are multiple strategies, which are context dependent:
- you can try to work around the problem, knowing which module is slow
- you can determine if its possible to resolve the problem in the node_module by modifying non node_module code
- you can monkey patch the node_module to experiment and see if it's really the problem (you can modify a functions properties to hijack the call for example)
- you can determine if it's feasible to replace whatever node_module is causing the problem with a performant option (this is an extreme)


We have the high level time of how much react spent rendering, and what else the browser spent time on during this slowdown

- react component render time: ${renderTime.toFixed(0)}ms
- other time: ${otherTime}ms


We also have lower level information about react components, such as their render time, and which props/state/context changed when they re-rendered.

${formattedReactData}

You may notice components have many renders, but much fewer props/state/context changes. This normally implies most of the components could of been memoized to avoid computation

It's also important to remember if a component had no props/state/context change, and it was memoized, it would not render. So the flow should be:
- find the most expensive components
- see what's causing them to render
- determine how you can make those state/props/context not change for a large set of the renders
- once there are no more changes left, you can memoize the component so it no longer unnecessarily re-renders. 

An important thing to note is that if you see a lot of react renders (some components with very high render counts), but other time is much higher than render time, it is possible that the components with lots of renders run hooks like useEffect/useLayoutEffect, which run outside of what we profile (just react render time).

It's also good to note that react profiles hook times in development, and if many hooks are called (lets say 5,000 components all called a useEffect), it will have to profile every single one. And it may also be the case the comparison of the hooks dependency can be expensive, and that would not be tracked in render time.

If a node_module is the component with high renders, you can experiment to see if that component is the root issue (because of hooks). You should use the same instructions for node_module debugging mentioned previously.

If renders don't seem to be the problem, see if there are any expensive CSS properties being added/mutated, or any expensive DOM Element mutations/new elements being created that could cause this slowdown. 
`;

export const generateFrameDropExplanationPrompt = ({
  renderTime,
  otherTime,
  formattedReactData,
}: {
  renderTime: number;

  otherTime: number;
  formattedReactData: string;
}) => `Your goal will be to help me find the source of a performance problem in a React App. I collected a large dataset about this specific performance problem.

We have the high level time of how much react spent rendering, and what else the browser spent time on during this slowdown

- react component render time: ${renderTime.toFixed(0)}ms
- other time (other JavaScript, hooks like useEffect, style recalculations, layerization, paint & commit and everything else the browser might do to draw a new frame after javascript mutates the DOM): ${otherTime}ms


We also have lower level information about react components, such as their render time, and which props/state/context changed when they re-rendered.

${formattedReactData}

You may notice components have many renders, but much fewer props/state/context changes. This normally implies most of the components could of been memoized to avoid computation

It's also important to remember if a component had no props/state/context change, and it was memoized, it would not render. So a flow we can go through is:
- find the most expensive components
- see what's causing them to render
- determine how you can make those state/props/context not change for a large set of the renders
- once there are no more changes left, you can memoize the component so it no longer unnecessarily re-renders. 


An important thing to note is that if you see a lot of react renders (some components with very high render counts), but other time is much higher than render time, it is possible that the components with lots of renders run hooks like useEffect/useLayoutEffect, which run outside of what we profile (just react render time).

It's also good to note that react profiles hook times in development, and if many hooks are called (lets say 5,000 components all called a useEffect), it will have to profile every single one, and this can add significant overhead when thousands of effects ran.

If it's not possible to explain the root problem from this data, please ask me for more data explicitly, and what we would need to know to find the source of the performance problem.
`;

const generateFrameDropDataPrompt = ({
  renderTime,
  otherTime,
  formattedReactData,
}: {
  renderTime: number;

  otherTime: number;
  formattedReactData: string;
}) => `I will provide you with a set of high level, and low level performance data about a large frame drop in a React App:
### High level
- react component render time: ${renderTime.toFixed(0)}ms
- how long it took to run everything else (other JavaScript, hooks like useEffect, style recalculations, layerization, paint & commit and everything else the browser might do to draw a new frame after javascript mutates the DOM): ${otherTime}ms

### Low level
We also have lower level information about react components, such as their render time, and which props/state/context changed when they re-rendered.
${formattedReactData}`;

export const generateInteractionExplanationPrompt = ({
  interactionType,
  name,
  time,
  renderTime,
  eHandlerTimeExcludingRenders,
  toRafTime,
  commitTime,
  framePresentTime,
  formattedReactData,
}: {
  interactionType: string;
  name: string;
  time: number;
  renderTime: number;
  eHandlerTimeExcludingRenders: number;
  toRafTime: number;
  commitTime: number;
  framePresentTime: number | null;
  formattedReactData: string;
}) => `Your goal will be to help me find the source of a performance problem. I collected a large dataset about this specific performance problem.

There was a ${interactionType} on a component named ${name}. This means, roughly, the component that handled the ${interactionType} event was named ${name}.

We have a set of high level, and low level data about the performance issue.

The click took ${time.toFixed(0)}ms from interaction start, to when a new frame was presented to a user.

We also provide you with a breakdown of what the browser spent time on during the period of interaction start to frame presentation.

- react component render time: ${renderTime.toFixed(0)}ms
- how long it took to run javascript event handlers (EXCLUDING REACT RENDERS): ${eHandlerTimeExcludingRenders.toFixed(0)}ms
- how long it took from the last event handler time, to the last request animation frame: ${toRafTime.toFixed(0)}ms
	- things like prepaint, style recalculations, layerization, async web API's like observers may occur during this time
- how long it took from the last request animation frame to when the dom was committed: ${commitTime.toFixed(0)}ms
	- during this period you will see paint, commit, potential style recalcs, and other misc browser activity. Frequently high times here imply css that makes the browser do a lot of work, or mutating expensive dom properties during the event handler stage. This can be many things, but it narrows the problem scope significantly when this is high
${framePresentTime && `- how long it took from dom commit for the frame to be presented: ${framePresentTime.toFixed(0)}ms. This is when information about how to paint the next frame is sent to the compositor threads, and when the GPU does work. If this is high, look for issues that may be a bottleneck for operations occurring during this time`}

We also have lower level information about react components, such as their render time, and which props/state/context changed when they re-rendered.

${formattedReactData}


You may notice components have many renders, but much fewer props/state/context changes. This normally implies most of the components could of been memoized to avoid computation

It's also important to remember if a component had no props/state/context change, and it was memoized, it would not render. So a flow we can go through is:
- find the most expensive components
- see what's causing them to render
- determine how you can make those state/props/context not change for a large set of the renders
- once there are no more changes left, you can memoize the component so it no longer unnecessarily re-renders. 


An important thing to note is that if you see a lot of react renders (some components with very high render counts), but javascript excluding renders is much higher than render time, it is possible that the components with lots of renders run hooks like useEffect/useLayoutEffect, which run during the JS event handler period.

It's also good to note that react profiles hook times in development, and if many hooks are called (lets say 5,000 components all called a useEffect), it will have to profile every single one. And it may also be the case the comparison of the hooks dependency can be expensive, and that would not be tracked in render time.

If it's not possible to explain the root problem from this data, please ask me for more data explicitly, and what we would need to know to find the source of the performance problem.
`;
export const getLLMPrompt = (
  activeTab: 'fix' | 'data' | 'explanation',
  selectedEvent: NotificationEvent,
) =>
  iife(() => {
    switch (activeTab) {
      case 'data': {
        switch (selectedEvent.kind) {
          case 'dropped-frames': {
            return generateFrameDropDataPrompt({
              formattedReactData: formatReactData(
                selectedEvent.groupedFiberRenders,
              ),
              renderTime: selectedEvent.groupedFiberRenders.reduce(
                (prev, curr) => prev + curr.totalTime,
                0,
              ),
              otherTime: selectedEvent.timing.otherTime,
            });
          }
          case 'interaction': {
            return generateInteractionDataPrompt({
              commitTime: selectedEvent.timing.frameConstruction,
              eHandlerTimeExcludingRenders: selectedEvent.timing.otherJSTime,
              formattedReactData: formatReactData(
                selectedEvent.groupedFiberRenders,
              ),
              framePresentTime: selectedEvent.timing.frameDraw,
              renderTime: selectedEvent.groupedFiberRenders.reduce(
                (prev, curr) => prev + curr.totalTime,
                0,
              ),
              toRafTime: selectedEvent.timing.framePreparation,
            });
          }
        }
      }
      case 'explanation': {
        switch (selectedEvent.kind) {
          case 'dropped-frames': {
            return generateFrameDropExplanationPrompt({
              formattedReactData: formatReactData(
                selectedEvent.groupedFiberRenders,
              ),
              renderTime: selectedEvent.groupedFiberRenders.reduce(
                (prev, curr) => prev + curr.totalTime,
                0,
              ),
              otherTime: selectedEvent.timing.otherTime,
            });
          }
          case 'interaction': {
            return generateInteractionExplanationPrompt({
              commitTime: selectedEvent.timing.frameConstruction,
              eHandlerTimeExcludingRenders: selectedEvent.timing.otherJSTime,
              formattedReactData: formatReactData(
                selectedEvent.groupedFiberRenders,
              ),
              framePresentTime: selectedEvent.timing.frameDraw,
              interactionType: selectedEvent.type,
              name: getComponentName(selectedEvent.componentPath),
              renderTime: selectedEvent.groupedFiberRenders.reduce(
                (prev, curr) => prev + curr.totalTime,
                0,
              ),
              time: getTotalTime(selectedEvent.timing),
              toRafTime: selectedEvent.timing.framePreparation,
            });
          }
        }
      }
      case 'fix': {
        switch (selectedEvent.kind) {
          case 'dropped-frames': {
            return generateFrameDropOptimizationPrompt({
              formattedReactData: formatReactData(
                selectedEvent.groupedFiberRenders,
              ),

              renderTime: selectedEvent.groupedFiberRenders.reduce(
                (prev, curr) => prev + curr.totalTime,
                0,
              ),
              otherTime: selectedEvent.timing.otherTime,
            });
          }
          case 'interaction': {
            return generateInteractionOptimizationPrompt({
              commitTime: selectedEvent.timing.frameConstruction,
              componentPath: selectedEvent.componentPath.join('>'),
              eHandlerTimeExcludingRenders: selectedEvent.timing.otherJSTime,
              formattedReactData: formatReactData(
                selectedEvent.groupedFiberRenders,
              ),
              framePresentTime: selectedEvent.timing.frameDraw,
              interactionType: selectedEvent.type,
              name: getComponentName(selectedEvent.componentPath),
              renderTime: selectedEvent.groupedFiberRenders.reduce(
                (prev, curr) => prev + curr.totalTime,
                0,
              ),
              time: getTotalTime(selectedEvent.timing),
              toRafTime: selectedEvent.timing.framePreparation,
            });
          }
        }
      }
    }
  });

export const Optimize = ({
  selectedEvent,
}: { selectedEvent: NotificationEvent }) => {
  const [activeTab, setActiveTab] = useState<'fix' | 'explanation' | 'data'>(
    'fix',
  );
  const [copying, setCopying] = useState(false);

  return (
    <div className={cn(['w-full h-full'])}>
      <div
        className={cn([
          'border border-[#27272A] rounded-sm h-4/5 text-xs overflow-hidden',
        ])}
      >
        <div className={cn(['bg-[#18181B] p-1 rounded-t-sm'])}>
          <div className={cn(['flex items-center gap-x-1'])}>
            <button
              onClick={() => setActiveTab('fix')}
              className={cn([
                'flex items-center justify-center whitespace-nowrap py-1.5 px-3 rounded-sm',
                activeTab === 'fix'
                  ? 'text-white bg-[#7521c8]'
                  : 'text-[#6E6E77] hover:text-white',
              ])}
            >
              Fix
            </button>

            <button
              onClick={() => setActiveTab('explanation')}
              className={cn([
                'flex items-center justify-center whitespace-nowrap py-1.5 px-3 rounded-sm',
                activeTab === 'explanation'
                  ? 'text-white bg-[#7521c8]'
                  : 'text-[#6E6E77] hover:text-white',
              ])}
            >
              Explanation
            </button>
            <button
              onClick={() => setActiveTab('data')}
              className={cn([
                'flex items-center justify-center whitespace-nowrap py-1.5 px-3 rounded-sm',
                activeTab === 'data'
                  ? 'text-white bg-[#7521c8]'
                  : 'text-[#6E6E77] hover:text-white',
              ])}
            >
              Data
            </button>
          </div>
        </div>
        <div className={cn(['overflow-y-auto h-full'])}>
          <pre
            className={cn([
              'p-2 h-full',
              'whitespace-pre-wrap break-words',
              'text-gray-300 font-mono ',
            ])}
          >
            {getLLMPrompt(activeTab, selectedEvent)}
          </pre>
        </div>
      </div>
      <button
        onClick={async () => {
          const text = getLLMPrompt(activeTab, selectedEvent);

          await navigator.clipboard.writeText(text);
          setCopying(true);
          setTimeout(() => setCopying(false), 1000);
        }}
        className={cn([
          'mt-4 px-4 py-2 bg-[#18181B] text-[#6E6E77] rounded-sm',
          'hover:text-white transition-colors duration-200',
          'flex items-center justify-center gap-x-2 text-xs',
        ])}
      >
        <span>{copying ? 'Copied!' : 'Copy Prompt'}</span>
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="16"
          height="16"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={cn([
            'transition-transform duration-200',
            copying && 'scale-110',
          ])}
        >
          {copying ? (
            <path d="M20 6L9 17l-5-5" />
          ) : (
            <>
              <rect width="14" height="14" x="8" y="8" rx="2" ry="2" />
              <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2" />
            </>
          )}
        </svg>
      </button>
    </div>
  );
};
</file>

<file path="src/web/views/notifications/other-visualization.tsx">
import { ReactNode } from 'preact/compat';
import { useContext, useEffect, useState } from 'preact/hooks';
import { getIsProduction } from '~core/index';
import { iife } from '~core/notifications/performance-utils';
import { cn } from '~web/utils/helpers';
import {
  InteractionEvent,
  NotificationEvent,
  getTotalTime,
  useNotificationsContext,
} from './data';
import { getLLMPrompt } from './optimize';
import { ToolbarElementContext } from '~web/widget';
type BaseTimeDataItem = {
  name: string;
  time: number;
  color: string;
  kind:
    | 'other-not-javascript'
    | 'other-javascript'
    | 'render'
    | 'other-frame-drop'
    | 'total-processing-time';
};

type TimeData = Array<BaseTimeDataItem>;

const getTimeData = (
  selectedEvent: NotificationEvent,
  isProduction: boolean,
) => {
  switch (selectedEvent.kind) {
    // todo: push instead of conditional spread
    case 'dropped-frames': {
      const timeData: TimeData = [
        ...(isProduction
          ? [
              {
                name: 'Total Processing Time',
                time: getTotalTime(selectedEvent.timing),
                color: 'bg-red-500',
                kind: 'total-processing-time' as const,
              },
            ]
          : [
              {
                name: 'Renders',
                time: selectedEvent.timing.renderTime,
                color: 'bg-purple-500',
                kind: 'render' as const,
              },
              {
                name: 'JavaScript, DOM updates, Draw Frame',
                time: selectedEvent.timing.otherTime,
                color: 'bg-[#4b4b4b]',
                kind: 'other-frame-drop' as const,
              },
            ]),
      ];
      return timeData;
    }
    case 'interaction': {
      const timeData: TimeData = [
        ...(!isProduction
          ? [
              {
                name: 'Renders',
                time: selectedEvent.timing.renderTime,
                color: 'bg-purple-500',
                kind: 'render' as const,
              },
            ]
          : []),
        {
          name: isProduction
            ? 'React Renders, Hooks, Other JavaScript'
            : 'JavaScript/React Hooks ',
          time: selectedEvent.timing.otherJSTime,
          color: 'bg-[#EFD81A]',

          kind: 'other-javascript',
        },

        {
          name: 'Update DOM and Draw New Frame',
          time:
            getTotalTime(selectedEvent.timing) -
            selectedEvent.timing.renderTime -
            selectedEvent.timing.otherJSTime,
          color: 'bg-[#1D3A66]',
          kind: 'other-not-javascript',
        },
      ];

      return timeData;
    }
  }
};

export const OtherVisualization = ({
  selectedEvent,
}: {
  selectedEvent: NotificationEvent;
}) => {
  const [isProduction] = useState(getIsProduction() ?? false);
  const { notificationState } = useNotificationsContext();
  const [expandedItems, setExpandedItems] = useState<string[]>(
    notificationState.routeMessage?.name
      ? [notificationState.routeMessage.name]
      : [],
  );
  const timeData = getTimeData(selectedEvent, isProduction);
  const root = useContext(ToolbarElementContext);

  // for when a user clicks a bar of a non render, and gets sent to the other visualization and passes a route message on the way
  // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>
  useEffect(() => {
    if (notificationState.routeMessage?.name) {
      const container = root?.querySelector('#overview-scroll-container');
      const element = root?.querySelector(
        `#react-scan-overview-bar-${notificationState.routeMessage.name}`,
      ) as HTMLElement;

      if (container && element) {
        const elementTop = element.getBoundingClientRect().top;
        const containerTop = container.getBoundingClientRect().top;
        const scrollOffset = elementTop - containerTop;
        container.scrollTop = container.scrollTop + scrollOffset;
      }
    }
  }, [notificationState.route]);

  // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>
  useEffect(() => {
    if (notificationState.route === 'other-visualization') {
      setExpandedItems((prev) =>
        notificationState.routeMessage?.name
          ? [notificationState.routeMessage.name]
          : prev,
      );
    }
  }, [notificationState.route]);

  const totalTime = timeData.reduce((acc, item) => acc + item.time, 0);

  return (
    <div className="rounded-sm border border-zinc-800 text-xs">
      <div className="p-2 border-b border-zinc-800 bg-zinc-900/50">
        <div className="flex items-center justify-between">
          <h3 className="text-xs font-medium">What was time spent on?</h3>
          <span className="text-xs text-zinc-400">
            Total: {totalTime.toFixed(0)}ms
          </span>
        </div>
      </div>
      <div className="divide-y divide-zinc-800">
        {timeData.map((entry) => {
          const isExpanded = expandedItems.includes(entry.kind);
          return (
            <div key={entry.kind} id={`react-scan-overview-bar-${entry.kind}`}>
              <button
                onClick={() =>
                  setExpandedItems((prev) =>
                    prev.includes(entry.kind)
                      ? prev.filter((item) => item !== entry.kind)
                      : [...prev, entry.kind],
                  )
                }
                className="w-full px-3 py-2 flex items-center gap-4 hover:bg-zinc-800/50 transition-colors"
              >
                <div className="flex-1">
                  <div className="flex items-center justify-between mb-2">
                    <div className="flex items-center gap-0.5">
                      <svg
                        className={`h-4 w-4 text-zinc-400 transition-transform ${isExpanded ? 'rotate-90' : ''}`}
                        fill="none"
                        stroke="currentColor"
                        viewBox="0 0 24 24"
                      >
                        <path
                          strokeLinecap="round"
                          strokeLinejoin="round"
                          strokeWidth={2}
                          d="M9 5l7 7-7 7"
                        />
                      </svg>
                      <span className="font-medium flex items-center text-left">
                        {entry.name}
                      </span>
                    </div>
                    <span className=" text-zinc-400">
                      {entry.time.toFixed(0)}ms
                    </span>
                  </div>
                  <div className="h-1 bg-zinc-800 rounded-full overflow-hidden">
                    <div
                      className={`h-full ${entry.color} transition-all`}
                      style={{
                        width: `${(entry.time / totalTime) * 100}%`,
                      }}
                    />
                  </div>
                </div>
              </button>
              {isExpanded && (
                <div className="bg-zinc-900/30 border-t border-zinc-800 px-2.5 py-3">
                  <p className=" text-zinc-400 mb-4 text-xs">
                    {iife(() => {
                      switch (selectedEvent.kind) {
                        case 'interaction': {
                          switch (entry.kind) {
                            case 'render': {
                              return (
                                <Explanation
                                  input={getRenderInput(selectedEvent)}
                                />
                              );
                            }

                            case 'other-javascript': {
                              return (
                                <Explanation
                                  input={getJSInput(selectedEvent)}
                                />
                              );
                            }

                            case 'other-not-javascript': {
                              return (
                                <Explanation
                                  input={getDrawInput(selectedEvent)}
                                />
                              );
                            }
                          }
                        }
                        case 'dropped-frames': {
                          switch (entry.kind) {
                            case 'total-processing-time': {
                              return (
                                <Explanation
                                  input={{
                                    kind: 'total-processing',
                                    data: {
                                      time: getTotalTime(selectedEvent.timing),
                                    },
                                  }}
                                />
                              );
                            }
                            case 'render': {
                              return (
                                <>
                                  <Explanation
                                    input={{
                                      kind: 'render',
                                      data: {
                                        topByTime:
                                          selectedEvent.groupedFiberRenders
                                            .toSorted(
                                              (a, b) =>
                                                b.totalTime - a.totalTime,
                                            )
                                            .slice(0, 3)
                                            .map((render) => ({
                                              name: render.name,
                                              percentage:
                                                render.totalTime /
                                                getTotalTime(
                                                  selectedEvent.timing,
                                                ),
                                            })),
                                      },
                                    }}
                                  />
                                </>
                              );
                            }
                            case 'other-frame-drop': {
                              return (
                                <Explanation
                                  input={{
                                    kind: 'other',
                                  }}
                                />
                              );
                            }
                          }
                        }
                      }
                    })}
                  </p>
                </div>
              )}
            </div>
          );
        })}
      </div>
    </div>
  );
};

type OverviewInput =
  | {
      kind: 'js-explanation-base';
    }
  | {
      kind: 'total-processing';
      data: {
        time: number;
      };
    }
  | {
      kind: 'high-render-count-high-js';
      data: {
        renderCount: number;
        topByCount: Array<{ name: string; count: number }>;
      };
    }
  | {
      kind: 'low-render-count-high-js';
      data: {
        renderCount: number;
      };
    }
  | {
      kind: 'high-render-count-update-dom-draw-frame';
      data: {
        count: number;
        percentageOfTotal: number;
        copyButton: ReactNode;
      };
    }
  | {
      kind: 'update-dom-draw-frame';
      data: {
        copyButton: ReactNode;
      };
    }
  | {
      kind: 'render';
      data: { topByTime: Array<{ name: string; percentage: number }> };
    }
  | {
      kind: 'other';
    };

export const getTotalProcessingTimeInput = (event: NotificationEvent) => {
  return {
    kind: 'total-processing',
    data: {
      time: getTotalTime(event.timing),
    },
  } satisfies OverviewInput;
};

const getDrawInput = (event: InteractionEvent): OverviewInput => {
  const renderCount = event.groupedFiberRenders.reduce(
    (prev, curr) => prev + curr.count,
    0,
  );

  const renderTime = event.timing.renderTime;
  const totalTime = getTotalTime(event.timing);
  const renderPercentage = (renderTime / totalTime) * 100;

  if (renderCount > 100) {
    return {
      kind: 'high-render-count-update-dom-draw-frame',
      data: {
        count: renderCount,
        percentageOfTotal: renderPercentage,
        copyButton: <CopyPromptButton />,
      },
    };
  }

  return {
    kind: 'update-dom-draw-frame',
    data: {
      copyButton: <CopyPromptButton />,
    },
  };
};

const CopyPromptButton = () => {
  const [copying, setCopying] = useState(false);
  const { notificationState } = useNotificationsContext();

  return (
    <button
      onClick={async () => {
        if (!notificationState.selectedEvent) {
          return;
        }

        await navigator.clipboard.writeText(
          getLLMPrompt('explanation', notificationState.selectedEvent),
        );
        setCopying(true);
        setTimeout(() => setCopying(false), 1000);
      }}
      className="bg-zinc-800 flex hover:bg-zinc-700 text-zinc-200 px-2 py-1 rounded gap-x-3"
    >
      <span>{copying ? 'Copied!' : 'Copy Prompt'}</span>
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="16"
        height="16"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
        className={cn([
          'transition-transform duration-200',
          copying && 'scale-110',
        ])}
      >
        {copying ? (
          <path d="M20 6L9 17l-5-5" />
        ) : (
          <>
            <rect width="14" height="14" x="8" y="8" rx="2" ry="2" />
            <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2" />
          </>
        )}
      </svg>
    </button>
  );
};

const getRenderInput = (event: InteractionEvent): OverviewInput => {
  if (event.timing.renderTime / getTotalTime(event.timing) > 0.3) {
    return {
      kind: 'render',
      data: {
        topByTime: event.groupedFiberRenders
          .toSorted((a, b) => b.totalTime - a.totalTime)
          .slice(0, 3)
          .map((e) => ({
            percentage: e.totalTime / getTotalTime(event.timing),
            name: e.name,
          })),
      },
    };
  }

  return {
    kind: 'other',
  };
};

const getJSInput = (event: InteractionEvent): OverviewInput => {
  const renderCount = event.groupedFiberRenders.reduce(
    (prev, curr) => prev + curr.count,
    0,
  );
  if (event.timing.otherJSTime / getTotalTime(event.timing) < 0.2) {
    return {
      kind: 'js-explanation-base',
    };
  }
  if (
    event.groupedFiberRenders.find((render) => render.count > 200) ||
    event.groupedFiberRenders.reduce((prev, curr) => prev + curr.count, 0) > 500
  ) {
    // not sure a great heuristic for picking the render count
    return {
      kind: 'high-render-count-high-js',
      data: {
        renderCount,
        topByCount: event.groupedFiberRenders
          .filter((groupedRender) => groupedRender.count > 100)
          .toSorted((a, b) => b.count - a.count)
          .slice(0, 3),
      },
    };
  }
  if (event.timing.otherJSTime / getTotalTime(event.timing) > 0.3) {
    if (event.timing.renderTime > 0.2) {
      return {
        kind: 'js-explanation-base',
      };
    }

    return {
      kind: 'low-render-count-high-js',
      data: {
        renderCount,
      },
    };
  }

  return {
    kind: 'js-explanation-base',
  };
};

const Explanation = ({ input }: { input: OverviewInput }) => {
  switch (input.kind) {
    case 'total-processing': {
      return (
        <div
          className={cn([
            'text-[#E4E4E7] text-[10px] leading-6 flex flex-col gap-y-2',
          ])}
        >
          <p>
            This is the time it took to draw the entire frame that was presented
            to the user. To be at 60FPS, this number needs to be {'<=16ms'}
          </p>

          <p>
            To debug the issue, check the "Ranked" tab to see if there are
            significant component renders
          </p>
          <p>
            On a production React build, React Scan can't access the time it
            took for component to render. To get that information, run React
            Scan on a development build
          </p>

          <p>
            To understand precisely what caused the slowdown while in
            production, use the <strong>Chrome profiler</strong> and analyze the
            function call times.
          </p>

          <p></p>
        </div>
      );
    }
    case 'render': {
      return (
        <div
          className={cn([
            'text-[#E4E4E7] text-[10px] leading-6 flex flex-col gap-y-2',
          ])}
        >
          <p>
            This is the time it took React to run components, and internal logic
            to handle the output of your component.
          </p>

          <div className={cn(['flex flex-col'])}>
            <p>The slowest components for this time period were:</p>
            {input.data.topByTime.map((item) => (
              <div key={item.name}>
                <strong>{item.name}</strong>:{' '}
                {(item.percentage * 100).toFixed(0)}% of total
              </div>
            ))}
          </div>
          <p>
            To view the render times of all your components, and what caused
            them to render, go to the "Ranked" tab
          </p>
          <p>The "Ranked" tab shows the render times of every component.</p>
          <p>
            The render times of the same components are grouped together into
            one bar.
          </p>
          <p>
            Clicking the component will show you what props, state, or context
            caused the component to re-render.
          </p>
        </div>
      );
    }
    case 'js-explanation-base': {
      return (
        <div
          className={cn([
            'text-[#E4E4E7] text-[10px] leading-6 flex flex-col gap-y-2',
          ])}
        >
          <p>
            This is the period when JavaScript hooks and other JavaScript
            outside of React Renders run.
          </p>
          <p>
            The most common culprit for high JS time is expensive hooks, like
            expensive callbacks inside of <code>useEffect</code>'s or a large
            number of useEffect's called, but this can also be JavaScript event
            handlers (<code>'onclick'</code>, <code>'onchange'</code>) that
            performed expensive computation.
          </p>
          <p>
            If you have lots of components rendering that call hooks, like
            useEffect, it can add significant overhead even if the callbacks are
            not expensive. If this is the case, you can try optimizing the
            renders of those components to avoid the hook from having to run.
          </p>
          <p>
            You should profile your app using the{' '}
            <strong>Chrome DevTools profiler</strong> to learn exactly which
            functions took the longest to execute.
          </p>
        </div>
      );
    }
    case 'high-render-count-high-js': {
      return (
        <div
          className={cn([
            'text-[#E4E4E7] text-[10px] leading-6 flex flex-col gap-y-2',
          ])}
        >
          <p>
            This is the period when JavaScript hooks and other JavaScript
            outside of React Renders run.
          </p>
          {input.data.renderCount === 0 ? (
            <>
              <p>
                There were no renders, which means nothing related to React
                caused this slowdown. The most likely cause of the slowdown is a
                slow JavaScript event handler, or code related to a Web API
              </p>
              <p>
                You should try to reproduce the slowdown while profiling your
                website with the
                <strong>Chrome DevTools profiler</strong> to see exactly what
                functions took the longest to execute.
              </p>
            </>
          ) : (
            <>
              {' '}
              <p>
                There were <strong>{input.data.renderCount}</strong> renders,
                which could have contributed to the high JavaScript/Hook time if
                they ran lots of hooks, like <code>useEffects</code>.
              </p>
              <div className={cn(['flex flex-col'])}>
                <p>You should try optimizing the renders of:</p>
                {input.data.topByCount.map((item) => (
                  <div key={item.name}>
                    - <strong>{item.name}</strong> (rendered {item.count}x)
                  </div>
                ))}
              </div>
              and then checking if the problem still exists.
              <p>
                You can also try profiling your app using the{' '}
                <strong>Chrome DevTools profiler</strong> to see exactly what
                functions took the longest to execute.
              </p>
            </>
          )}
        </div>
      );
    }
    case 'low-render-count-high-js': {
      return (
        <div
          className={cn([
            'text-[#E4E4E7] text-[10px] leading-6 flex flex-col gap-y-2',
          ])}
        >
          <p>
            This is the period when JavaScript hooks and other JavaScript
            outside of React Renders run.
          </p>
          <p>
            There were only <strong>{input.data.renderCount}</strong> renders
            detected, which means either you had very expensive hooks like{' '}
            <code>useEffect</code>/<code>useLayoutEffect</code>, or there is
            other JavaScript running during this interaction that took up the
            majority of the time.
          </p>
          <p>
            To understand precisely what caused the slowdown, use the{' '}
            <strong>Chrome profiler</strong> and analyze the function call
            times.
          </p>
        </div>
      );
    }
    case 'high-render-count-update-dom-draw-frame': {
      return (
        <div
          className={cn([
            'text-[#E4E4E7] text-[10px] leading-6 flex flex-col gap-y-2',
          ])}
        >
          <p>
            These are the calculations the browser is forced to do in response
            to the JavaScript that ran during the interaction.
          </p>
          <p>
            This can be caused by CSS updates/CSS recalculations, or new DOM
            elements/DOM mutations.
          </p>
          <p>
            During this interaction, there were{' '}
            <strong>{input.data.count}</strong> renders, which was{' '}
            <strong>{input.data.percentageOfTotal.toFixed(0)}%</strong> of the
            time spent processing
          </p>
          <p>
            The work performed as a result of the renders may have forced the
            browser to spend a lot of time to draw the next frame.
          </p>
          <p>
            You can try optimizing the renders to see if the performance problem
            still exists using the "Ranked" tab.
          </p>
          <p>
            If you use an AI-based code editor, you can export the performance
            data collected as a prompt.
          </p>

          <p>{input.data.copyButton}</p>
          <p>
            Provide this formatted data to the model and ask it to find, or fix,
            what could be causing this performance problem.
          </p>
          <p>For a larger selection of prompts, try the "Prompts" tab</p>
        </div>
      );
    }
    case 'update-dom-draw-frame': {
      return (
        <div
          className={cn([
            'text-[#E4E4E7] text-[10px] leading-6 flex flex-col gap-y-2',
          ])}
        >
          <p>
            These are the calculations the browser is forced to do in response
            to the JavaScript that ran during the interaction.
          </p>
          <p>
            This can be caused by CSS updates/CSS recalculations, or new DOM
            elements/DOM mutations.
          </p>
          <p>
            If you use an AI-based code editor, you can export the performance
            data collected as a prompt.
          </p>

          <p>{input.data.copyButton}</p>
          <p>
            Provide this formatted data to the model and ask it to find, or fix,
            what could be causing this performance problem.
          </p>
          <p>For a larger selection of prompts, try the "Prompts" tab</p>
        </div>
      );
    }
    case 'other': {
      return (
        <div
          className={cn([
            'text-[#E4E4E7] text-[10px] leading-6 flex flex-col gap-y-2',
          ])}
        >
          <p>
            This is the time it took to run everything other than React renders.
            This can be hooks like <code>useEffect</code>, other JavaScript not
            part of React, or work the browser has to do to update the DOM and
            draw the next frame.
          </p>
          <p>
            To get a better picture of what happened, profile your app using the{' '}
            <strong>Chrome profiler</strong> when the performance problem
            arises.
          </p>
        </div>
      );
    }
  }
};
</file>

<file path="src/web/views/notifications/popover.tsx">
import {
  ComponentProps,
  ReactNode,
  createPortal,
  useContext,
  useEffect,
  useRef,
  useState,
} from 'preact/compat';
import { cn } from '~web/utils/helpers';
import { ToolbarElementContext } from '~web/widget';

type PopoverState = 'closed' | 'opening' | 'open' | 'closing';

/**
 *
 * fixme: very hacky and suboptimal popover (api and implementation)
 */
export const Popover = ({
  children,
  triggerContent,
  wrapperProps,
}: {
  children: ReactNode;
  triggerContent: ReactNode;
  wrapperProps?: ComponentProps<'div'>;
}) => {
  const [popoverState, setPopoverState] = useState<PopoverState>('closed');
  const [elBoundingRect, setElBoundingRect] = useState<DOMRect | null>(null);
  const [viewportSize, setViewportSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  });
  const triggerRef = useRef<HTMLDivElement | null>(null);
  const popoverRef = useRef<HTMLDivElement | null>(null);
  const portalEl = useContext(ToolbarElementContext);
  const isHoveredRef = useRef(false);

  useEffect(() => {
    const handleResize = () => {
      setViewportSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
      updateRect();
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  const updateRect = () => {
    if (triggerRef.current && portalEl) {
      const triggerRect = triggerRef.current.getBoundingClientRect();
      const portalRect = portalEl.getBoundingClientRect();

      const centerX = triggerRect.left + triggerRect.width / 2;
      const centerY = triggerRect.top;

      const rect = new DOMRect(
        centerX - portalRect.left,
        centerY - portalRect.top,
        triggerRect.width,
        triggerRect.height,
      );
      setElBoundingRect(rect);
    }
  };

  // biome-ignore lint/correctness/useExhaustiveDependencies: its not pure but fine
  useEffect(() => {
    updateRect();
  }, [triggerRef.current]);

  useEffect(() => {
    if (popoverState === 'opening') {
      const timer = setTimeout(() => setPopoverState('open'), 120);
      return () => clearTimeout(timer);
    } else if (popoverState === 'closing') {
      const timer = setTimeout(() => setPopoverState('closed'), 120);
      return () => clearTimeout(timer);
    }
  }, [popoverState]);

  // just incase we didn't capture the mouse leave event because the underlying container moved
  useEffect(() => {
    const interval = setInterval(() => {
      if (!isHoveredRef.current && popoverState !== 'closed') {
        setPopoverState('closing');
      }
    }, 1000);

    return () => clearInterval(interval);
  }, [popoverState]);

  const handleMouseEnter = () => {
    isHoveredRef.current = true;
    updateRect();
    setPopoverState('opening');
  };

  const handleMouseLeave = () => {
    isHoveredRef.current = false;
    updateRect();
    setPopoverState('closing');
  };

  const getPopoverPosition = () => {
    if (!elBoundingRect || !portalEl) return { top: 0, left: 0 };

    const portalRect = portalEl.getBoundingClientRect();
    const popoverWidth = 175;
    const popoverHeight = popoverRef.current?.offsetHeight || 40;
    const safeArea = 5;

    const viewportX = elBoundingRect.x + portalRect.left;
    const viewportY = elBoundingRect.y + portalRect.top;

    let left = viewportX;
    let top = viewportY - 4;

    if (left - popoverWidth / 2 < safeArea) {
      left = safeArea + popoverWidth / 2;
    } else if (left + popoverWidth / 2 > viewportSize.width - safeArea) {
      left = viewportSize.width - safeArea - popoverWidth / 2;
    }

    if (top - popoverHeight < safeArea) {
      top = viewportY + elBoundingRect.height + 4;
    }

    return {
      top: top - portalRect.top,
      left: left - portalRect.left,
    };
  };

  return (
    <>
      {portalEl &&
        elBoundingRect &&
        popoverState !== 'closed' &&
        createPortal(
          <div
            ref={popoverRef}
            className={cn([
              'absolute z-100 bg-white text-black rounded-lg px-3 py-2 shadow-lg',
              'transform transition-all duration-120 ease-[cubic-bezier(0.23,1,0.32,1)]',
              'after:content-[""] after:absolute after:top-[100%]',
              'after:left-1/2 after:-translate-x-1/2',
              'after:w-[10px] after:h-[6px]',
              'after:border-l-[5px] after:border-l-transparent',
              'after:border-r-[5px] after:border-r-transparent',
              'after:border-t-[6px] after:border-t-white',
              'pointer-events-none',
              popoverState === 'opening' || popoverState === 'closing'
                ? 'opacity-0 translate-y-1'
                : 'opacity-100 translate-y-0',
            ])}
            style={{
              top: getPopoverPosition().top + 'px',
              left: getPopoverPosition().left + 'px',
              transform: 'translate(-50%, -100%)',
              minWidth: '175px',
            }}
          >
            {children}
          </div>,
          portalEl,
        )}

      <div
        ref={triggerRef}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
        {...wrapperProps}
      >
        {triggerContent}
      </div>
    </>
  );
};
</file>

<file path="src/web/views/notifications/render-bar-chart.tsx">
import { useRef, useState } from 'preact/hooks';
import { getBatchedRectMap } from 'src/new-outlines';
import { getIsProduction } from '~core/index';
import { iife } from '~core/notifications/performance-utils';
import { cn } from '~web/utils/helpers';
import {
  GroupedFiberRender,
  NotificationEvent,
  getTotalTime,
  isRenderMemoizable,
  useNotificationsContext,
} from './data';
import {
  HighlightStore,
  drawHighlights,
} from '~core/notifications/outline-overlay';
import { ChevronRight } from './icons';

// todo: cleanup, convoluted ternaries
export const fadeOutHighlights = () => {
  const curr = HighlightStore.value.current
    ? HighlightStore.value.current
    : HighlightStore.value.kind === 'transition'
      ? HighlightStore.value.transitionTo
      : null;
  if (!curr) {
    return;
  }

  if (HighlightStore.value.kind === 'transition') {
    HighlightStore.value = {
      kind: 'move-out',
      // because we want to dynamically fade this value
      current:
        HighlightStore.value.current?.alpha === 0
          ? // we want to only start fading from transition if current is done animating out
            HighlightStore.value.transitionTo
          : // if current doesn't exist then transition must exist
            (HighlightStore.value.current ?? HighlightStore.value.transitionTo),
    };
    return;
  }

  HighlightStore.value = {
    kind: 'move-out',
    current: {
      alpha: 0,
      ...curr,
    },
  };
};

type Bars = Array<
  | { kind: 'other-frame-drop'; totalTime: number }
  | { kind: 'other-not-javascript'; totalTime: number }
  | { kind: 'other-javascript'; totalTime: number }
  | { kind: 'render'; event: GroupedFiberRender; totalTime: number }
>;

export const NO_PURGE = ['hover:bg-[#0f0f0f]'];

export const RenderBarChart = ({
  selectedEvent,
}: { selectedEvent: NotificationEvent }) => {
  const totalInteractionTime = getTotalTime(selectedEvent.timing);
  const nonRender = totalInteractionTime - selectedEvent.timing.renderTime;
  const [isProduction] = useState(getIsProduction());
  const events = selectedEvent.groupedFiberRenders;
  const bars: Bars = events.map((event) => ({
    event,
    kind: 'render',
    totalTime: isProduction ? event.count : event.totalTime,
  }));

  const isShowingExtraInfo = iife(() => {
    switch (selectedEvent.kind) {
      case 'dropped-frames': {
        return selectedEvent.timing.renderTime / totalInteractionTime < 0.1;
      }
      case 'interaction': {
        return (
          (selectedEvent.timing.otherJSTime + selectedEvent.timing.renderTime) /
            totalInteractionTime <
          0.2
        );
      }
    }
  });
  /**
   * We don't add the extra bars in production because we can't compare them to the renders, so the bar is useless, user can use overview tab to see times
   */
  if (selectedEvent.kind === 'interaction' && !isProduction) {
    bars.push({
      kind: 'other-javascript',
      totalTime: selectedEvent.timing.otherJSTime,
    });
  }

  if (isShowingExtraInfo && !isProduction) {
    if (selectedEvent.kind === 'interaction') {
      bars.push({
        kind: 'other-not-javascript',
        totalTime:
          getTotalTime(selectedEvent.timing) -
          selectedEvent.timing.renderTime -
          selectedEvent.timing.otherJSTime,
      });
    } else {
      bars.push({
        kind: 'other-frame-drop',
        totalTime: nonRender,
      });
    }
  }

  const debouncedMouseEnter = useRef<{
    timer: ReturnType<typeof setTimeout> | null;
    lastCallAt: number | null;
  }>({
    lastCallAt: null,
    timer: null,
  });

  const totalBarTime = bars.reduce((prev, curr) => prev + curr.totalTime, 0);

  return (
    <div className={cn(['flex flex-col h-full w-full gap-y-1'])}>
      {iife(() => {
        if (isProduction && bars.length === 0) {
          return (
            <div className="flex flex-col items-center justify-center h-full text-zinc-400">
              <p className="text-sm w-full text-left text-white mb-1.5">
                No data available
              </p>
              <p className="text-x w-full text-lefts">
                No data was collected during this period
              </p>
            </div>
          );
        }
        if (bars.length === 0) {
          return (
            <div className="flex flex-col items-center justify-center h-full text-zinc-400">
              <p className="text-sm w-full text-left text-white mb-1.5">
                No renders collected
              </p>
              <p className="text-x w-full text-lefts">
                There were no renders during this period
              </p>
            </div>
          );
        }
      })}

      {bars
        .toSorted((a, b) => b.totalTime - a.totalTime)
        .map((bar) => (
          <RenderBar
            key={bar.kind === 'render' ? bar.event.id : bar.kind}
            bars={bars}
            bar={bar}
            debouncedMouseEnter={debouncedMouseEnter}
            totalBarTime={totalBarTime}
            isProduction={isProduction}
          />
        ))}
    </div>
  );
};

const getTransitionState = (state: {
  current: { alpha: number } | null;
  transitionTo: { alpha: number };
}) => {
  if (!state.current) {
    return 'fading-in';
  }
  if (state.current.alpha > 0) {
    return 'fading-out' as const;
  }
  return 'fading-in' as const;
};

const RenderBar = ({
  bar,
  debouncedMouseEnter,
  totalBarTime,
  isProduction,
  bars,
  depth = 0,
}: {
  depth?: number;
  bars: Bars;
  bar: Bars[number];
  debouncedMouseEnter: {
    current: {
      timer: ReturnType<typeof setTimeout> | null;
      lastCallAt: number | null;
    };
  };
  totalBarTime: number;
  isProduction: boolean | null;
}) => {
  const { setNotificationState, setRoute } = useNotificationsContext();
  const [isExpanded, setIsExpanded] = useState(false);

  const isLeaf = bar.kind === 'render' ? bar.event.parents.size === 0 : true;

  const parentBars = bars.filter((otherBar) =>
    otherBar.kind === 'render' && bar.kind === 'render'
      ? bar.event.parents.has(otherBar.event.name) &&
        otherBar.event.name !== bar.event.name
      : false,
  );

  const missingParentNames =
    bar.kind === 'render'
      ? Array.from(bar.event.parents).filter(
          (parentName) =>
            !bars.some(
              (b) => b.kind === 'render' && b.event.name === parentName,
            ),
        )
      : [];

  const handleBarClick = () => {
    if (bar.kind === 'render') {
      setNotificationState((prev) => ({
        ...prev,
        selectedFiber: bar.event,
      }));

      setRoute({
        route: 'render-explanation',
        routeMessage: null,
      });
    } else {
      setRoute({
        route: 'other-visualization',
        routeMessage: {
          kind: 'auto-open-overview-accordion',
          name: bar.kind,
        },
      });
    }
  };

  return (
    <div className="w-full">
      <div
        className={cn(['w-full flex items-center relative text-xs min-w-0'])}
      >
        <button
          onMouseLeave={() => {
            debouncedMouseEnter.current.timer &&
              clearTimeout(debouncedMouseEnter.current.timer);
            fadeOutHighlights();
          }}
          onMouseEnter={async () => {
            const highlightBars = async () => {
              debouncedMouseEnter.current.lastCallAt = Date.now();
              if (bar.kind !== 'render') {
                const curr = HighlightStore.value.current
                  ? HighlightStore.value.current
                  : HighlightStore.value.kind === 'transition'
                    ? HighlightStore.value.transitionTo
                    : null;

                if (!curr) {
                  HighlightStore.value = {
                    kind: 'idle',
                    current: null,
                  };
                  return;
                }
                HighlightStore.value = {
                  kind: 'move-out',
                  current: {
                    alpha: 0,
                    ...curr,
                  },
                };
                return;
              }
              const state = HighlightStore.value;
              const currentState = iife(() => {
                switch (state.kind) {
                  case 'transition': {
                    return state.transitionTo;
                  }
                  case 'idle':
                  case 'move-out': {
                    return state.current;
                  }
                }
              });
              const stateRects: Array<DOMRect> = [];

              if (state.kind === 'transition') {
                const transitionState = getTransitionState(state);
                iife(() => {
                  switch (transitionState) {
                    case 'fading-in': {
                      HighlightStore.value = {
                        kind: 'transition',
                        current: state.transitionTo,
                        transitionTo: {
                          rects: stateRects,
                          alpha: 0,
                          name: bar.event.name,
                        },
                      };
                      return;
                    }
                    case 'fading-out': {
                      HighlightStore.value = {
                        kind: 'transition',
                        current: HighlightStore.value.current
                          ? {
                              alpha: 0,
                              ...HighlightStore.value.current,
                            }
                          : null,
                        transitionTo: {
                          rects: stateRects,
                          alpha: 0,
                          name: bar.event.name,
                        },
                      };
                      return;
                    }
                  }
                });
              } else {
                HighlightStore.value = {
                  kind: 'transition',
                  transitionTo: {
                    rects: stateRects,
                    alpha: 0,
                    name: bar.event.name,
                  },
                  current: currentState
                    ? {
                        alpha: 0,
                        ...currentState,
                      }
                    : null,
                };
              }

              const trueElements = bar.event.elements.filter(
                (element) => element instanceof Element,
              );

              for await (const entries of getBatchedRectMap(trueElements)) {
                entries.forEach(({ boundingClientRect }) => {
                  stateRects.push(boundingClientRect);
                });
                drawHighlights();
              }
            };

            if (
              debouncedMouseEnter.current.lastCallAt &&
              Date.now() - debouncedMouseEnter.current.lastCallAt < 200
            ) {
              debouncedMouseEnter.current.timer &&
                clearTimeout(debouncedMouseEnter.current.timer);
              debouncedMouseEnter.current.timer = setTimeout(() => {
                highlightBars();
              }, 200);
              return;
            }

            highlightBars();
          }}
          onClick={handleBarClick}
          className={cn([
            'h-full w-[90%] flex items-center hover:bg-[#0f0f0f] rounded-l-md min-w-0 relative',
          ])}
        >
          <div
            style={{
              minWidth: 'fit-content',
              width: `${(bar.totalTime / totalBarTime) * 100}%`,
            }}
            className={cn([
              'flex items-center rounded-sm text-white text-xs h-[28px] shrink-0',
              bar.kind === 'render' && 'bg-[#412162] group-hover:bg-[#5b2d89]',
              bar.kind === 'other-frame-drop' &&
                'bg-[#44444a] group-hover:bg-[#6a6a6a]',
              bar.kind === 'other-javascript' &&
                'bg-[#efd81a6b] group-hover:bg-[#efda1a2f]',
              bar.kind === 'other-not-javascript' &&
                'bg-[#214379d4] group-hover:bg-[#21437982]',
            ])}
          />
          <div
            className={cn([
              'absolute inset-0 flex items-center px-2',
              'min-w-0',
            ])}
          >
            <div className="flex items-center gap-x-2 min-w-0 w-full">
              <span className={cn(['truncate'])}>
                {iife(() => {
                  switch (bar.kind) {
                    case 'other-frame-drop': {
                      return 'JavaScript, DOM updates, Draw Frame';
                    }
                    case 'other-javascript': {
                      return 'JavaScript/React Hooks';
                    }
                    case 'other-not-javascript': {
                      return 'Update DOM and Draw New Frame';
                    }
                    case 'render': {
                      return bar.event.name;
                    }
                  }
                })}
              </span>
              {bar.kind === 'render' && isRenderMemoizable(bar.event) && (
                <div
                  style={{
                    lineHeight: '10px',
                  }}
                  className={cn([
                    'px-1 py-0.5 bg-[#6a369e] flex items-center rounded-sm font-semibold text-[8px] shrink-0',
                  ])}
                >
                  Memoizable
                </div>
              )}
            </div>
          </div>
        </button>

        <button
          onClick={() =>
            bar.kind === 'render' && !isLeaf && setIsExpanded(!isExpanded)
          }
          className={cn([
            'flex items-center min-w-fit shrink-0 rounded-r-md h-[28px]',
            !isLeaf && 'hover:bg-[#0f0f0f]',
            bar.kind === 'render' && !isLeaf
              ? 'cursor-pointer'
              : 'cursor-default',
          ])}
        >
          <div className="w-[20px] flex items-center justify-center">
            {bar.kind === 'render' && !isLeaf && (
              <ChevronRight
                className={cn(
                  'transition-transform',
                  isExpanded && 'rotate-90',
                )}
                size={16}
              />
            )}
          </div>

          <div
            style={{
              minWidth: isLeaf ? 'fit-content' : isProduction ? '30px' : '60px',
            }}
            className="flex items-center justify-end gap-x-1"
          >
            {bar.kind === 'render' && (
              <span className={cn(['text-[10px]'])}>x{bar.event.count}</span>
            )}

            {(bar.kind !== 'render' || !isProduction) && (
              <span className="text-[10px] text-[#7346a0] pr-1">
                {bar.totalTime < 1 ? '<1' : bar.totalTime.toFixed(0)}
                ms
              </span>
            )}
          </div>
        </button>

        {depth === 0 && (
          <div
            className={cn([
              'absolute right-0 top-1/2 transition-none -translate-y-1/2 bg-white text-black px-2 py-1 rounded text-xs opacity-0 group-hover:opacity-100 transition-opacity mr-16',
              'pointer-events-none',
            ])}
          >
            Click to learn more
          </div>
        )}
      </div>

      {isExpanded &&
        (parentBars.length > 0 || missingParentNames.length > 0) && (
          <div className="pl-3 flex flex-col gap-y-1 mt-1">
            {parentBars
              .toSorted((a, b) => b.totalTime - a.totalTime)
              .map((parentBar, i) => (
                <RenderBar
                  depth={depth + 1}
                  key={i}
                  bar={parentBar}
                  debouncedMouseEnter={debouncedMouseEnter}
                  totalBarTime={totalBarTime}
                  isProduction={isProduction}
                  bars={bars}
                />
              ))}
            {missingParentNames.map((parentName) => (
              <div key={parentName} className="w-full">
                <div className="w-full flex items-center relative text-xs">
                  <div className="h-full w-full flex items-center relative">
                    <div className="flex items-center rounded-sm text-white text-xs h-[28px] w-full" />
                    <div className="absolute inset-0 flex items-center px-2">
                      <span className="truncate whitespace-nowrap text-white/70 w-full">
                        {parentName}
                      </span>
                    </div>
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}
    </div>
  );
};
</file>

<file path="src/web/views/notifications/render-explanation.tsx">
import { cn } from '~web/utils/helpers';
import { NotificationEvent, useNotificationsContext } from './data';
import { useLayoutEffect, useState } from 'preact/hooks';
import { ArrowLeft, CloseIcon } from './icons';
import { getIsProduction } from '~core/index';

export const RenderExplanation = ({
  selectedEvent: _,
  selectedFiber,
}: {
  selectedFiber: NotificationEvent['groupedFiberRenders'][number];
  selectedEvent: NotificationEvent;
}) => {
  const { setRoute } = useNotificationsContext();
  const [tipisShown, setTipIsShown] = useState(true);
  const [isProduction] = useState(getIsProduction());

  useLayoutEffect(() => {
    const res = localStorage.getItem('react-scan-tip-shown');
    const asBool = res === 'true' ? true : res === 'false' ? false : null;
    if (asBool === null) {
      setTipIsShown(true);
      localStorage.setItem('react-scan-tip-is-shown', 'true');
      return;
    }
    if (!asBool) {
      setTipIsShown(false);
    }
  }, []);
  const isMemoizable =
    selectedFiber.changes.context.length === 0 &&
    selectedFiber.changes.props.length === 0 &&
    selectedFiber.changes.state.length === 0;
  return (
    <div
      className={cn([
        'w-full min-h-fit h-full flex flex-col py-4 pt-0 rounded-sm',
      ])}
    >
      <div className={cn(['flex items-start gap-x-4 '])}>
        <button
          onClick={() => {
            setRoute({
              route: 'render-visualization',
              routeMessage: null,
            });
          }}
          className={cn([
            'text-white hover:bg-[#34343b] flex gap-x-1 justify-center items-center mb-4 w-fit px-2.5 py-1.5 text-xs rounded-sm bg-[#18181B]',
          ])}
        >
          <ArrowLeft size={14} /> <span>Overview</span>
        </button>
        <div className={cn(['flex flex-col gap-y-1'])}>
          <div
            className={cn(['text-sm font-bold text-white overflow-x-hidden'])}
          >
            <div className="flex items-center gap-x-2 truncate">
              {selectedFiber.name}
            </div>
          </div>
          <div className={cn(['flex gap-x-2'])}>
            {!isProduction && (
              <>
                <div className={cn(['text-xs text-gray-400'])}>
                   Render time: {selectedFiber.totalTime.toFixed(0)}ms
                </div>
              </>
            )}
            <div className={cn(['text-xs text-gray-400 mb-4'])}>
               Renders: {selectedFiber.count}x
            </div>
          </div>
        </div>
      </div>
      {tipisShown && !isMemoizable && (
        <div
          className={cn([
            'w-full mb-4 bg-[#0A0A0A] border border-[#27272A] rounded-sm overflow-hidden flex relative',
          ])}
        >
          <button
            onClick={() => {
              setTipIsShown(false);

              localStorage.setItem('react-scan-tip-shown', 'false');
            }}
            className={cn([
              'absolute right-2 top-2 rounded-sm p-1 hover:bg-[#18181B]',
            ])}
          >
            <CloseIcon size={12} />
          </button>
          <div className={cn(['w-1 bg-[#d36cff]'])} />
          <div className={cn(['flex-1'])}>
            <div
              className={cn(['px-3 py-2 text-gray-100 text-xs font-semibold'])}
            >
              How to stop renders
            </div>
            <div className={cn(['px-3 pb-2 text-gray-400 text-[10px]'])}>
              Stop the following props, state and context from changing between
              renders, and wrap the component in React.memo if not already
            </div>
          </div>
        </div>
      )}

      {isMemoizable && (
        <div
          className={cn([
            'w-full mb-4 bg-[#0A0A0A] border border-[#27272A] rounded-sm overflow-hidden flex',
          ])}
        >
          <div className={cn(['w-1 bg-[#d36cff]'])} />
          <div className={cn(['flex-1'])}>
            <div
              className={cn(['px-3 py-2 text-gray-100 text-sm font-semibold'])}
            >
              No changes detected
            </div>
            <div className={cn(['px-3 pb-2 text-gray-400 text-xs'])}>
              This component would not of rendered if it was memoized
            </div>
          </div>
        </div>
      )}
      <div className={cn(['flex w-full'])}>
        <div
          className={cn([
            'flex flex-col border border-[#27272A] rounded-l-sm overflow-hidden w-1/3',
          ])}
        >
          <div
            className={cn([
              'text-[14px] font-semibold px-2 py-2 bg-[#18181B] text-white flex justify-center',
            ])}
          >
            Changed Props
          </div>
          {selectedFiber.changes.props.length > 0 ? (
            selectedFiber.changes.props
              .toSorted((a, b) => b.count - a.count)
              .map((change) => (
                <div
                  key={change.name}
                  className={cn([
                    'flex flex-col justify-between items-center border-t overflow-x-auto border-[#27272A] px-1 py-1 text-wrap bg-[#0A0A0A] text-[10px]',
                  ])}
                >
                  <span className={cn(['text-white '])}>{change.name}</span>
                  <div
                    className={cn([' text-[8px]  text-[#d36cff] pl-1 py-1 '])}
                  >
                    {change.count}/{selectedFiber.count}x
                  </div>
                </div>
              ))
          ) : (
            <div
              className={cn([
                'flex items-center justify-center h-full bg-[#0A0A0A] text-[#A1A1AA] border-t border-[#27272A]',
              ])}
            >
              No changes
            </div>
          )}
        </div>
        <div
          className={cn([
            'flex flex-col border border-[#27272A] border-l-0 overflow-hidden w-1/3',
          ])}
        >
          <div
            className={cn([
              ' text-[14px] font-semibold px-2 py-2 bg-[#18181B] text-white flex justify-center',
            ])}
          >
            Changed State
          </div>
          {selectedFiber.changes.state.length > 0 ? (
            selectedFiber.changes.state
              .toSorted((a, b) => b.count - a.count)
              .map((change) => (
                <div
                  key={change.index}
                  className={cn([
                    'flex flex-col justify-between items-center border-t overflow-x-auto border-[#27272A] px-1 py-1 text-wrap bg-[#0A0A0A] text-[10px]',
                  ])}
                >
                  <span className={cn(['text-white '])}>
                    index {change.index}
                  </span>
                  <div
                    className={cn([
                      'rounded-full  text-[#d36cff] pl-1 py-1 text-[8px]',
                    ])}
                  >
                    {change.count}/{selectedFiber.count}x
                  </div>
                </div>
              ))
          ) : (
            <div
              className={cn([
                'flex items-center justify-center h-full bg-[#0A0A0A] text-[#A1A1AA] border-t border-[#27272A]',
              ])}
            >
              No changes
            </div>
          )}
        </div>
        <div
          className={cn([
            'flex flex-col border border-[#27272A] border-l-0 rounded-r-sm overflow-hidden w-1/3',
          ])}
        >
          <div
            className={cn([
              ' text-[14px] font-semibold px-2 py-2 bg-[#18181B] text-white flex justify-center',
            ])}
          >
            Changed Context
          </div>
          {selectedFiber.changes.context.length > 0 ? (
            selectedFiber.changes.context

              .toSorted((a, b) => b.count - a.count)
              .map((change) => (
                <div
                  key={change.name}
                  className={cn([
                    'flex flex-col justify-between items-center border-t  border-[#27272A] px-1 py-1 bg-[#0A0A0A] text-[10px] overflow-x-auto',
                  ])}
                >
                  <span className={cn(['text-white '])}>{change.name}</span>
                  <div
                    className={cn([
                      'rounded-full text-[#d36cff] pl-1 py-1 text-[8px] text-wrap',
                    ])}
                  >
                    {change.count}/{selectedFiber.count}x
                  </div>
                </div>
              ))
          ) : (
            <div
              className={cn([
                'flex items-center justify-center h-full bg-[#0A0A0A] text-[#A1A1AA] border-t border-[#27272A] py-2',
              ])}
            >
              No changes
            </div>
          )}
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/web/views/notifications/slowdown-history.tsx">
import { useEffect, useRef, useState } from 'preact/compat';
import { cn } from '~web/utils/helpers';
import {
  InteractionEvent,
  NotificationEvent,
  getComponentName,
  getEventSeverity,
  getTotalTime,
  useNotificationsContext,
} from './data';
import {
  ClearIcon,
  KeyboardIcon,
  PointerIcon,
  TrendingDownIcon,
} from './icons';
import { Popover } from './popover';
import { iife } from '~core/notifications/performance-utils';
import { toolbarEventStore } from '~core/notifications/event-tracking';
import { CollapsedDroppedFrame, CollapsedItem } from './collapsed-event';

const useFlashManager = (events: NotificationEvent[]) => {
  const prevEventsRef = useRef<NotificationEvent[]>([]);
  const [newEventIds, setNewEventIds] = useState<Set<string>>(new Set());
  const isInitialMount = useRef(true);

  useEffect(() => {
    if (isInitialMount.current) {
      isInitialMount.current = false;
      prevEventsRef.current = events;
      return;
    }

    const currentIds = new Set(events.map((e) => e.id));
    const prevIds = new Set(prevEventsRef.current.map((e) => e.id));

    const newIds = new Set<string>();
    currentIds.forEach((id) => {
      if (!prevIds.has(id)) {
        newIds.add(id);
      }
    });

    if (newIds.size > 0) {
      setNewEventIds(newIds);
      setTimeout(() => {
        setNewEventIds(new Set());
      }, 2000);
    }

    prevEventsRef.current = events;
  }, [events]);

  return (id: string) => newEventIds.has(id);
};

const useFlash = ({ shouldFlash }: { shouldFlash: boolean }) => {
  const [isFlashing, setIsFlashing] = useState(shouldFlash);
  useEffect(() => {
    if (shouldFlash) {
      setIsFlashing(true);
      const timer = setTimeout(() => {
        setIsFlashing(false);
      }, 1000);
      return () => clearTimeout(timer);
    }
  }, [shouldFlash]);

  return isFlashing;
};

export const SlowdownHistoryItem = ({
  event,
  shouldFlash,
}: {
  event: NotificationEvent;
  shouldFlash: boolean;
}) => {
  const { notificationState, setNotificationState } = useNotificationsContext();

  const severity = getEventSeverity(event);

  const isFlashing = useFlash({ shouldFlash });

  switch (event.kind) {
    case 'interaction': {
      return (
        <button
          onClick={() => {
            setNotificationState((prev) => ({
              ...prev,
              selectedEvent: event,
              route: 'render-visualization',
              selectedFiber: null,
            }));
          }}
          className={cn([
            'pl-2 py-1.5  text-sm flex w-full items-center rounded-sm hover:bg-[#18181B] relative overflow-hidden',
            event.id === notificationState.selectedEvent?.id && 'bg-[#18181B]',
            isFlashing &&
              'after:absolute after:inset-0 after:bg-purple-500/30 after:animate-[fadeOut_1s_ease-out_forwards]',
          ])}
        >
          <div
            className={cn([
              'w-4/5 flex items-center justify-start h-full gap-x-1.5',
            ])}
          >
            <span className={cn(['min-w-fit text-xs'])}>
              {iife(() => {
                switch (event.type) {
                  case 'click': {
                    return <PointerIcon size={14} />;
                  }
                  case 'keyboard': {
                    return <KeyboardIcon size={14} />;
                  }
                }
              })}
            </span>

            <span className={cn(['text-xs pr-1 truncate'])}>
              {getComponentName(event.componentPath)}
            </span>
          </div>
          <div
            className={cn([' min-w-fit flex justify-end items-center ml-auto'])}
          >
            <div
              style={{
                lineHeight: '10px',
              }}
              className={cn([
                'gap-x-0.5 w-fit flex items-end justify-center h-full text-white px-1 py-1 rounded-sm font-semibold text-[10px]',
                severity === 'low' && 'bg-green-500/50',
                severity === 'needs-improvement' && 'bg-[#b77116] text-[10px]',
                severity === 'high' && 'bg-[#b94040]',
              ])}
            >
              <div
                style={{
                  lineHeight: '10px',
                }}
                className={cn(['text-[10px] text-white flex items-end'])}
              >
                {getTotalTime(event.timing).toFixed(0)}ms
              </div>
            </div>
          </div>
        </button>
      );
    }
    case 'dropped-frames': {
      return (
        <button
          onClick={() => {
            setNotificationState((prev) => ({
              ...prev,
              selectedEvent: event,
              // explicitly force back to render-visualization since the user might get confused when they don't see the detailed view immediately when clicking the view
              route: 'render-visualization',
              selectedFiber: null,
            }));
          }}
          className={cn([
            'pl-2 py-1.5  w-full text-sm flex items-center rounded-sm hover:bg-[#18181B] relative overflow-hidden',
            event.id === notificationState.selectedEvent?.id && 'bg-[#18181B]',
            isFlashing &&
              'after:absolute after:inset-0 after:bg-purple-500/30 after:animate-[fadeOut_1s_ease-out_forwards]',
          ])}
        >
          <div
            className={cn([
              'w-4/5 flex items-center justify-start h-full text-xs truncate',
            ])}
          >
            <TrendingDownIcon size={14} className="mr-1.5" /> FPS Drop
          </div>
          <div
            className={cn([' min-w-fit flex justify-end items-center ml-auto'])}
          >
            <div
              style={{
                lineHeight: '10px',
              }}
              className={cn([
                'w-fit flex items-center justify-center h-full text-white px-1 py-1 rounded-sm text-[10px] font-bold',
                severity === 'low' && 'bg-green-500/60',
                severity === 'needs-improvement' && 'bg-[#b77116] text-[10px]',
                severity === 'high' && 'bg-[#b94040]',
              ])}
            >
              {event.fps} FPS
            </div>
          </div>
        </button>
      );
    }
  }
};

type CollapsedKeyboardInput = {
  kind: 'collapsed-keyboard';
  events: Array<InteractionEvent>;
  timestamp: number;
};

type HistoryEvent =
  | {
      kind: 'single';
      event: NotificationEvent;
      timestamp: number;
    }
  | CollapsedKeyboardInput
  | CollapsedDroppedFrame;

const collapseEvents = (events: Array<NotificationEvent>) => {
  const newEvents = events.reduce<Array<HistoryEvent>>((prev, curr) => {
    const lastEvent = prev.at(-1);
    if (!lastEvent) {
      return [
        {
          kind: 'single',
          event: curr,
          timestamp: curr.timestamp,
        },
      ];
    }

    switch (lastEvent.kind) {
      case 'collapsed-keyboard': {
        if (
          curr.kind === 'interaction' &&
          curr.type === 'keyboard' &&
          // must be on the same semantic component, it would be ideal to compare on fiberId, but i digress
          curr.componentPath.join('-') ===
            lastEvent.events[0].componentPath.join('-')
        ) {
          const eventsWithoutLast = prev.filter((e) => e !== lastEvent);

          return [
            ...eventsWithoutLast,
            {
              kind: 'collapsed-keyboard',
              events: [...lastEvent.events, curr],
              timestamp: Math.max(
                ...[...lastEvent.events, curr].map((e) => e.timestamp),
              ),
            },
          ];
        }

        return [
          ...prev,
          {
            kind: 'single',
            event: curr,
            timestamp: curr.timestamp,
          },
        ];
      }
      case 'single': {
        // if its a keyboard input on the same element
        if (
          lastEvent.event.kind === 'interaction' &&
          lastEvent.event.type === 'keyboard' &&
          curr.kind === 'interaction' &&
          curr.type === 'keyboard' &&
          lastEvent.event.componentPath.join('-') ===
            curr.componentPath.join('-')
        ) {
          const eventsWithoutLast = prev.filter((e) => e !== lastEvent);
          return [
            ...eventsWithoutLast,
            {
              kind: 'collapsed-keyboard',
              events: [lastEvent.event, curr],
              timestamp: Math.max(lastEvent.event.timestamp, curr.timestamp),
            },
          ];
        }
        if (
          lastEvent.event.kind === 'dropped-frames' &&
          curr.kind === 'dropped-frames'
        ) {
          const eventsWithoutLast = prev.filter((e) => e !== lastEvent);

          return [
            ...eventsWithoutLast,
            {
              kind: 'collapsed-frame-drops',
              events: [lastEvent.event, curr],
              timestamp: Math.max(lastEvent.event.timestamp, curr.timestamp),
            },
          ];
        }
        return [
          ...prev,
          {
            kind: 'single',
            event: curr,
            timestamp: curr.timestamp,
          },
        ];
      }
      case 'collapsed-frame-drops': {
        if (curr.kind === 'dropped-frames') {
          const eventsWithoutLast = prev.filter((e) => e !== lastEvent);
          return [
            ...eventsWithoutLast,
            {
              kind: 'collapsed-frame-drops',
              events: [...lastEvent.events, curr],
              timestamp: Math.max(
                ...[...lastEvent.events, curr].map((e) => e.timestamp),
              ),
            },
          ];
        }
        return [
          ...prev,
          {
            kind: 'single',
            event: curr,
            timestamp: curr.timestamp,
          },
        ];
      }
    }
  }, []);
  return newEvents;
};

export const useLaggedEvents = (lagMs = 150) => {
  const { notificationState } = useNotificationsContext();
  const [laggedEvents, setLaggedEvents] = useState(notificationState.events);

  // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>
  useEffect(() => {
    setTimeout(() => {
      setLaggedEvents(notificationState.events);
    }, lagMs);
  }, [notificationState.events]);
  return [laggedEvents, setLaggedEvents] as const;
};

export const SlowdownHistory = () => {
  const { notificationState, setNotificationState } = useNotificationsContext();
  const shouldFlash = useFlashManager(notificationState.events);
  const [laggedEvents, setLaggedEvents] = useLaggedEvents();
  // this is to avoid a flicker from our overlapping events deduping logic. This should be handled downstream, but this simplifies logic for now
  const collapsedEvents = collapseEvents(laggedEvents).toSorted(
    (a, b) => b.timestamp - a.timestamp,
  );

  return (
    <div
      className={cn([
        `w-full h-full gap-y-2 flex flex-col border-r border-[#27272A] overflow-y-auto`,
      ])}
    >
      <div
        className={cn([
          'text-sm text-[#65656D] pl-3 pr-1 w-full flex items-center justify-between',
        ])}
      >
        <span>History</span>
        <Popover
          wrapperProps={{
            className: 'h-full flex items-center justify-center ml-auto',
          }}
          triggerContent={
            <button
              className={cn(['hover:bg-[#18181B] rounded-full p-2'])}
              onClick={() => {
                toolbarEventStore.getState().actions.clear();
                setNotificationState((prev) => ({
                  ...prev,
                  selectedEvent: null,
                  selectedFiber: null,
                  route:
                    prev.route === 'other-visualization'
                      ? 'other-visualization'
                      : 'render-visualization',
                }));
                setLaggedEvents([]);
              }}
            >
              <ClearIcon className={cn([''])} size={16} />
            </button>
          }
        >
          <div className={cn(['w-full flex justify-center'])}>
            Clear all events
          </div>
        </Popover>
      </div>
      <div className={cn(['flex flex-col px-1 gap-y-1'])}>
        {collapsedEvents.length === 0 && (
          <div
            className={cn([
              'flex items-center justify-center text-zinc-500 text-sm py-4',
            ])}
          >
            No Events
          </div>
        )}
        {collapsedEvents.map((historyItem) =>
          iife(() => {
            switch (historyItem.kind) {
              case 'collapsed-keyboard': {
                return (
                  <CollapsedItem shouldFlash={shouldFlash} item={historyItem} />
                );
              }
              case 'single': {
                return (
                  <SlowdownHistoryItem
                    key={historyItem.event.id}
                    event={historyItem.event}
                    shouldFlash={shouldFlash(historyItem.event.id)}
                  />
                );
              }
              case 'collapsed-frame-drops': {
                return (
                  <CollapsedItem shouldFlash={shouldFlash} item={historyItem} />
                );
              }
            }
          }),
        )}
      </div>
    </div>
  );
};
</file>

<file path="src/web/views/settings/header.tsx">
import { signalIsSettingsOpen } from '~web/state';
import { cn } from '~web/utils/helpers';

export const HeaderSettings = () => {
  const isSettingsOpen = signalIsSettingsOpen.value;
  return (
    <span
      data-text="Settings"
      className={cn(
        'absolute inset-0 flex items-center',
        'with-data-text',
        'transition-transform duration-300',
        isSettingsOpen ? 'translate-y-0' : '-translate-y-[200%]',
      )}
    />
  );
};
</file>

<file path="src/web/views/toolbar/index.tsx">
import { useSignalEffect } from '@preact/signals';
import {
  useCallback,
  useEffect,
  useLayoutEffect,
  useState,
} from 'preact/hooks';
import {
  type LocalStorageOptions,
  ReactScanInternals,
  Store,
} from '~core/index';
import { Icon } from '~web/components/icon';
import { Toggle } from '~web/components/toggle';
import { signalWidgetViews } from '~web/state';
import { cn, readLocalStorage, saveLocalStorage } from '~web/utils/helpers';
import { constant } from '~web/utils/preact/constant';
import { FPSMeter } from '~web/widget/fps-meter';
import { getEventSeverity } from '../notifications/data';
import { Notification } from '../notifications/icons';
import { useAppNotifications } from '../notifications/notifications';

export const Toolbar = constant(() => {
  const events = useAppNotifications();
  const [laggedEvents, setLaggedEvents] = useState(events);

  useEffect(() => {
    const timeout = setTimeout(() => {
      setLaggedEvents(events);
      // 500 + buffer to never see intermediary state
      // todo: check if we still need this large of buffer
    }, 500 + 100);
    return () => {
      clearTimeout(timeout);
    };
  }, [events]);

  const inspectState = Store.inspectState;
  const isInspectActive = inspectState.value.kind === 'inspecting';
  const isInspectFocused = inspectState.value.kind === 'focused';

  const [seenEvents, setSeenEvents] = useState<Array<string>>([]);

  const onToggleInspect = useCallback(() => {
    const currentState = Store.inspectState.value;

    switch (currentState.kind) {
      case 'inspecting': {
        signalWidgetViews.value = {
          view: 'none',
        };
        Store.inspectState.value = {
          kind: 'inspect-off',
        };
        return;
      }

      case 'focused': {
        signalWidgetViews.value = {
          view: 'inspector',
        };
        Store.inspectState.value = {
          kind: 'inspecting',
          hoveredDomElement: null,
        };
        return;
      }
      // todo: auto select the root fibers first stateNode, and tell the user to select the element
      case 'inspect-off': {
        signalWidgetViews.value = {
          view: 'none',
        };
        Store.inspectState.value = {
          kind: 'inspecting',
          hoveredDomElement: null,
        };
        return;
      }
      case 'uninitialized': {
        return;
      }
    }
  }, []);

  const onToggleActive = useCallback((e: Event) => {
    e.preventDefault();
    e.stopPropagation();

    if (!ReactScanInternals.instrumentation) {
      return;
    }
    // todo: set a single source of truth
    const isPaused = !ReactScanInternals.instrumentation.isPaused.value;
    ReactScanInternals.instrumentation.isPaused.value = isPaused;
    const existingLocalStorageOptions =
      readLocalStorage<LocalStorageOptions>('react-scan-options');
    saveLocalStorage('react-scan-options', {
      ...existingLocalStorageOptions,
      enabled: !isPaused,
    });
  }, []);

  useSignalEffect(() => {
    const state = Store.inspectState.value;
    if (state.kind === 'uninitialized') {
      Store.inspectState.value = {
        kind: 'inspect-off',
      };
    }
  });

  let inspectIcon = null;
  let inspectColor = '#999';

  if (isInspectActive) {
    inspectIcon = <Icon name="icon-inspect" />;
    inspectColor = '#8e61e3';
  } else if (isInspectFocused) {
    inspectIcon = <Icon name="icon-focus" />;
    inspectColor = '#8e61e3';
  } else {
    inspectIcon = <Icon name="icon-inspect" />;
    inspectColor = '#999';
  }

  // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>
  useLayoutEffect(() => {
    if (signalWidgetViews.value.view !== 'notifications') {
      return;
    }
    const ids = new Set(events.map((event) => event.id));
    setSeenEvents([...ids.values()]);
  }, [events.length, signalWidgetViews.value.view]);

  return (
    <div className="flex max-h-9 min-h-9 flex-1 items-stretch overflow-hidden">
      <div className="h-full flex items-center min-w-fit">
        <button
          type="button"
          id="react-scan-inspect-element"
          title="Inspect element"
          onClick={onToggleInspect}
          className="button flex items-center justify-center h-full w-full pl-3 pr-2.5"
          style={{ color: inspectColor }}
        >
          {inspectIcon}
        </button>
      </div>

      <div className="h-full flex items-center justify-center">
        <button
          type="button"
          id="react-scan-notifications"
          onClick={() => {
            if (Store.inspectState.value.kind !== 'inspect-off') {
              Store.inspectState.value = {
                kind: 'inspect-off',
              };
            }
            switch (signalWidgetViews.value.view) {
              case 'inspector': {
                Store.inspectState.value = {
                  kind: 'inspect-off',
                };

                const ids = new Set(events.map((event) => event.id));
                setSeenEvents([...ids.values()]);
                signalWidgetViews.value = {
                  view: 'notifications',
                };
                return;
              }
              case 'notifications': {
                signalWidgetViews.value = {
                  view: 'none',
                };
                return;
              }
              case 'none': {
                const ids = new Set(events.map((event) => event.id));
                setSeenEvents([...ids.values()]);
                signalWidgetViews.value = {
                  view: 'notifications',
                };
                return;
              }
            }
          }}
          className="button flex items-center justify-center h-full pl-2.5 pr-2.5"
          style={{ color: inspectColor }}
        >
          <Notification
            events={laggedEvents
              .filter((event) => !seenEvents.includes(event.id))
              .map((event) => getEventSeverity(event) === 'high')}
            size={16}
            className={cn([
              'text-[#999]',
              signalWidgetViews.value.view === 'notifications' &&
                'text-[#8E61E3]',
            ])}
          />
        </button>
      </div>

      <Toggle
        checked={!ReactScanInternals.instrumentation?.isPaused.value}
        onChange={onToggleActive}
        className="place-self-center"
      />

      {/* todo add back showFPS*/}
      {ReactScanInternals.options.value.showFPS && <FPSMeter />}
    </div>
  );
});
</file>

<file path="src/web/views/index.tsx">
import { type ReadonlySignal, computed } from '@preact/signals';
import type { ReactNode } from 'preact/compat';
import { Store } from '~core/index';
import { signalWidgetViews } from '~web/state';
import { cn } from '~web/utils/helpers';
import { Header } from '~web/widget/header';
import { ViewInspector } from './inspector';
import { Toolbar } from './toolbar';
import { NotificationWrapper } from './notifications/notifications';

const isInspecting = computed(
  () => Store.inspectState.value.kind === 'inspecting',
);

const headerClassName = computed(() =>
  cn(
    'relative',
    'flex-1',
    'flex flex-col',
    'rounded-t-lg',
    'overflow-hidden',
    'opacity-100',
    'transition-[opacity]',
    isInspecting.value && 'opacity-0 duration-0 delay-0',
  ),
);

const isInspectorViewOpen = computed(
  () => signalWidgetViews.value.view === 'inspector',
);
const isNotificationsViewOpen = computed(
  () => signalWidgetViews.value.view === 'notifications',
);

export const Content = () => {
  return (
    <div
      className={cn(
        'flex flex-1 flex-col',
        'overflow-hidden z-10',
        'rounded-lg',
        'bg-black',
        'opacity-100',
        'transition-[border-radius]',
        'peer-hover/left:rounded-l-none',
        'peer-hover/right:rounded-r-none',
        'peer-hover/top:rounded-t-none',
        'peer-hover/bottom:rounded-b-none',
      )}
    >
      <div className={headerClassName}>
        <Header />
        <div
          className={cn(
            'relative',
            'flex-1 flex',
            'text-white',
            'bg-[#0A0A0A]',
            'transition-opacity delay-150',
            'overflow-hidden',
            'border-b border-[#222]',
          )}
        >
          <ContentView isOpen={isInspectorViewOpen}>
            <ViewInspector />
          </ContentView>

          <ContentView isOpen={isNotificationsViewOpen}>
            <NotificationWrapper />
          </ContentView>
        </div>
      </div>
      <Toolbar />
    </div>
  );
};

interface ContentViewProps {
  isOpen: ReadonlySignal<boolean>;
  children: ReactNode;
}

const ContentView = ({ isOpen, children }: ContentViewProps) => {
  return (
    <div
      className={cn(
        'flex-1',
        'opacity-0',
        'overflow-y-auto overflow-x-hidden',
        'transition-opacity delay-0',
        'pointer-events-none',
        isOpen.value && 'opacity-100 delay-150 pointer-events-auto',
      )}
    >
      <div className="absolute inset-0 flex">{children}</div>
    </div>
  );
};
</file>

<file path="src/web/widget/fps-meter.tsx">
import { useEffect, useState } from 'preact/hooks';
import { getFPS } from '~core/instrumentation';
import { cn } from '~web/utils/helpers';

export const FpsMeterInner = ({fps}:{fps: number}) => {


  const getColor = (fps: number) => {
    if (fps < 30) return '#EF4444';
    if (fps < 50) return '#F59E0B';
    return 'rgb(214,132,245)';
  };

  return (
    <div
      className={cn(
        'flex items-center gap-x-1 px-2 w-full',
        'h-6',
        'rounded-md',
        'font-mono leading-none',
        'bg-[#141414]',
        'ring-1 ring-white/[0.08]',
      )}
    >
      <div
        style={{ color: getColor(fps) }}
        className="text-sm font-semibold tracking-wide transition-colors ease-in-out w-full flex justify-center items-center"
      >
        {fps}
      </div>
      <span className="text-white/30 text-[11px] font-medium tracking-wide ml-auto min-w-fit">
        FPS
      </span>
    </div>
  );
};


export const FPSMeter = () => {
  const [fps, setFps] = useState<null | number>(null);

  useEffect(() => {
    const intervalId = setInterval(() => {
      setFps(getFPS());
    }, 200);

    return () => clearInterval(intervalId);
  }, []);

  return (
    <div
      className={cn(
        'flex items-center justify-end gap-x-2 px-1 ml-1 w-[72px]',
        'whitespace-nowrap text-sm text-white',
      )}
    >
      {/* fixme: default fps state*/}
      {fps === null ? <></> : <FpsMeterInner fps={fps} />}
    </div>
  );
};
</file>

<file path="src/web/widget/header.tsx">
import { useEffect, useState } from 'preact/hooks';
import { Store } from '~core/index';
import { Icon } from '~web/components/icon';
import { useDelayedValue } from '~web/hooks/use-delayed-value';
import { signalWidgetViews } from '~web/state';
import { cn } from '~web/utils/helpers';
import { HeaderInspect } from '~web/views/inspector/header';
import { getOverrideMethods } from '~web/views/inspector/utils';

// const REPLAY_DELAY_MS = 300;

export const BtnReplay = () => {
  // const refTimeout = useRef<TTimer>();
  // const replayState = useRef({
  //   isReplaying: false,
  //   toggleDisabled: (disabled: boolean, button: HTMLElement) => {
  //     button.classList[disabled ? 'add' : 'remove']('disabled');
  //   },
  // });

  const [canEdit, setCanEdit] = useState(false);

  useEffect(() => {
    const { overrideProps } = getOverrideMethods();
    const canEdit = !!overrideProps;

    requestAnimationFrame(() => {
      setCanEdit(canEdit);
    });
  }, []);

  // const handleReplay = (e: MouseEvent) => {
  //   e.stopPropagation();
  //   const { overrideProps, overrideHookState } = getOverrideMethods();
  //   const state = replayState.current;
  //   const button = e.currentTarget as HTMLElement;

  //   const inspectState = Store.inspectState.value;
  //   if (state.isReplaying || inspectState.kind !== 'focused') return;

  //   const { parentCompositeFiber } = getCompositeComponentFromElement(
  //     inspectState.focusedDomElement,
  //   );
  //   if (!parentCompositeFiber || !overrideProps || !overrideHookState) return;

  //   state.isReplaying = true;
  //   state.toggleDisabled(true, button);

  //   void replayComponent(parentCompositeFiber)
  //     .catch(() => void 0)
  //     .finally(() => {
  //       clearTimeout(refTimeout.current);
  //       if (document.hidden) {
  //         state.isReplaying = false;
  //         state.toggleDisabled(false, button);
  //       } else {
  //         refTimeout.current = setTimeout(() => {
  //           state.isReplaying = false;
  //           state.toggleDisabled(false, button);
  //         }, REPLAY_DELAY_MS);
  //       }
  //     });
  // };

  if (!canEdit) return null;

  return (
    <button
      type="button"
      title="Replay component"
      // onClick={handleReplay}
      className="react-scan-replay-button"
    >
      <Icon name="icon-replay" />
    </button>
  );
};

// const useSubscribeFocusedFiber = (onUpdate: () => void) => {
//   // biome-ignore lint/correctness/useExhaustiveDependencies: no deps
//   useEffect(() => {
//     const subscribe = () => {
//       if (Store.inspectState.value.kind !== 'focused') {
//         return;
//       }
//       onUpdate();
//     };

//     const unSubReportTime = Store.lastReportTime.subscribe(subscribe);
//     const unSubState = Store.inspectState.subscribe(subscribe);
//     return () => {
//       unSubReportTime();
//       unSubState();
//     };
//   }, []);
// };

export const Header = () => {
  const isInitialView = useDelayedValue(
    Store.inspectState.value.kind === 'focused',
    150,
    0,
  );
  const handleClose = () => {
    signalWidgetViews.value = {
      view: 'none',
    };
    Store.inspectState.value = {
      kind: 'inspect-off',
    };
  };

  const isHeaderIsNotifications =
    signalWidgetViews.value.view === 'notifications';

  if (isHeaderIsNotifications) {
    return;
  }

  return (
    <div className="react-scan-header">
      <div className="relative flex-1 h-full">
        <div
          className={cn(
            'react-scan-header-item is-visible',
            !isInitialView && '!duration-0',
          )}
        >
          <HeaderInspect />
        </div>
      </div>

      {/* {Store.inspectState.value.kind !== 'inspect-off' && <BtnReplay />} */}
      <button
        type="button"
        title="Close"
        className="react-scan-close-button"
        onClick={handleClose}
      >
        <Icon name="icon-close" />
      </button>
    </div>
  );
};
</file>

<file path="src/web/widget/helpers.ts">
import { MIN_SIZE, SAFE_AREA } from '../constants';
import type { Corner, Position, ResizeHandleProps, Size } from './types';

class WindowDimensions {
  maxWidth: number;
  maxHeight: number;

  constructor(
    public width: number,
    public height: number,
  ) {
    this.maxWidth = width - SAFE_AREA * 2;
    this.maxHeight = height - SAFE_AREA * 2;
  }

  rightEdge(width: number): number {
    return this.width - width - SAFE_AREA;
  }

  bottomEdge(height: number): number {
    return this.height - height - SAFE_AREA;
  }

  isFullWidth(width: number): boolean {
    return width >= this.maxWidth;
  }

  isFullHeight(height: number): boolean {
    return height >= this.maxHeight;
  }
}

let cachedWindowDimensions: WindowDimensions | undefined;

export const getWindowDimensions = () => {
  const currentWidth = window.innerWidth;
  const currentHeight = window.innerHeight;

  if (
    cachedWindowDimensions &&
    cachedWindowDimensions.width === currentWidth &&
    cachedWindowDimensions.height === currentHeight
  ) {
    return cachedWindowDimensions;
  }

  cachedWindowDimensions = new WindowDimensions(currentWidth, currentHeight);

  return cachedWindowDimensions;
};

export const getOppositeCorner = (
  position: ResizeHandleProps['position'],
  currentCorner: Corner,
  isFullScreen: boolean,
  isFullWidth?: boolean,
  isFullHeight?: boolean,
): Corner => {
  // For full screen mode
  if (isFullScreen) {
    if (position === 'top-left') return 'bottom-right';
    if (position === 'top-right') return 'bottom-left';
    if (position === 'bottom-left') return 'top-right';
    if (position === 'bottom-right') return 'top-left';

    const [vertical, horizontal] = currentCorner.split('-');
    if (position === 'left') return `${vertical}-right` as Corner;
    if (position === 'right') return `${vertical}-left` as Corner;
    if (position === 'top') return `bottom-${horizontal}` as Corner;
    if (position === 'bottom') return `top-${horizontal}` as Corner;
  }

  // For full width mode
  if (isFullWidth) {
    if (position === 'left')
      return `${currentCorner.split('-')[0]}-right` as Corner;
    if (position === 'right')
      return `${currentCorner.split('-')[0]}-left` as Corner;
  }

  // For full height mode
  if (isFullHeight) {
    if (position === 'top')
      return `bottom-${currentCorner.split('-')[1]}` as Corner;
    if (position === 'bottom')
      return `top-${currentCorner.split('-')[1]}` as Corner;
  }

  return currentCorner;
};

export const calculatePosition = (
  corner: Corner,
  width: number,
  height: number,
): Position => {
  const windowWidth = window.innerWidth;
  const windowHeight = window.innerHeight;

  // Check if widget is minimized
  const isMinimized = width === MIN_SIZE.width;

  // Only bound dimensions if minimized
  const effectiveWidth = isMinimized
    ? width
    : Math.min(width, windowWidth - SAFE_AREA * 2);
  const effectiveHeight = isMinimized
    ? height
    : Math.min(height, windowHeight - SAFE_AREA * 2);

  // Calculate base positions
  let x: number;
  let y: number;

  switch (corner) {
    case 'top-right':
      x = windowWidth - effectiveWidth - SAFE_AREA;
      y = SAFE_AREA;
      break;
    case 'bottom-right':
      x = windowWidth - effectiveWidth - SAFE_AREA;
      y = windowHeight - effectiveHeight - SAFE_AREA;
      break;
    case 'bottom-left':
      x = SAFE_AREA;
      y = windowHeight - effectiveHeight - SAFE_AREA;
      break;
    case 'top-left':
      x = SAFE_AREA;
      y = SAFE_AREA;
      break;
    default:
      x = SAFE_AREA;
      y = SAFE_AREA;
      break;
  }

  // Only ensure positions are within bounds if minimized
  if (isMinimized) {
    x = Math.max(
      SAFE_AREA,
      Math.min(x, windowWidth - effectiveWidth - SAFE_AREA),
    );
    y = Math.max(
      SAFE_AREA,
      Math.min(y, windowHeight - effectiveHeight - SAFE_AREA),
    );
  }

  return { x, y };
};

const positionMatchesCorner = (
  position: ResizeHandleProps['position'],
  corner: Corner,
): boolean => {
  const [vertical, horizontal] = corner.split('-');
  return position !== vertical && position !== horizontal;
};

export const getHandleVisibility = (
  position: ResizeHandleProps['position'],
  corner: Corner,
  isFullWidth: boolean,
  isFullHeight: boolean,
): boolean => {
  if (isFullWidth && isFullHeight) {
    return true;
  }

  // Normal state
  if (!isFullWidth && !isFullHeight) {
    return positionMatchesCorner(position, corner);
  }

  // Full width state
  if (isFullWidth) {
    return position !== corner.split('-')[0];
  }

  // Full height state
  if (isFullHeight) {
    return position !== corner.split('-')[1];
  }

  return false;
};

export const calculateBoundedSize = (
  currentSize: number,
  delta: number,
  isWidth: boolean,
): number => {
  const min = isWidth ? MIN_SIZE.width : MIN_SIZE.initialHeight;
  const max = isWidth
    ? getWindowDimensions().maxWidth
    : getWindowDimensions().maxHeight;

  const newSize = currentSize + delta;
  return Math.min(Math.max(min, newSize), max);
};

export const calculateNewSizeAndPosition = (
  position: ResizeHandleProps['position'],
  initialSize: Size,
  initialPosition: Position,
  deltaX: number,
  deltaY: number,
): { newSize: Size; newPosition: Position } => {
  const maxWidth = window.innerWidth - SAFE_AREA * 2;
  const maxHeight = window.innerHeight - SAFE_AREA * 2;

  let newWidth = initialSize.width;
  let newHeight = initialSize.height;
  let newX = initialPosition.x;
  let newY = initialPosition.y;

  // horizontal resize
  if (position.includes('right')) {
    // Check if we have enough space on the right
    const availableWidth = window.innerWidth - initialPosition.x - SAFE_AREA;
    const proposedWidth = Math.min(initialSize.width + deltaX, availableWidth);
    newWidth = Math.min(maxWidth, Math.max(MIN_SIZE.width, proposedWidth));
  }
  if (position.includes('left')) {
    // Check if we have enough space on the left
    const availableWidth = initialPosition.x + initialSize.width - SAFE_AREA;
    const proposedWidth = Math.min(initialSize.width - deltaX, availableWidth);
    newWidth = Math.min(maxWidth, Math.max(MIN_SIZE.width, proposedWidth));
    newX = initialPosition.x - (newWidth - initialSize.width);
  }

  // vertical resize
  if (position.includes('bottom')) {
    // Check if we have enough space at the bottom
    const availableHeight = window.innerHeight - initialPosition.y - SAFE_AREA;
    const proposedHeight = Math.min(
      initialSize.height + deltaY,
      availableHeight,
    );
    newHeight = Math.min(
      maxHeight,
      Math.max(MIN_SIZE.initialHeight, proposedHeight),
    );
  }
  if (position.includes('top')) {
    // Check if we have enough space at the top
    const availableHeight = initialPosition.y + initialSize.height - SAFE_AREA;
    const proposedHeight = Math.min(
      initialSize.height - deltaY,
      availableHeight,
    );
    newHeight = Math.min(
      maxHeight,
      Math.max(MIN_SIZE.initialHeight, proposedHeight),
    );
    newY = initialPosition.y - (newHeight - initialSize.height);
  }

  // Ensure position stays within bounds
  newX = Math.max(
    SAFE_AREA,
    Math.min(newX, window.innerWidth - SAFE_AREA - newWidth),
  );
  newY = Math.max(
    SAFE_AREA,
    Math.min(newY, window.innerHeight - SAFE_AREA - newHeight),
  );

  return {
    newSize: { width: newWidth, height: newHeight },
    newPosition: { x: newX, y: newY },
  };
};

export const getClosestCorner = (position: Position): Corner => {
  const windowDims = getWindowDimensions();

  const distances: Record<Corner, number> = {
    'top-left': Math.hypot(position.x, position.y),
    'top-right': Math.hypot(windowDims.maxWidth - position.x, position.y),
    'bottom-left': Math.hypot(position.x, windowDims.maxHeight - position.y),
    'bottom-right': Math.hypot(
      windowDims.maxWidth - position.x,
      windowDims.maxHeight - position.y,
    ),
  };

  let closest: Corner = 'top-left';

  for (const key in distances) {
    if (distances[key as Corner] < distances[closest]) {
      closest = key as Corner;
    }
  }

  return closest;
};

// Helper to determine best corner based on cursor position, widget size, and movement
export const getBestCorner = (
  mouseX: number,
  mouseY: number,
  initialMouseX?: number,
  initialMouseY?: number,
  threshold = 100,
): Corner => {
  const deltaX = initialMouseX !== undefined ? mouseX - initialMouseX : 0;
  const deltaY = initialMouseY !== undefined ? mouseY - initialMouseY : 0;

  const windowCenterX = window.innerWidth / 2;
  const windowCenterY = window.innerHeight / 2;

  // Determine movement direction
  const movingRight = deltaX > threshold;
  const movingLeft = deltaX < -threshold;
  const movingDown = deltaY > threshold;
  const movingUp = deltaY < -threshold;

  // If horizontal movement
  if (movingRight || movingLeft) {
    const isBottom = mouseY > windowCenterY;
    return movingRight
      ? isBottom
        ? 'bottom-right'
        : 'top-right'
      : isBottom
        ? 'bottom-left'
        : 'top-left';
  }

  // If vertical movement
  if (movingDown || movingUp) {
    const isRight = mouseX > windowCenterX;
    return movingDown
      ? isRight
        ? 'bottom-right'
        : 'bottom-left'
      : isRight
        ? 'top-right'
        : 'top-left';
  }

  // If no significant movement, use quadrant-based position
  return mouseX > windowCenterX
    ? mouseY > windowCenterY
      ? 'bottom-right'
      : 'top-right'
    : mouseY > windowCenterY
      ? 'bottom-left'
      : 'top-left';
};
</file>

<file path="src/web/widget/index.tsx">
import { createContext, type JSX } from 'preact';
import { useCallback, useEffect, useRef, useState } from 'preact/hooks';
import { Store } from '~core/index';
import { cn, saveLocalStorage } from '~web/utils/helpers';
import { Content } from '~web/views';
import { ScanOverlay } from '~web/views/inspector/overlay';
import { LOCALSTORAGE_KEY, MIN_SIZE, SAFE_AREA } from '../constants';
import {
  defaultWidgetConfig,
  signalRefWidget,
  signalWidget,
  signalWidgetViews,
  updateDimensions,
} from '../state';
import {
  calculateBoundedSize,
  calculatePosition,
  getBestCorner,
} from './helpers';
import { ResizeHandle } from './resize-handle';

export const Widget = () => {
  const refWidget = useRef<HTMLDivElement | null>(null);
  const refShouldOpen = useRef<boolean>(false);

  const refInitialMinimizedWidth = useRef<number>(0);
  const refInitialMinimizedHeight = useRef<number>(0);

  const updateWidgetPosition = useCallback((shouldSave = true) => {
    if (!refWidget.current) return;

    const { corner } = signalWidget.value;
    let newWidth: number;
    let newHeight: number;

    if (refShouldOpen.current) {
      const lastDims = signalWidget.value.lastDimensions;
      newWidth = calculateBoundedSize(lastDims.width, 0, true);
      newHeight = calculateBoundedSize(lastDims.height, 0, false);
    } else {
      const currentDims = signalWidget.value.dimensions;
      if (currentDims.width > refInitialMinimizedWidth.current) {
        signalWidget.value = {
          ...signalWidget.value,
          lastDimensions: {
            isFullWidth: currentDims.isFullWidth,
            isFullHeight: currentDims.isFullHeight,
            width: currentDims.width,
            height: currentDims.height,
            position: currentDims.position,
          },
        };
      }
      newWidth = refInitialMinimizedWidth.current;
      newHeight = refInitialMinimizedHeight.current;
    }

    const newPosition = calculatePosition(corner, newWidth, newHeight);

    const isTooSmall =
      newWidth < MIN_SIZE.width || newHeight < MIN_SIZE.initialHeight;
    const shouldPersist = shouldSave && !isTooSmall;

    const container = refWidget.current;
    const containerStyle = container.style;

    let rafId: number | null = null;
    const onTransitionEnd = () => {
      updateDimensions();
      container.removeEventListener('transitionend', onTransitionEnd);
      if (rafId) {
        cancelAnimationFrame(rafId);
        rafId = null;
      }
    };

    container.addEventListener('transitionend', onTransitionEnd);
    containerStyle.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';

    rafId = requestAnimationFrame(() => {
      containerStyle.width = `${newWidth}px`;
      containerStyle.height = `${newHeight}px`;
      containerStyle.transform = `translate3d(${newPosition.x}px, ${newPosition.y}px, 0)`;
      rafId = null;
    });

    const newDimensions = {
      isFullWidth: newWidth >= window.innerWidth - SAFE_AREA * 2,
      isFullHeight: newHeight >= window.innerHeight - SAFE_AREA * 2,
      width: newWidth,
      height: newHeight,
      position: newPosition,
    };

    signalWidget.value = {
      corner,
      dimensions: newDimensions,
      lastDimensions: refShouldOpen
        ? signalWidget.value.lastDimensions
        : newWidth > refInitialMinimizedWidth.current
          ? newDimensions
          : signalWidget.value.lastDimensions,
      componentsTree: signalWidget.value.componentsTree,
    };

    if (shouldPersist) {
      saveLocalStorage(LOCALSTORAGE_KEY, {
        corner: signalWidget.value.corner,
        dimensions: signalWidget.value.dimensions,
        lastDimensions: signalWidget.value.lastDimensions,
        componentsTree: signalWidget.value.componentsTree,
      });
    }

    updateDimensions();
  }, []);

  const handleDrag = useCallback(
    (e: JSX.TargetedPointerEvent<HTMLDivElement>) => {
      e.preventDefault();

      if (!refWidget.current || (e.target as HTMLElement).closest('button'))
        return;

      const container = refWidget.current;
      const containerStyle = container.style;
      const { dimensions } = signalWidget.value;

      const initialMouseX = e.clientX;
      const initialMouseY = e.clientY;

      const initialX = dimensions.position.x;
      const initialY = dimensions.position.y;

      let currentX = initialX;
      let currentY = initialY;
      let rafId: number | null = null;
      let hasMoved = false;
      let lastMouseX = initialMouseX;
      let lastMouseY = initialMouseY;

      const handlePointerMove = (e: globalThis.PointerEvent) => {
        if (rafId) return;

        hasMoved = true;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;

        rafId = requestAnimationFrame(() => {
          const deltaX = lastMouseX - initialMouseX;
          const deltaY = lastMouseY - initialMouseY;

          currentX = Number(initialX) + deltaX;
          currentY = Number(initialY) + deltaY;

          /* [CURSOR GENERATED] Anti-blur fix:
           * Changed from transition: 'all' and transform: translate() to:
           * 1. transition: none - Prevents interpolation blur during drag
           * 2. translate3d - Forces GPU acceleration for crisp text
           */
          containerStyle.transition = 'none';
          containerStyle.transform = `translate3d(${currentX}px, ${currentY}px, 0)`;
          rafId = null;
        });
      };

      const handlePointerEnd = () => {
        if (!container) return;

        if (rafId) {
          cancelAnimationFrame(rafId);
          rafId = null;
        }

        document.removeEventListener('pointermove', handlePointerMove);
        document.removeEventListener('pointerup', handlePointerEnd);

        // Calculate total movement distance
        const totalDeltaX = Math.abs(lastMouseX - initialMouseX);
        const totalDeltaY = Math.abs(lastMouseY - initialMouseY);
        const totalMovement = Math.sqrt(
          totalDeltaX * totalDeltaX + totalDeltaY * totalDeltaY,
        );

        // Only consider it a move if we moved more than 60 pixels
        if (!hasMoved || totalMovement < 60) return;

        const newCorner = getBestCorner(
          lastMouseX,
          lastMouseY,
          initialMouseX,
          initialMouseY,
          Store.inspectState.value.kind === 'focused' ? 80 : 40,
        );

        if (newCorner === signalWidget.value.corner) {
          /* [CURSOR GENERATED] Anti-blur fix:
           * Changed from transition: 'all' to transition: 'transform'
           * to prevent unnecessary property interpolation that was
           * causing text blur during animation
           */
          containerStyle.transition =
            'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
          const currentPosition = signalWidget.value.dimensions.position;
          requestAnimationFrame(() => {
            containerStyle.transform = `translate3d(${currentPosition.x}px, ${currentPosition.y}px, 0)`;
          });

          return;
        }

        const snappedPosition = calculatePosition(
          newCorner,
          dimensions.width,
          dimensions.height,
        );

        if (currentX === initialX && currentY === initialY) return;

        const onTransitionEnd = () => {
          containerStyle.transition = 'none';
          updateDimensions();
          container.removeEventListener('transitionend', onTransitionEnd);
          if (rafId) {
            cancelAnimationFrame(rafId);
            rafId = null;
          }
        };

        container.addEventListener('transitionend', onTransitionEnd);
        containerStyle.transition =
          'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';

        requestAnimationFrame(() => {
          containerStyle.transform = `translate3d(${snappedPosition.x}px, ${snappedPosition.y}px, 0)`;
        });

        signalWidget.value = {
          corner: newCorner,
          dimensions: {
            isFullWidth: dimensions.isFullWidth,
            isFullHeight: dimensions.isFullHeight,
            width: dimensions.width,
            height: dimensions.height,
            position: snappedPosition,
          },
          lastDimensions: signalWidget.value.lastDimensions,
          componentsTree: signalWidget.value.componentsTree,
        };

        saveLocalStorage(LOCALSTORAGE_KEY, {
          corner: newCorner,
          dimensions: signalWidget.value.dimensions,
          lastDimensions: signalWidget.value.lastDimensions,
          componentsTree: signalWidget.value.componentsTree,
        });
      };

      document.addEventListener('pointermove', handlePointerMove);
      document.addEventListener('pointerup', handlePointerEnd);
    },
    [],
  );

  // biome-ignore lint/correctness/useExhaustiveDependencies: no deps
  useEffect(() => {
    if (!refWidget.current) return;

    refWidget.current.style.width = 'min-content';
    refInitialMinimizedHeight.current = 36; // height of the header
    refInitialMinimizedWidth.current = refWidget.current.offsetWidth;

    refWidget.current.style.maxWidth = `calc(100vw - ${SAFE_AREA * 2}px)`;
    refWidget.current.style.maxHeight = `calc(100vh - ${SAFE_AREA * 2}px)`;

    if (Store.inspectState.value.kind !== 'focused') {
      signalWidget.value = {
        ...signalWidget.value,
        dimensions: {
          isFullWidth: false,
          isFullHeight: false,
          width: refInitialMinimizedWidth.current,
          height: refInitialMinimizedHeight.current,
          position: signalWidget.value.dimensions.position,
        },
      };
    }

    signalRefWidget.value = refWidget.current;

    const unsubscribeSignalWidget = signalWidget.subscribe((widget) => {
      if (!refWidget.current) return;

      const { x, y } = widget.dimensions.position;
      const { width, height } = widget.dimensions;
      const container = refWidget.current;

      requestAnimationFrame(() => {
        container.style.transform = `translate3d(${x}px, ${y}px, 0)`;
        container.style.width = `${width}px`;
        container.style.height = `${height}px`;
      });
    });

    const unsubscribeSignalWidgetViews = signalWidgetViews.subscribe(
      (state) => {
        refShouldOpen.current = state.view !== 'none';
        updateWidgetPosition();
      },
    );

    const unsubscribeStoreInspectState = Store.inspectState.subscribe(
      (state) => {
        refShouldOpen.current = state.kind === 'focused';
        updateWidgetPosition();
      },
    );

    const handleWindowResize = () => {
      updateWidgetPosition(true);
    };

    window.addEventListener('resize', handleWindowResize, { passive: true });

    return () => {
      window.removeEventListener('resize', handleWindowResize);
      unsubscribeSignalWidgetViews();
      unsubscribeStoreInspectState();
      unsubscribeSignalWidget();

      saveLocalStorage(LOCALSTORAGE_KEY, {
        ...defaultWidgetConfig,
        corner: signalWidget.value.corner,
      });
    };
  }, []);

  // i don't want to put the ref in state, so this is the solution to force context to propagate it
  const [_, setTriggerRender] = useState(false);
  useEffect(() => {
    setTriggerRender(true);
  }, []);

  return (
    <>
      <ScanOverlay />
      <ToolbarElementContext.Provider value={refWidget.current}>
        <div
          id="react-scan-toolbar"
          dir="ltr"
          ref={refWidget}
          onPointerDown={handleDrag}
          className={cn(
            'fixed inset-0 rounded-lg shadow-lg',
            'flex flex-col',
            'font-mono text-[13px]',
            'user-select-none',
            'opacity-0',
            'cursor-move',
            'z-[124124124124]',
            'animate-fade-in animation-duration-300 animation-delay-300',
            'will-change-transform',
            '[touch-action:none]',
          )}
        >
          <ResizeHandle position="top" />
          <ResizeHandle position="bottom" />
          <ResizeHandle position="left" />
          <ResizeHandle position="right" />
          <Content />
        </div>
      </ToolbarElementContext.Provider>
    </>
  );
};

export const ToolbarElementContext = createContext<HTMLElement | null>(null);
</file>

<file path="src/web/widget/resize-handle.tsx">
import type { JSX } from 'preact';
import { useCallback, useEffect, useRef } from 'preact/hooks';
import { Store } from '~core/index';
import { Icon } from '~web/components/icon';
import {
  LOCALSTORAGE_KEY,
  MIN_CONTAINER_WIDTH,
  MIN_SIZE,
} from '~web/constants';
import {
  signalRefWidget,
  signalWidget,
  signalWidgetViews,
} from '~web/state';
import { cn, saveLocalStorage } from '~web/utils/helpers';
import {
  calculateNewSizeAndPosition,
  calculatePosition,
  getClosestCorner,
  getHandleVisibility,
  getOppositeCorner,
  getWindowDimensions,
} from './helpers';
import type { Corner, ResizeHandleProps } from './types';

export const ResizeHandle = ({ position }: ResizeHandleProps) => {
  const refContainer = useRef<HTMLDivElement>(null);

  const prevWidth = useRef<number | null>(null);
  const prevHeight = useRef<number | null>(null);
  const prevCorner = useRef<Corner | null>(null);

  // biome-ignore lint/correctness/useExhaustiveDependencies: no deps
  useEffect(() => {
    const container = refContainer.current;
    if (!container) return;

    const updateVisibility = () => {
      container.classList.remove('pointer-events-none');

      const isFocused = Store.inspectState.value.kind === 'focused';
      const shouldShow = signalWidgetViews.value.view !== 'none';
      const isVisible =
        (isFocused || shouldShow) &&
        getHandleVisibility(
          position,
          signalWidget.value.corner,
          signalWidget.value.dimensions.isFullWidth,
          signalWidget.value.dimensions.isFullHeight,
        );

      if (isVisible) {
        container.classList.remove(
          'hidden',
          'pointer-events-none',
          'opacity-0',
        );
      } else {
        container.classList.add('hidden', 'pointer-events-none', 'opacity-0');
      }
    };

    const unsubscribeSignalWidget = signalWidget.subscribe((state) => {
      if (
        prevWidth.current !== null &&
        prevHeight.current !== null &&
        prevCorner.current !== null &&
        state.dimensions.width === prevWidth.current &&
        state.dimensions.height === prevHeight.current &&
        state.corner === prevCorner.current
      ) {
        return;
      }

      updateVisibility();

      prevWidth.current = state.dimensions.width;
      prevHeight.current = state.dimensions.height;
      prevCorner.current = state.corner;
    });

    const unsubscribeInspectState = Store.inspectState.subscribe(() => {
      updateVisibility();
    });

    return () => {
      unsubscribeSignalWidget();
      unsubscribeInspectState();
      prevWidth.current = null;
      prevHeight.current = null;
      prevCorner.current = null;
    };
  }, []);

  // biome-ignore lint/correctness/useExhaustiveDependencies: no deps
  const handleResize = useCallback(
    (e: JSX.TargetedPointerEvent<HTMLDivElement>) => {
      e.preventDefault();
      e.stopPropagation();

      const widget = signalRefWidget.value;
      if (!widget) return;

      const containerStyle = widget.style;
      const { dimensions } = signalWidget.value;
      const initialX = e.clientX;
      const initialY = e.clientY;

      const initialWidth = dimensions.width;
      const initialHeight = dimensions.height;
      const initialPosition = dimensions.position;

      signalWidget.value = {
        ...signalWidget.value,
        dimensions: {
          ...dimensions,
          isFullWidth: false,
          isFullHeight: false,
          width: initialWidth,
          height: initialHeight,
          position: initialPosition,
        },
      };

      let rafId: number | null = null;

      const handlePointerMove = (e: PointerEvent) => {
        if (rafId) return;

        containerStyle.transition = 'none';

        rafId = requestAnimationFrame(() => {
          const { newSize, newPosition } = calculateNewSizeAndPosition(
            position,
            { width: initialWidth, height: initialHeight },
            initialPosition,
            e.clientX - initialX,
            e.clientY - initialY,
          );

          containerStyle.transform = `translate3d(${newPosition.x}px, ${newPosition.y}px, 0)`;
          containerStyle.width = `${newSize.width}px`;
          containerStyle.height = `${newSize.height}px`;

          // Adjust components tree width when widget is resized
          const maxTreeWidth = Math.floor(newSize.width - (MIN_CONTAINER_WIDTH / 2));
          const currentTreeWidth = signalWidget.value.componentsTree.width;
          const newTreeWidth = Math.min(
            maxTreeWidth,
            Math.max(MIN_CONTAINER_WIDTH, currentTreeWidth),
          );

          signalWidget.value = {
            ...signalWidget.value,
            dimensions: {
              isFullWidth: false,
              isFullHeight: false,
              width: newSize.width,
              height: newSize.height,
              position: newPosition,
            },
            componentsTree: {
              ...signalWidget.value.componentsTree,
              width: newTreeWidth,
            },
          };

          rafId = null;
        });
      };

      const handlePointerUp = () => {
        if (rafId) {
          cancelAnimationFrame(rafId);
          rafId = null;
        }
        document.removeEventListener('pointermove', handlePointerMove);
        document.removeEventListener('pointerup', handlePointerUp);

        const { dimensions, corner } = signalWidget.value;
        const windowDims = getWindowDimensions();
        const isCurrentFullWidth = windowDims.isFullWidth(dimensions.width);
        const isCurrentFullHeight = windowDims.isFullHeight(dimensions.height);
        const isFullScreen = isCurrentFullWidth && isCurrentFullHeight;

        let newCorner = corner;
        if (isFullScreen || isCurrentFullWidth || isCurrentFullHeight) {
          newCorner = getClosestCorner(dimensions.position);
        }

        const newPosition = calculatePosition(
          newCorner,
          dimensions.width,
          dimensions.height,
        );

        const onTransitionEnd = () => {
          widget.removeEventListener('transitionend', onTransitionEnd);
        };

        widget.addEventListener('transitionend', onTransitionEnd);
        containerStyle.transform = `translate3d(${newPosition.x}px, ${newPosition.y}px, 0)`;

        signalWidget.value = {
          ...signalWidget.value,
          corner: newCorner,
          dimensions: {
            isFullWidth: isCurrentFullWidth,
            isFullHeight: isCurrentFullHeight,
            width: dimensions.width,
            height: dimensions.height,
            position: newPosition,
          },
          lastDimensions: {
            isFullWidth: isCurrentFullWidth,
            isFullHeight: isCurrentFullHeight,
            width: dimensions.width,
            height: dimensions.height,
            position: newPosition,
          },
        };

        saveLocalStorage(LOCALSTORAGE_KEY, {
          corner: newCorner,
          dimensions: signalWidget.value.dimensions,
          lastDimensions: signalWidget.value.lastDimensions,
          componentsTree: signalWidget.value.componentsTree,
        });
      };

      document.addEventListener('pointermove', handlePointerMove, {
        passive: true,
      });
      document.addEventListener('pointerup', handlePointerUp);
    },
    [],
  );

  // biome-ignore lint/correctness/useExhaustiveDependencies: no deps
  const handleDoubleClick = useCallback(
    (e: JSX.TargetedMouseEvent<HTMLDivElement>) => {
      e.preventDefault();
      e.stopPropagation();

      const widget = signalRefWidget.value;
      if (!widget) return;

      const containerStyle = widget.style;
      const { dimensions, corner } = signalWidget.value;
      const windowDims = getWindowDimensions();

      const isCurrentFullWidth = windowDims.isFullWidth(dimensions.width);
      const isCurrentFullHeight = windowDims.isFullHeight(dimensions.height);
      const isFullScreen = isCurrentFullWidth && isCurrentFullHeight;
      const isPartiallyMaximized =
        (isCurrentFullWidth || isCurrentFullHeight) && !isFullScreen;

      let newWidth = dimensions.width;
      let newHeight = dimensions.height;
      const newCorner = getOppositeCorner(
        position,
        corner,
        isFullScreen,
        isCurrentFullWidth,
        isCurrentFullHeight,
      );

      if (position === 'left' || position === 'right') {
        newWidth = isCurrentFullWidth ? dimensions.width : windowDims.maxWidth;
        if (isPartiallyMaximized) {
          newWidth = isCurrentFullWidth ? MIN_SIZE.width : windowDims.maxWidth;
        }
      } else {
        newHeight = isCurrentFullHeight
          ? dimensions.height
          : windowDims.maxHeight;
        if (isPartiallyMaximized) {
          newHeight = isCurrentFullHeight
            ? MIN_SIZE.initialHeight
            : windowDims.maxHeight;
        }
      }

      if (isFullScreen) {
        if (position === 'left' || position === 'right') {
          newWidth = MIN_SIZE.width;
        } else {
          newHeight = MIN_SIZE.initialHeight;
        }
      }

      const newPosition = calculatePosition(newCorner, newWidth, newHeight);
      const newDimensions = {
        isFullWidth: windowDims.isFullWidth(newWidth),
        isFullHeight: windowDims.isFullHeight(newHeight),
        width: newWidth,
        height: newHeight,
        position: newPosition,
      };

      // Adjust components tree width when widget is resized
      const maxTreeWidth = Math.floor(newWidth - MIN_SIZE.width / 2);
      const currentTreeWidth = signalWidget.value.componentsTree.width;
      const defaultWidth = Math.floor(newWidth * 0.3); // Use 30% of window width as default

      const newTreeWidth = isCurrentFullWidth
        ? MIN_CONTAINER_WIDTH
        : (position === 'left' || position === 'right') && !isCurrentFullWidth
          ? Math.min(maxTreeWidth, Math.max(MIN_CONTAINER_WIDTH, defaultWidth))
          : Math.min(
              maxTreeWidth,
              Math.max(MIN_CONTAINER_WIDTH, currentTreeWidth),
            );

      requestAnimationFrame(() => {
        signalWidget.value = {
          corner: newCorner,
          dimensions: newDimensions,
          lastDimensions: dimensions,
          componentsTree: {
            ...signalWidget.value.componentsTree,
            width: newTreeWidth,
          },
        };

        containerStyle.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
        containerStyle.width = `${newWidth}px`;
        containerStyle.height = `${newHeight}px`;
        containerStyle.transform = `translate3d(${newPosition.x}px, ${newPosition.y}px, 0)`;
      });

      saveLocalStorage(LOCALSTORAGE_KEY, {
        corner: newCorner,
        dimensions: newDimensions,
        lastDimensions: dimensions,
        componentsTree: {
          ...signalWidget.value.componentsTree,
          width: newTreeWidth,
        },
      });
    },
    [],
  );

  return (
    <div
      ref={refContainer}
      onPointerDown={handleResize}
      onDblClick={handleDoubleClick}
      className={cn(
        'absolute z-50',
        'flex items-center justify-center',
        'group',
        'transition-colors select-none',
        'peer',
        {
          'resize-left peer/left': position === 'left',
          'resize-right peer/right z-10': position === 'right',
          'resize-top peer/top': position === 'top',
          'resize-bottom peer/bottom': position === 'bottom',
        },
      )}
    >
      <span className="resize-line-wrapper">
        <span className="resize-line">
          <Icon
            name="icon-ellipsis"
            size={18}
            className={cn(
              'text-neutral-400',
              (position === 'left' || position === 'right') && 'rotate-90',
            )}
          />
        </span>
      </span>
    </div>
  );
};
</file>

<file path="src/web/widget/types.ts">
export interface Position {
  x: number;
  y: number;
}

export interface Size {
  width: number;
  height: number;
}

export type Corner = 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';

export interface ResizeHandleProps {
  position: Corner | 'top' | 'bottom' | 'left' | 'right';
}

export interface WidgetDimensions {
  isFullWidth: boolean;
  isFullHeight: boolean;
  width: number;
  height: number;
  position: Position;
}

export interface ComponentsTreeConfig {
  width: number;
}

export interface WidgetConfig {
  corner: Corner;
  dimensions: WidgetDimensions;
  lastDimensions: WidgetDimensions;
  componentsTree: ComponentsTreeConfig;
}

export interface WidgetSettings {
  corner: Corner;
  dimensions: WidgetDimensions;
  lastDimensions: WidgetDimensions;
  componentsTree: ComponentsTreeConfig;
}
</file>

<file path="src/web/constants.ts">
export const SAFE_AREA = 24;
export const MIN_SIZE = {
  width: 550,
  height: 350,
  initialHeight: 400,
} as const;

export const MIN_CONTAINER_WIDTH = 240;

export const LOCALSTORAGE_KEY = 'react-scan-widget-settings-v2';
</file>

<file path="src/web/state.ts">
import { signal } from '@preact/signals';
import {
  LOCALSTORAGE_KEY,
  MIN_CONTAINER_WIDTH,
  MIN_SIZE,
  SAFE_AREA,
} from './constants';
import { IS_CLIENT } from './utils/constants';
import { readLocalStorage, saveLocalStorage } from './utils/helpers';
import type { Corner, WidgetConfig, WidgetSettings } from './widget/types';

export const signalIsSettingsOpen = /* @__PURE__ */ signal(false);
export const signalRefWidget = /* @__PURE__ */ signal<HTMLDivElement | null>(
  null,
);

export const defaultWidgetConfig = {
  corner: 'bottom-right' as Corner,
  dimensions: {
    isFullWidth: false,
    isFullHeight: false,
    width: MIN_SIZE.width,
    height: MIN_SIZE.height,
    position: { x: SAFE_AREA, y: SAFE_AREA },
  },
  lastDimensions: {
    isFullWidth: false,
    isFullHeight: false,
    width: MIN_SIZE.width,
    height: MIN_SIZE.height,
    position: { x: SAFE_AREA, y: SAFE_AREA },
  },
  componentsTree: {
    width: MIN_CONTAINER_WIDTH,
  },
} as WidgetConfig;

export const getInitialWidgetConfig = (): WidgetConfig => {
  const stored = readLocalStorage<WidgetSettings>(LOCALSTORAGE_KEY);
  if (!stored) {
    saveLocalStorage(LOCALSTORAGE_KEY, {
      corner: defaultWidgetConfig.corner,
      dimensions: defaultWidgetConfig.dimensions,
      lastDimensions: defaultWidgetConfig.lastDimensions,
      componentsTree: defaultWidgetConfig.componentsTree,
    });

    return defaultWidgetConfig;
  }

  return {
    corner: stored.corner ?? defaultWidgetConfig.corner,
    dimensions: {
      isFullWidth: false,
      isFullHeight: false,
      width: MIN_SIZE.width,
      height: MIN_SIZE.height,
      position:
        stored.dimensions.position ?? defaultWidgetConfig.dimensions.position,
    },
    lastDimensions: stored.dimensions ?? defaultWidgetConfig.dimensions,
    componentsTree: stored.componentsTree ?? defaultWidgetConfig.componentsTree,
  };
};

export const signalWidget = signal<WidgetConfig>(getInitialWidgetConfig());

export const updateDimensions = (): void => {
  if (!IS_CLIENT) return;

  const { dimensions } = signalWidget.value;
  const { width, height, position } = dimensions;

  signalWidget.value = {
    ...signalWidget.value,
    dimensions: {
      isFullWidth: width >= window.innerWidth - SAFE_AREA * 2,
      isFullHeight: height >= window.innerHeight - SAFE_AREA * 2,
      width,
      height,
      position,
    },
  };
};

export interface SlowDowns {
  slowDowns: number;
  hideNotification: boolean;
}

export type WidgetStates =
  | {
      view: 'none';
    }
  | {
      view: 'inspector';
      // extra params
    }
  // | {
  //     view: 'settings';
  //     // extra params
  //   }
  | {
      view: 'notifications';
      // extra params
    };
// | {
//     view: 'summary';
//     // extra params
//   };
export const signalWidgetViews = signal<WidgetStates>({
  view: 'none',
});
</file>

<file path="src/web/toolbar.tsx">
import { Component, render } from 'preact';
import { Icon } from './components/icon';
import { Widget } from './widget';
import { SvgSprite } from './components/svg-sprite';


class ToolbarErrorBoundary extends Component {
  state: { hasError: boolean; error: Error | null } = { hasError: false, error: null };

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }

  handleReset = () => {
    this.setState({ hasError: false, error: null });
  };

  render() {
    if (this.state.hasError) {
      return (
        <div className="fixed bottom-4 right-4 z-[124124124124]">
          <div className="p-3 bg-black rounded-lg shadow-lg w-80">
            <div className="flex items-center gap-2 mb-2 text-red-400 text-sm font-medium">
              <Icon name="icon-flame" className="text-red-500" size={14} />
              React Scan ran into a problem
            </div>
            <div className="p-2 bg-black rounded font-mono text-xs text-red-300 mb-3 break-words">
              {this.state.error?.message || JSON.stringify(this.state.error)}
            </div>
            <button
              type="button"
              onClick={this.handleReset}
              className="px-3 py-1.5 bg-red-500 hover:bg-red-600 text-white rounded text-xs font-medium transition-colors flex items-center justify-center gap-1.5"
            >
              Restart
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

export const createToolbar = (root: ShadowRoot): HTMLElement => {
  const container = document.createElement('div');
  container.id = 'react-scan-toolbar-root';
  window.__REACT_SCAN_TOOLBAR_CONTAINER__ = container;
  root.appendChild(container);

  render(
    <ToolbarErrorBoundary>
      <>
        <SvgSprite />
        <Widget />
      </>
    </ToolbarErrorBoundary>,
    container,
  );

  const originalRemove = container.remove.bind(container);

  container.remove = () => {
    window.__REACT_SCAN_TOOLBAR_CONTAINER__ = undefined;

    if (container.hasChildNodes()) {
      // Double render(null) is needed to fully unmount Preact components.
      // The first call initiates unmounting, while the second ensures
      // cleanup of internal VNode references and event listeners.
      render(null, container);
      render(null, container);
    }

    originalRemove();
  };

  return container;
};
</file>

<file path="src/auto.ts">
// Prioritize bippy side-effect
import 'bippy';

import { IS_CLIENT } from '~web/utils/constants';
import { scan } from './index';

if (IS_CLIENT) {
  scan();
  window.reactScan = scan;
}

export * from './core';
</file>

<file path="src/cli.mts">
import { spawn } from 'node:child_process';
import fs from 'node:fs/promises';
import path from 'node:path';
import { cancel, confirm, intro, isCancel, spinner } from '@clack/prompts';
import { bgMagenta, dim, red } from 'kleur';
import mri from 'mri';
import {
  type Browser,
  type BrowserContext,
  chromium,
  devices,
  firefox,
  webkit,
} from 'playwright';

const truncateString = (str: string, maxLength: number) => {
  let result = str
    .replace('http://', '')
    .replace('https://', '')
    .replace('www.', '');

  if (result.endsWith('/')) {
    result = result.slice(0, -1);
  }

  if (result.length > maxLength) {
    const half = Math.floor(maxLength / 2);
    const start = result.slice(0, half);
    const end = result.slice(result.length - (maxLength - half));
    return `${start}${end}`;
  }
  return result;
};

const inferValidURL = (maybeURL: string) => {
  try {
    return new URL(maybeURL).href;
  } catch {
    try {
      return new URL(`https://${maybeURL}`).href;
    } catch {
      return 'about:blank';
    }
  }
};

const getBrowserDetails = async (browserType: string) => {
  switch (browserType) {
    case 'firefox':
      return { browserType: firefox, channel: undefined, name: 'firefox' };
    case 'webkit':
      return { browserType: webkit, channel: undefined, name: 'webkit' };
    default:
      return { browserType: chromium, channel: 'chrome', name: 'chrome' };
  }
};

const userAgentStrings = [
  'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.2227.0 Safari/537.36',
  'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36',
  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.3497.92 Safari/537.36',
  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36',
];

const applyStealthScripts = async (context: BrowserContext) => {
  await context.addInitScript(() => {
    // Override the navigator.webdriver property
    Object.defineProperty(navigator, 'webdriver', {
      get: () => undefined,
    });

    // Mock languages and plugins to mimic a real browser
    Object.defineProperty(navigator, 'languages', {
      get: () => ['en-US', 'en'],
    });

    Object.defineProperty(navigator, 'plugins', {
      get: () => [1, 2, 3, 4, 5],
    });

    // Remove Playwright-specific properties
    interface PlaywrightWindow extends Window {
      __playwright?: unknown;
      __pw_manual?: unknown;
      __PW_inspect?: unknown;
    }

    const win = window as PlaywrightWindow;
    win.__playwright = undefined;
    win.__pw_manual = undefined;
    win.__PW_inspect = undefined;

    // Redefine the headless property
    Object.defineProperty(navigator, 'headless', {
      get: () => false,
    });

    // Override the permissions API
    const originalQuery = window.navigator.permissions.query;
    window.navigator.permissions.query = (parameters) =>
      parameters.name === 'notifications'
        ? Promise.resolve({
            state: Notification.permission,
          } as PermissionStatus)
        : originalQuery(parameters);
  });
};

const init = async () => {
  intro(`${bgMagenta('[]')} React Scan`);
  const args = mri(process.argv.slice(2));
  let browser: Browser | undefined;

  const device = devices[args.device];
  const { browserType, channel } = await getBrowserDetails(args.browser);

  const contextOptions = {
    headless: false,
    channel,
    ...device,
    acceptDownloads: true,
    viewport: null,
    locale: 'en-US',
    timezoneId: 'America/New_York',
    args: [
      '--enable-webgl',
      '--use-gl=swiftshader',
      '--enable-accelerated-2d-canvas',
      '--disable-blink-features=AutomationControlled',
      '--disable-web-security',
    ],
    userAgent:
      userAgentStrings[Math.floor(Math.random() * userAgentStrings.length)],
    bypassCSP: true,
    ignoreHTTPSErrors: true,
  };

  try {
    browser = await browserType.launch({
      headless: false,
      channel,
    });
  } catch {
    /**/
  }

  if (!browser) {
    try {
      browser = await browserType.launch({ headless: false });
    } catch {
      const installPromise = new Promise<void>((resolve, reject) => {
        const runInstall = () => {
          confirm({
            message:
              'No drivers found. Install Playwright Chromium driver to continue?',
          }).then((shouldInstall) => {
            if (isCancel(shouldInstall)) {
              cancel('Operation cancelled.');
              process.exit(0);
            }
            if (!shouldInstall) {
              process.exit(0);
            }

            const installProcess = spawn(
              'npx',
              ['playwright@latest', 'install', 'chromium'],
              { stdio: 'inherit' },
            );

            installProcess.on('close', (code) => {
              if (!code) resolve();
              else
                reject(
                  new Error(`Installation process exited with code ${code}`),
                );
            });

            installProcess.on('error', reject);
          });
        };

        runInstall();
      });

      await installPromise;

      try {
        browser = await chromium.launch({ headless: false });
      } catch {
        cancel(
          'No browser could be launched. Please run `npx playwright install` to install browser drivers.',
        );
      }
    }
  }

  if (!browser) {
    cancel(
      'No browser could be launched. Please run `npx playwright install` to install browser drivers.',
    );
    return;
  }

  const context = await browser.newContext(contextOptions);
  await applyStealthScripts(context);

  const scriptContent = await fs.readFile(
    path.resolve(__dirname, './auto.global.js'),
    'utf8',
  );

  // Add React Scan script at context level so it's available for all pages
  await context.addInitScript({
    content: `window.hideIntro = true;${scriptContent}\n//# sourceURL=react-scan.js`,
  });

  const page = await context.newPage();

  const inputUrl = args._[0] || 'about:blank';

  const urlString = inferValidURL(inputUrl);

  await page.goto(urlString);

  await page.waitForLoadState('load');
  await page.waitForTimeout(500);

  const pollReport = async () => {
    if (page.url() !== currentURL) return;
    await page.evaluate(() => {
      const globalHook = globalThis.__REACT_SCAN__;
      if (!globalHook) return;
      let count = 0;
      globalHook.ReactScanInternals.onRender = (_fiber, renders) => {
        let localCount = 0;
        for (const render of renders) {
          localCount += render.count;
        }
        count = localCount;
      };
      const reportData = globalHook.ReactScanInternals.Store.reportData;
      if (!Object.keys(reportData).length) return;

      // biome-ignore lint/suspicious/noConsole: Intended debug output
      console.log('REACT_SCAN_REPORT', count);
    });
  };

  let count = 0;
  let currentSpinner: ReturnType<typeof spinner> | undefined;
  let currentURL = urlString;

  let interval: ReturnType<typeof setInterval>;

  const inject = async (url: string) => {
    if (interval) clearInterval(interval);
    currentURL = url;
    const truncatedURL = truncateString(url, 35);

    // biome-ignore lint/suspicious/noConsole: <explanation>
    console.log(dim(`Scanning: ${truncatedURL}`));
    count = 0;

    try {
      await page.waitForLoadState('load');
      await page.waitForTimeout(500);

      const hasReactScan = await page.evaluate(() => {
        return Boolean(globalThis.__REACT_SCAN__);
      });

      if (!hasReactScan) {
        // Script is already registered at context level, just reload
        await page.reload();
        return;
      }

      await page.waitForTimeout(100);

      interval = setInterval(() => {
        pollReport().catch(() => {});
      }, 1000);
    } catch {
      // biome-ignore lint/suspicious/noConsole: <explanation>
      console.log(red(`Error: ${truncatedURL}`));
    }
  };

  await inject(urlString);

  page.on('framenavigated', async (frame) => {
    if (frame !== page.mainFrame()) return;
    const url = frame.url();
    inject(url);
  });

  page.on('console', async (msg) => {
    const text = msg.text();
    if (!text.startsWith('REACT_SCAN_REPORT')) {
      return;
    }
    const reportDataString = text.replace('REACT_SCAN_REPORT', '').trim();
    try {
      count = Number.parseInt(reportDataString, 10);
    } catch {
      return;
    }

    const truncatedURL = truncateString(currentURL, 50);
    if (currentSpinner) {
      currentSpinner.message(
        dim(`Scanning: ${truncatedURL}${count ? ` (${count})` : ''}`),
      );
    }
  });
};

void init();
</file>

<file path="src/index.ts">
// Bippy has a side-effect that installs the hook.
import 'bippy';

export * from './core/index';
</file>

<file path="src/install-hook.ts">
export { getRDTHook as init } from 'bippy';
</file>

<file path="src/types.d.ts">
declare module './new-outlines/offscreen-canvas.worker' {
  const workerCode: string;
  export default workerCode;
}
</file>

<file path="src/types.ts">
import type { Fiber, FiberRoot } from 'bippy';

type ReactScanInternals = typeof import('./core/index')['ReactScanInternals'];
type Scan = typeof import('./index')['scan'];

export interface ExtendedReactRenderer {
  findFiberByHostInstance: (instance: Element) => Fiber | null;
  version: string;
  bundleType: number;
  rendererPackageName: string;
  overrideHookState?: (
    fiber: Fiber,
    id: string,
    path: string[],
    value: unknown,
  ) => void;
  overrideProps?: (fiber: Fiber, path: string[], value: unknown) => void;
  overrideContext?: (
    fiber: Fiber,
    contextType: unknown,
    path: string[],
    value: unknown,
  ) => void;
}

declare global {
  var __REACT_SCAN__: {
    ReactScanInternals: ReactScanInternals;
  };
  var reactScanCleanupListeners: (() => void) | undefined;
  var reactScan: Scan;
  var scheduler: {
    postTask: (cb: unknown, options: { priority: string }) => void;
  };

  type TTimer = NodeJS.Timeout;

  interface Window {
    reactScan: Scan;
    __REACT_SCAN_TOOLBAR_CONTAINER__?: HTMLDivElement;
    __REACT_SCAN_VERSION__?: string;
    __REACT_SCAN_EXTENSION__?: boolean;
    __REACT_DEVTOOLS_GLOBAL_HOOK__?: {
      checkDCE: (fn: unknown) => void;
      supportsFiber: boolean;
      supportsFlight: boolean;
      renderers: Map<number, ExtendedReactRenderer>;
      hasUnsupportedRendererAttached: boolean;
      onCommitFiberRoot: (
        rendererID: number,
        root: FiberRoot,
        priority: void | number,
      ) => void;
      onCommitFiberUnmount: (rendererID: number, fiber: Fiber) => void;
      onPostCommitFiberRoot: (rendererID: number, root: FiberRoot) => void;
      inject: (renderer: ExtendedReactRenderer) => number;
      _instrumentationSource?: string;
      _instrumentationIsActive?: boolean;
    };
  }
}
</file>

<file path="src/worker-shim.ts">
// This gets injected into the bundle
export function createInlineWorker(code: string) {
  const blob = new Blob([code], { type: 'application/javascript' });
  const url = URL.createObjectURL(blob);
  return new Worker(url);
}
</file>

<file path=".gitignore">
src/web/assets/css/styles.css
</file>

<file path="auto.d.ts">
export * from './dist/auto';
</file>

<file path="global.d.ts">
declare module '*.css' {
  const content: string;
  export default content;
}

declare module '*.astro' {
  const Component: unknown;
  export default Component;
}
</file>

<file path="package.json">
{
  "name": "shopable-scan",
  "version": "0.3.30",
  "description": "Scan your React app for renders",
  "keywords": ["react", "react-scan", "react scan", "render", "performance"],
  "homepage": "https://react-scan.million.dev",
  "bugs": {
    "url": "https://github.com/aidenybai/react-scan/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/aidenybai/react-scan.git"
  },
  "license": "MIT",
  "author": {
    "name": "Aiden Bai",
    "email": "aiden@million.dev",
    "url": "https://million.dev"
  },
  "exports": {
    "./package.json": "./package.json",
    "./monitoring": {
      "types": "./dist/core/monitor/index.d.ts",
      "import": "./dist/core/monitor/index.mjs",
      "require": "./dist/core/monitor/index.js"
    },
    "./monitoring/next": {
      "types": "./dist/core/monitor/params/next.d.ts",
      "import": "./dist/core/monitor/params/next.mjs",
      "require": "./dist/core/monitor/params/next.js"
    },
    "./monitoring/react-router-legacy": {
      "types": "./dist/core/monitor/params/react-router-v5.d.ts",
      "import": "./dist/core/monitor/params/react-router-v5.mjs",
      "require": "./dist/core/monitor/params/react-router-v5.js"
    },
    "./monitoring/react-router": {
      "types": "./dist/core/monitor/params/react-router-v6.d.ts",
      "import": "./dist/core/monitor/params/react-router-v6.mjs",
      "require": "./dist/core/monitor/params/react-router-v6.js"
    },
    "./monitoring/remix": {
      "types": "./dist/core/monitor/params/remix.d.ts",
      "import": "./dist/core/monitor/params/remix.mjs",
      "require": "./dist/core/monitor/params/remix.js"
    },
    "./monitoring/astro": {
      "import": "./dist/core/monitor/params/astro/index.ts"
    },
    ".": {
      "production": {
        "import": {
          "types": "./dist/rsc-shim.d.mts",
          "react-server": "./dist/rsc-shim.mjs",
          "default": "./dist/rsc-shim.mjs"
        },
        "require": {
          "types": "./dist/rsc-shim.d.ts",
          "react-server": "./dist/rsc-shim.js",
          "default": "./dist/rsc-shim.js"
        }
      },
      "development": {
        "import": {
          "types": "./dist/index.d.mts",
          "react-server": "./dist/rsc-shim.mjs",
          "default": "./dist/index.mjs"
        },
        "require": {
          "types": "./dist/index.d.ts",
          "react-server": "./dist/rsc-shim.js",
          "default": "./dist/index.js"
        }
      },
      "default": {
        "import": {
          "types": "./dist/index.d.mts",
          "react-server": "./dist/rsc-shim.mjs",
          "default": "./dist/index.mjs"
        },
        "require": {
          "types": "./dist/index.d.ts",
          "react-server": "./dist/rsc-shim.js",
          "default": "./dist/index.js"
        }
      }
    },
    "./install-hook": {
      "types": "./dist/install-hook.d.ts",
      "import": "./dist/install-hook.mjs",
      "require": "./dist/install-hook.js"
    },
    "./auto": {
      "production": {
        "import": {
          "types": "./dist/rsc-shim.d.mts",
          "react-server": "./dist/rsc-shim.mjs",
          "default": "./dist/rsc-shim.mjs"
        },
        "require": {
          "types": "./dist/rsc-shim.d.ts",
          "react-server": "./dist/rsc-shim.js",
          "default": "./dist/rsc-shim.js"
        }
      },
      "development": {
        "import": {
          "types": "./dist/auto.d.mts",
          "react-server": "./dist/rsc-shim.mjs",
          "default": "./dist/auto.mjs"
        },
        "require": {
          "types": "./dist/auto.d.ts",
          "react-server": "./dist/rsc-shim.js",
          "default": "./dist/auto.js"
        }
      }
    },
    "./dist/*": "./dist/*.js",
    "./dist/*.js": "./dist/*.js",
    "./dist/*.mjs": "./dist/*.mjs",
    "./react-component-name/vite": {
      "types": "./dist/react-component-name/vite.d.ts",
      "import": "./dist/react-component-name/vite.mjs",
      "require": "./dist/react-component-name/vite.js"
    },
    "./react-component-name/webpack": {
      "types": "./dist/react-component-name/webpack.d.ts",
      "import": "./dist/react-component-name/webpack.mjs",
      "require": "./dist/react-component-name/webpack.js"
    },
    "./react-component-name/esbuild": {
      "types": "./dist/react-component-name/esbuild.d.ts",
      "import": "./dist/react-component-name/esbuild.mjs",
      "require": "./dist/react-component-name/esbuild.js"
    },
    "./react-component-name/rspack": {
      "types": "./dist/react-component-name/rspack.d.ts",
      "import": "./dist/react-component-name/rspack.mjs",
      "require": "./dist/react-component-name/rspack.js"
    },
    "./react-component-name/rolldown": {
      "types": "./dist/react-component-name/rolldown.d.ts",
      "import": "./dist/react-component-name/rolldown.mjs",
      "require": "./dist/react-component-name/rolldown.js"
    },
    "./react-component-name/rollup": {
      "types": "./dist/react-component-name/rollup.d.ts",
      "import": "./dist/react-component-name/rollup.mjs",
      "require": "./dist/react-component-name/rollup.js"
    },
    "./react-component-name/astro": {
      "types": "./dist/react-component-name/astro.d.ts",
      "import": "./dist/react-component-name/astro.mjs",
      "require": "./dist/react-component-name/astro.js"
    },
    "./react-component-name/loader": {
      "types": "./dist/react-component-name/loader.d.ts",
      "import": "./dist/react-component-name/loader.mjs",
      "require": "./dist/react-component-name/loader.js"
    }
  },
  "main": "dist/index.js",
  "module": "dist/index.mjs",
  "browser": "dist/auto.global.js",
  "types": "dist/index.d.ts",
  "typesVersions": {
    "*": {
      "monitoring": ["./dist/core/monitor/index.d.ts"],
      "monitoring/next": ["./dist/core/monitor/params/next.d.ts"],
      "monitoring/react-router-legacy": [
        "./dist/core/monitor/params/react-router-v5.d.ts"
      ],
      "monitoring/react-router": [
        "./dist/core/monitor/params/react-router-v6.d.ts"
      ],
      "monitoring/remix": ["./dist/core/monitor/params/remix.d.ts"],
      "monitoring/astro": ["./dist/core/monitor/params/astro/index.ts"],
      "react-component-name/vite": ["./dist/react-component-name/vite.d.ts"],
      "react-component-name/webpack": [
        "./dist/react-component-name/webpack.d.ts"
      ],
      "react-component-name/esbuild": [
        "./dist/react-component-name/esbuild.d.ts"
      ],
      "react-component-name/rspack": [
        "./dist/react-component-name/rspack.d.ts"
      ],
      "react-component-name/rolldown": [
        "./dist/react-component-name/rolldown.d.ts"
      ],
      "react-component-name/rollup": [
        "./dist/react-component-name/rollup.d.ts"
      ],
      "react-component-name/astro": ["./dist/react-component-name/astro.d.ts"],
      "react-component-name/loader": ["./dist/react-component-name/loader.d.ts"]
    }
  },
  "bin": "bin/cli.js",
  "files": ["dist", "bin", "package.json", "README.md", "LICENSE", "auto.d.ts"],
  "scripts": {
    "dev:kitchen": "node dist/cli.js http://localhost:5173",
    "build": "npm run build:css && NODE_ENV=production tsup",
    "postbuild": "pnpm copy-astro && node ../../scripts/version-warning.mjs",
    "build:copy": "npm run build:css && NODE_ENV=production tsup && cat dist/auto.global.js | pbcopy",
    "copy-astro": "cp -R src/core/monitor/params/astro dist/core/monitor/params",
    "dev:css": "postcss ./src/web/assets/css/styles.tailwind.css -o ./src/web/assets/css/styles.css --watch",
    "dev:tsup": "NODE_ENV=development tsup --watch",
    "dev": "pnpm copy-astro && npm-run-all --parallel dev:css dev:tsup",
    "build:css": "postcss ./src/web/assets/css/styles.tailwind.css -o ./src/web/assets/css/styles.css",
    "pack": "npm version patch && pnpm build && npm pack",
    "pack:bump": "bun scripts/bump-version.js && nr pack && echo $(pwd)/react-scan-$(node -p \"require('./package.json').version\").tgz | pbcopy",
    "prettier": "prettier --config .prettierrc.mjs -w src",
    "publint": "publint",
    "test": "vitest",
    "lint": "biome lint src && pnpm typecheck",
    "format": "biome format . --write",
    "check": "biome check . --write",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "@babel/core": "^7.26.0",
    "@babel/generator": "^7.26.2",
    "@babel/types": "^7.26.0",
    "@clack/core": "^0.3.5",
    "@clack/prompts": "^0.8.2",
    "@pivanov/utils": "0.0.2",
    "@preact/signals": "^1.3.1",
    "@rollup/pluginutils": "^5.1.3",
    "@types/node": "^20.17.9",
    "bippy": "^0.3.8",
    "esbuild": "^0.25.0",
    "estree-walker": "^3.0.3",
    "kleur": "^4.1.5",
    "mri": "^1.2.0",
    "playwright": "^1.49.0",
    "preact": "^10.25.1",
    "tsx": "^4.19.3"
  },
  "devDependencies": {
    "@esbuild-plugins/tsconfig-paths": "^0.1.2",
    "@remix-run/react": "*",
    "@types/babel__core": "^7.20.5",
    "@types/react": "^18.0.0",
    "@types/react-router": "^5.1.0",
    "@vercel/style-guide": "^6.0.0",
    "clsx": "^2.1.1",
    "es-module-lexer": "^1.5.4",
    "next": "*",
    "npm-run-all": "^4.1.5",
    "postcss-cli": "^11.0.0",
    "prettier": "^3.3.3",
    "publint": "^0.2.12",
    "react": "*",
    "react-dom": "*",
    "react-router": "^5.0.0",
    "react-router-dom": "^5.0.0 || ^6.0.0 || ^7.0.0",
    "tailwind-merge": "^2.5.5",
    "terser": "^5.36.0",
    "tsup": "^8.0.0",
    "vitest": "^1.0.0"
  },
  "peerDependencies": {
    "@remix-run/react": ">=1.0.0",
    "next": ">=13.0.0",
    "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0",
    "react-dom": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0",
    "react-router": "^5.0.0 || ^6.0.0 || ^7.0.0",
    "react-router-dom": "^5.0.0 || ^6.0.0 || ^7.0.0"
  },
  "peerDependenciesMeta": {
    "@remix-run/react": {
      "optional": true
    },
    "next": {
      "optional": true
    },
    "react-router": {
      "optional": true
    },
    "react-router-dom": {
      "optional": true
    }
  },
  "optionalDependencies": {
    "unplugin": "2.1.0"
  },
  "publishConfig": {
    "access": "public"
  }
}
</file>

<file path="postcss.config.mjs">
import autoprefixer from 'autoprefixer';
import tailwindcss from 'tailwindcss';
import remToPx from './postcss.rem2px.mjs';

export default {
  plugins: [remToPx({ baseValue: 16 }), tailwindcss, autoprefixer],
};
</file>

<file path="postcss.rem2px.mjs">
const remToPx = (options = {}) => {
  const baseValue = options.baseValue || 16;

  // Improved regex that handles all rem cases including negatives
  const remRegex = /(?<![-\w])(-)?((?:\d*\.)?\d+)rem\b/g;

  const convertRemToPx = (value) => {
    // Handle all cases: calc(), min(), max(), clamp(), and regular values
    return value.replace(remRegex, (_match, negative, num) => {
      const pixels = Number.parseFloat(num) * baseValue;
      return `${negative ? '-' : ''}${pixels}px`;
    });
  };

  return {
    postcssPlugin: 'postcss-rem-to-px',
    prepare() {
      return {
        Once(root) {
          root.walkDecls((decl) => {
            if (decl.value?.includes('rem')) {
              decl.value = convertRemToPx(decl.value);
            }
          });
        },
        Declaration(decl) {
          if (decl.value?.includes('rem')) {
            decl.value = convertRemToPx(decl.value);
          }
        },
        AtRule: {
          media: (atRule) => {
            if (atRule.params?.includes('rem')) {
              atRule.params = convertRemToPx(atRule.params);
            }
          },
        },
      };
    },
  };
};

remToPx.postcss = true;

export default remToPx;
</file>

<file path="README.md">
# <img src="https://github.com/aidenybai/react-scan/blob/main/.github/assets/logo.svg" width="30" height="30" align="center" /> React Scan

React Scan automatically detects performance issues in your React app.

Previously, tools like:

- [`<Profiler />`](https://react.dev/reference/react/Profiler) required lots of manual changes
- [Why Did You Render?](https://github.com/welldone-software/why-did-you-render) lacked simple visual cues
- [React Devtools](https://legacy.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html) didn't have a simple, portable, and programmatic API

React Scan attempts to solve these problems:

- It requires no code changes  just drop it in
- It highlights exactly the components you need to optimize
- Use it via script tag, npm, CLI, you name it!

Trusted by engineering teams at:

Airbnb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://polaris.shopify.com/"><img src="https://raw.githubusercontent.com/aidenybai/react-scan/refs/heads/main/.github/assets/shopify-logo.png" height="30" align="center" /></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.faire.com/"><img src="https://raw.githubusercontent.com/aidenybai/react-scan/refs/heads/main/.github/assets/faire-logo.svg" height="20" align="center" /></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://perplexity.com/"><img src="https://raw.githubusercontent.com/aidenybai/react-scan/refs/heads/main/.github/assets/perplexity-logo.png" height="30" align="center" /></a>

### [**Try it out! **](https://react-scan.million.dev)

![React Scan in action](https://raw.githubusercontent.com/aidenybai/react-scan/refs/heads/main/.github/assets/demo.gif)

> [!IMPORTANT]
> Want to monitor issues in production? Check out [React Scan Monitoring](https://react-scan.com/monitoring)!

## Install

### Package managers

```bash
npm i react-scan
```

```bash
pnpm add react-scan
```

```bash
yarn add react-scan
```

### CDN

```html
<!-- import this BEFORE any scripts -->
<script src="https://unpkg.com/react-scan/dist/auto.global.js"></script>
```

## Usage

- [NextJS App Router](https://github.com/aidenybai/react-scan/blob/main/docs/installation/next-js-app-router.md)
- [NextJS Page Router](https://github.com/aidenybai/react-scan/blob/main/docs/installation/next-js-page-router.md)
- [Create React App](https://github.com/aidenybai/react-scan/blob/main/docs/installation/create-react-app.md)
- [Vite](https://github.com/aidenybai/react-scan/blob/main/docs/installation/vite.md)
- [Parcel](https://github.com/aidenybai/react-scan/blob/main/docs/installation/parcel.md)
- [Remix](https://github.com/aidenybai/react-scan/blob/main/docs/installation/remix.md)
- [React Router](https://github.com/aidenybai/react-scan/blob/main/docs/installation/react-router.md)
- [Astro](https://github.com/aidenybai/react-scan/blob/main/docs/installation/astro.md)
- [TanStack Start](https://github.com/aidenybai/react-scan/blob/main/docs/installation/tanstack-start.md)

### CLI

If you don't have a local version of the site or you want to test a React app remotely, you can use the CLI. This will spin up an isolated browser instance which you can interact or use React Scan with.

```bash
npx react-scan@latest http://localhost:3000
# you can technically scan ANY website on the web:
# npx react-scan@latest https://react.dev
```

You can add it to your existing dev process as well. Here's an example for Next.js:

```json
{
  "scripts": {
    "dev": "next dev",
    "scan": "next dev & npx react-scan@latest localhost:3000"
  }
}
```

### Browser Extension

If you want to install the extension, follow the guide [here](https://github.com/aidenybai/react-scan/blob/main/BROWSER_EXTENSION_GUIDE.md).

### React Native

See [discussion](https://github.com/aidenybai/react-scan/pull/23)

## API Reference

<details>
<summary><code>Options</code></summary>

<br />

```tsx
export interface Options {
  /**
   * Enable/disable scanning
   *
   * Please use the recommended way:
   * enabled: process.env.NODE_ENV === 'development',
   *
   * @default true
   */
  enabled?: boolean;

  /**
   * Force React Scan to run in production (not recommended)
   *
   * @default false
   */
  dangerouslyForceRunInProduction?: boolean;
  /**
   * Log renders to the console
   *
   * WARNING: This can add significant overhead when the app re-renders frequently
   *
   * @default false
   */
  log?: boolean;

  /**
   * Show toolbar bar
   *
   * If you set this to true, and set {@link enabled} to false, the toolbar will still show, but scanning will be disabled.
   *
   * @default true
   */
  showToolbar?: boolean;

  /**
   * Animation speed
   *
   * @default "fast"
   */
  animationSpeed?: "slow" | "fast" | "off";

  /**
   * Track unnecessary renders, and mark their outlines gray when detected
   *
   * An unnecessary render is defined as the component re-rendering with no change to the component's
   * corresponding dom subtree
   *
   *  @default false
   *  @warning tracking unnecessary renders can add meaningful overhead to react-scan
   */
  trackUnnecessaryRenders?: boolean;

  onCommitStart?: () => void;
  onRender?: (fiber: Fiber, renders: Array<Render>) => void;
  onCommitFinish?: () => void;
  onPaintStart?: (outlines: Array<Outline>) => void;
  onPaintFinish?: (outlines: Array<Outline>) => void;
}
```

</details>

- `scan(options: Options)`: Imperative API to start scanning
- `useScan(options: Options)`: Hook API to start scanning
- `getReport()`: Get a report of all the renders
- `setOptions(options: Options): void`: Set options at runtime
- `getOptions()`: Get the current options
- `onRender(Component, onRender: (fiber: Fiber, render: Render) => void)`: Hook into a specific component's renders

## Why React Scan?

React can be tricky to optimize.

The issue is that component props are compared by reference, not value. This is intentional  this way rendering can be cheap to run.

However, this makes it easy to accidentally cause unnecessary renders, making the app slow. Even in production apps, with hundreds of engineers, can't fully optimize their apps (see [GitHub](https://github.com/aidenybai/react-scan/blob/main/.github/assets/github.mp4), [Twitter](https://github.com/aidenybai/react-scan/blob/main/.github/assets/twitter.mp4), and [Instagram](https://github.com/aidenybai/react-scan/blob/main/.github/assets/instagram.mp4)).

This often comes down to props that update in reference, like callbacks or object values. For example, the `onClick` function and `style` object are re-created on every render, causing `ExpensiveComponent` to slow down the app:

```jsx
<ExpensiveComponent onClick={() => alert("hi")} style={{ color: "purple" }} />
```

React Scan helps you identify these issues by automatically detecting and highlighting renders that cause performance issues. Now, instead of guessing, you can see exactly which components you need to fix.

> Want monitor issues in production? Check out [React Scan Monitoring](https://react-scan.com/monitoring)!

### FAQ

**Q: Why this instead of React Devtools?**

React Devtools aims to be a general purpose tool for React. However, I deal with React performance issues every day, and React Devtools doesn't fix my problems well. There's a lot of noise (no obvious distinction between unnecessary and necessary renders), and there's no programmatic API. If it sounds like you have the same problems, then React Scan may be a better choice.

Also, some personal complaints about React Devtools' highlight feature:

- React Devtools "batches" paints, so if a component renders too fast, it will lag behind and only show 1 every second or so
- When you scroll/resize the boxes don't update position
- No count of how many renders there are
- I don't know what the bad/slow renders are without inspecting
- The menu is hidden away so it's annoying to turn on/off, user experience should be specifically tuned for debugging performance, instead of hidden behind a profiler/component tree
- No programmatic API
- It's stuck in a chrome extension, I want to run it anywhere on the web
- It looks subjectively ugly (lines look fuzzy, feels sluggish)
- I'm more ambitious with react-scan

## Resources & Contributing Back

Want to try it out? Check the [our demo](https://react-scan.million.dev).

Looking to contribute back? Check the [Contributing Guide](https://github.com/aidenybai/react-scan/blob/main/CONTRIBUTING.md) out.

Want to talk to the community? Hop in our [Discord](https://discord.gg/X9yFbcV2rF) and share your ideas and what you've build with React Scan.

Find a bug? Head over to our [issue tracker](https://github.com/aidenybai/react-scan/issues) and we'll do our best to help. We love pull requests, too!

We expect all contributors to abide by the terms of our [Code of Conduct](https://github.com/aidenybai/react-scan/blob/main/.github/CODE_OF_CONDUCT.md).

[** Start contributing on GitHub**](https://github.com/aidenybai/react-scan/blob/main/CONTRIBUTING.md)

## Acknowledgments

React Scan takes inspiration from the following projects:

- [React Devtools](https://react.dev/learn/react-developer-tools) for the initial idea of [highlighting renders](https://medium.com/dev-proto/highlight-react-components-updates-1b2832f2ce48). We chose to diverge from this to provide a [better developer experience](https://x.com/aidenybai/status/1857122670929969551)
- [Million Lint](https://million.dev) for scanning and linting approaches
- [Why Did You Render?](https://github.com/welldone-software/why-did-you-render) for the concept of hijacking internals to detect unnecessary renders caused by "unstable" props

## License

React Scan is [MIT-licensed](LICENSE) open-source software by Aiden Bai, [Million Software, Inc.](https://million.dev), and [contributors](https://github.com/aidenybai/react-scan/graphs/contributors).
</file>

<file path="tailwind.config.mjs">
export default {
  content: ['./src/**/*.{js,jsx,ts,tsx}'],
  corePlugins: {
    preflight: true,
  },
  darkMode: 'class',
  theme: {
    extend: {
      fontFamily: {
        mono: [
          'Menlo',
          'Consolas',
          'Monaco',
          'Liberation Mono',
          'Lucida Console',
          'monospace',
        ],
      },
      spacing: {
        3.5: '0.875rem',
        4.5: '1.125rem',
        5.5: '1.375rem',
        6.5: '1.625rem',
        7.5: '1.875rem',
        8.5: '2.125rem',
        9.5: '2.375rem',
      },
      colors: {
        inspect: '#8e61e3',
      },
      fontSize: {
        xxs: '0.5rem',
      },
      cursor: {
        'nwse-resize': 'nwse-resize',
        'nesw-resize': 'nesw-resize',
        'ns-resize': 'ns-resize',
        'ew-resize': 'ew-resize',
        move: 'move',
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' },
        },
        fadeOut: {
          '0%': { opacity: '1' },
          '100%': { opacity: '0' },
        },
        shake: {
          '0%': { transform: 'translateX(0)' },
          '25%': { transform: 'translateX(-5px)' },
          '50%': { transform: 'translateX(5px)' },
          '75%': { transform: 'translateX(-5px)' },
          '100%': { transform: 'translateX(0)' },
        },
        rotate: {
          '0%': { transform: 'rotate(0deg)' },
          '100%': { transform: 'rotate(360deg)' },
        },
        countFlash: {
          '0%': {
            backgroundColor: 'rgba(168, 85, 247, 0.3)',
            transform: 'scale(1.05)',
          },
          '100%': {
            backgroundColor: 'rgba(168, 85, 247, 0.1)',
            transform: 'scale(1)',
          },
        },
        countFlashShake: {
          '0%': { transform: 'translateX(0)' },
          '25%': { transform: 'translateX(-5px)' },
          '50%': {
            transform: 'translateX(5px) scale(1.1)',
          },
          '75%': { transform: 'translateX(-5px)' },
          '100%': { transform: 'translateX(0)' },
        },
      },
      animation: {
        'fade-in': 'fadeIn ease-in forwards',
        'fade-out': 'fadeOut ease-out forwards',
        rotate: 'rotate linear infinite',
        shake: 'shake .4s ease-in-out forwards',
        'count-flash': 'countFlash .3s ease-out forwards',
        'count-flash-shake': 'countFlashShake .3s ease-out forwards',
      },
      zIndex: {
        100: 100,
      },
      borderWidth: {
        1: '1px',
      },
    },
  },
  safelist: [
    'cursor-nwse-resize',
    'cursor-nesw-resize',
    'cursor-ns-resize',
    'cursor-ew-resize',
    'cursor-move',
  ],
  plugins: [
    ({ addUtilities }) => {
      const newUtilities = {
        '.pointer-events-bounding-box': {
          'pointer-events': 'bounding-box',
        },
      };
      addUtilities(newUtilities);
    },
    ({ addUtilities }) => {
      const newUtilities = {
        '.animation-duration-0': {
          'animation-duration': '0s',
        },
        '.animation-delay-0': {
          'animation-delay': '0s',
        },
        '.animation-duration-100': {
          'animation-duration': '.1s',
        },
        '.animation-delay-100': {
          'animation-delay': '.1s',
        },
        '.animation-delay-150': {
          'animation-delay': '.15s',
        },
        '.animation-duration-200': {
          'animation-duration': '.2s',
        },
        '.animation-delay-200': {
          'animation-delay': '.2s',
        },
        '.animation-duration-300': {
          'animation-duration': '.3s',
        },
        '.animation-delay-300': {
          'animation-delay': '.3s',
        },
        '.animation-duration-500': {
          'animation-duration': '.5s',
        },
        '.animation-delay-500': {
          'animation-delay': '.5s',
        },
        '.animation-duration-700': {
          'animation-duration': '.7s',
        },
        '.animation-delay-700': {
          'animation-delay': '.7s',
        },
        '.animation-duration-1000': {
          'animation-duration': '1s',
        },
        '.animation-delay-1000': {
          'animation-delay': '1s',
        },
      };

      addUtilities(newUtilities);
    },
  ],
};
</file>

<file path="tsconfig.json">
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "rootDir": "src",
    "outDir": "dist",
    "baseUrl": ".",
    "types": [
      "node"
    ],
    "paths": {
      "~web/*": [
        "src/web/*"
      ],
      "~core/*": [
        "src/core/*"
      ],
      "~monitor/*": [
        "src/monitor/*"
      ],
      "~instrumentation/*": [
        "src/instrumentation/*"
      ]
    }
  },
  "include": [
    "src",
    "global.d.ts"
  ],
  "exclude": [
    "node_modules",
    "dist"
  ]
}
</file>

<file path="tsup.config.ts">
import * as fs from 'node:fs';
import fsPromise from 'node:fs/promises';
import path from 'node:path';
import { TsconfigPathsPlugin } from '@esbuild-plugins/tsconfig-paths';
import { init, parse } from 'es-module-lexer';
import { defineConfig } from 'tsup';
import { workerPlugin } from './worker-plugin';

const DIST_PATH = './dist';

const addDirectivesToChunkFiles = async (readPath: string): Promise<void> => {
  try {
    const files = await fsPromise.readdir(readPath);
    for (const file of files) {
      if (file.endsWith('.mjs') || file.endsWith('.js')) {
        const filePath = path.join(readPath, file);
        const data = await fsPromise.readFile(filePath, 'utf8');
        const updatedContent = `'use client';\n${data}`;
        await fsPromise.writeFile(filePath, updatedContent, 'utf8');
      }
    }
  } catch (err) {
    // biome-ignore lint/suspicious/noConsole: Intended debug output
    console.error('Error:', err);
  }
};

const banner = `/**
 * Copyright 2025 Aiden Bai, Million Software, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
 * and associated documentation files (the Software), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
 * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */`;

void (async () => {
  await init;

  if (fs.existsSync(DIST_PATH)) {
    fs.rmSync(DIST_PATH, { recursive: true });
  }
  fs.mkdirSync(DIST_PATH, { recursive: true });

  const code = fs.readFileSync('./src/core/index.ts', 'utf8');
  const [_, allExports] = parse(code);
  const names: Array<string> = [];
  for (const exportItem of allExports) {
    names.push(exportItem.n);
  }

  const createFn = (name: string) =>
    `export let ${name}=()=>{console.error('Do not use ${name} directly in a Server Component module. It should only be used in a Client Component.');return undefined}`;
  const createVar = (name: string) => `export let ${name}=undefined`;

  let script = '';
  for (const name of names) {
    if (name[0].toLowerCase() === name[0]) {
      script += `${createFn(name)}\n`;
      continue;
    }
    script += `${createVar(name)}\n`;
  }

  setTimeout(() => {
    for (const ext of ['js', 'mjs', 'global.js']) {
      fs.writeFileSync(`./dist/rsc-shim.${ext}`, script);
    }
  }, 500);
})();

export default defineConfig([
  {
    entry: ['./src/auto.ts', './src/install-hook.ts'],
    outDir: DIST_PATH,
    banner: {
      js: banner,
    },
    splitting: false,
    clean: false,
    sourcemap: false,
    format: ['iife'],
    target: 'esnext',
    platform: 'browser',
    treeshake: true,
    dts: true,
    minify: process.env.NODE_ENV === 'production' ? 'terser' : false,
    env: {
      NODE_ENV: process.env.NODE_ENV ?? 'development',
    },
    external: [
      'react',
      'react-dom',
      'next',
      'next/navigation',
      'react-router',
      'react-router-dom',
      '@remix-run/react',
    ],
    esbuildPlugins: [workerPlugin],
    loader: {
      '.css': 'text',
      '.worker.js': 'text',
    },
  },
  {
    entry: [
      './src/index.ts',
      './src/install-hook.ts',
      './src/core/monitor/index.ts',
      './src/core/monitor/params/next.ts',
      './src/core/monitor/params/react-router-v5.ts',
      './src/core/monitor/params/react-router-v6.ts',
      './src/core/monitor/params/remix.ts',
      './src/core/monitor/params/astro/component.ts',
    ],
    banner: {
      js: banner,
    },
    outDir: DIST_PATH,
    splitting: false,
    clean: false,
    sourcemap: false,
    format: ['cjs', 'esm'],
    target: 'esnext',
    platform: 'browser',
    // FIXME: tree shaking removes use client directive
    // Info: vercel analytics does the same thing- https://github.com/vercel/analytics/blob/main/packages/web/tsup.config.js
    treeshake: false,
    dts: true,
    watch: process.env.NODE_ENV === 'development',
    async onSuccess() {
      await Promise.all([
        addDirectivesToChunkFiles(DIST_PATH),
        addDirectivesToChunkFiles(`${DIST_PATH}/core/monitor/params`),
        addDirectivesToChunkFiles(`${DIST_PATH}/core/monitor`),
      ]);
    },
    minify: false,
    env: {
      NODE_ENV: process.env.NODE_ENV ?? 'development',
      NPM_PACKAGE_VERSION: JSON.parse(
        fs.readFileSync(
          path.join(__dirname, '../scan', 'package.json'),
          'utf8',
        ),
      ).version,
    },
    external: [
      'react',
      'react-dom',
      'next',
      'next/navigation',
      'react-router',
      'react-router-dom',
      '@remix-run/react',
      'preact',
      '@preact/signals',
    ],
    loader: {
      '.css': 'text',
    },
    esbuildPlugins: [
      workerPlugin,
      TsconfigPathsPlugin({
        tsconfig: path.resolve(__dirname, './tsconfig.json'),
      }),
    ],
  },
  {
    entry: ['./src/cli.mts'],
    outDir: DIST_PATH,
    banner: {
      js: banner,
    },
    splitting: false,
    clean: false,
    sourcemap: false,
    format: ['cjs'],
    target: 'esnext',
    platform: 'node',
    minify: false,
    env: {
      NODE_ENV: process.env.NODE_ENV ?? 'development',
    },
    watch: process.env.NODE_ENV === 'development',
  },
  {
    entry: [
      './src/react-component-name/index.ts',
      './src/react-component-name/vite.ts',
      './src/react-component-name/webpack.ts',
      './src/react-component-name/esbuild.ts',
      './src/react-component-name/rspack.ts',
      './src/react-component-name/rolldown.ts',
      './src/react-component-name/rollup.ts',
      './src/react-component-name/astro.ts',
    ],
    outDir: `${DIST_PATH}/react-component-name`,
    splitting: false,
    sourcemap: false,
    clean: false,
    format: ['cjs', 'esm'],
    target: 'esnext',
    external: [
      'unplugin',
      'estree-walker',
      '@rollup/pluginutils',
      '@babel/types',
      '@babel/parser',
      '@babel/traverse',
      '@babel/generator',
      '@babel/core',
      'rollup',
      'webpack',
      'esbuild',
      'rspack',
      'vite',
    ],
    dts: true,
    minify: false,
    treeshake: true,
    env: {
      NODE_ENV: process.env.NODE_ENV || 'development',
    },
    outExtension: ({ format }) => ({
      js: format === 'esm' ? '.mjs' : '.js',
    }),
    esbuildOptions: (options, context) => {
      options.mainFields = ['module', 'main'];
      options.conditions = ['import', 'require', 'node', 'default'];
      options.format = context.format === 'esm' ? 'esm' : 'cjs';
      options.preserveSymlinks = true;
    },
  },
]);
</file>

<file path="vite.config.mts">
import tsconfigPaths from 'vite-tsconfig-paths';
import { defineConfig } from 'vitest/config';

export default defineConfig({
  plugins: [tsconfigPaths()],
});
</file>

<file path="worker-plugin.ts">
import * as esbuild from 'esbuild';

/**
 * A hacky plugin to build the worker file (resolving all imports), and inline
 * the javascript into a variable by replacing __WORKER_CODE__ string in bundle with the worker
 * build output
 */
export const workerPlugin = {
  name: 'worker-plugin',
  setup(build) {
    const workerResult = esbuild.buildSync({
      entryPoints: ['src/new-outlines/offscreen-canvas.worker.ts'],
      bundle: true,
      write: false,
      format: 'iife',
      platform: 'browser',
      minify: true,
    });
    const workerCode = workerResult.outputFiles[0].text;

    build.onEnd((result) => {
      if (!result.outputFiles) return;

      for (const file of result.outputFiles) {
        const newText = file.text.replace(
          'var workerCode = "__WORKER_CODE__"',
          `var workerCode = ${JSON.stringify(workerCode)}`,
        );
        file.contents = Buffer.from(newText);
      }
    });
  },
};
</file>

</files>
