This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: pacakges/scan/package.json, packages/scan/**/*.ts
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
packages/
  scan/
    src/
      core/
        monitor/
          params/
            astro/
              component.ts
              index.ts
            next.ts
            react-router-v5.ts
            react-router-v6.ts
            remix.ts
            types.ts
            utils.ts
          constants.ts
          index.ts
          network.ts
          performance.ts
          types.ts
          utils.ts
        notifications/
          event-tracking.ts
          interaction-store.ts
          outline-overlay.ts
          performance-store.ts
          performance-utils.ts
          performance.ts
          types.ts
        fast-serialize.test.ts
        index.ts
        instrumentation.ts
        utils.ts
      html-to-image/
        apply-style.ts
        clone-node.ts
        clone-pseudos.ts
        dataurl.ts
        embed-images.ts
        embed-resources.ts
        embed-webfonts.ts
        index.ts
        mimes.ts
        types.ts
        util.ts
      new-outlines/
        canvas.ts
        index.ts
        offscreen-canvas.worker.ts
        types.ts
      react-component-name/
        __tests__/
          arrow-function.test.ts
          complex-patterns.test.ts
          function-declarations.test.ts
          general-cases.test.ts
          react-patterns.test.ts
          ts-patterns.test.ts
          utils.ts
        babel/
          get-descriptive-name.ts
          get-root-statement-path.ts
          index.ts
          is-componentish-name.ts
          is-nested-expression.ts
          is-path-valid.ts
          is-statement-top-level.ts
          path-references-import.ts
          unwrap.ts
        core/
          options.ts
        astro.ts
        esbuild.ts
        index.ts
        loader.ts
        rolldown.ts
        rollup.ts
        rspack.ts
        vite.ts
        webpack.ts
      web/
        hooks/
          use-delayed-value.ts
          use-merged-refs.ts
          use-virtual-list.ts
        utils/
          preact/
            constant.ts
            use-constant.ts
            use-lazy-ref.ts
          constants.ts
          create-store.ts
          geiger.ts
          helpers.ts
          lerp.ts
          log.ts
          lru.ts
          outline.ts
          pin.ts
        views/
          inspector/
            components-tree/
              state.ts
            timeline/
              utils.ts
            whats-changed/
              use-change-store.ts
            flash-overlay.ts
            logging.ts
            states.ts
            utils.ts
          notifications/
            data.ts
        widget/
          helpers.ts
          types.ts
        constants.ts
        state.ts
      auto.ts
      index.ts
      install-hook.ts
      types.d.ts
      types.ts
      worker-shim.ts
    auto.d.ts
    global.d.ts
    tsup.config.ts
    worker-plugin.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="packages/scan/src/core/monitor/params/astro/component.ts">
import { createElement } from 'react';
import {
  Monitoring as BaseMonitoring,
  type MonitoringWithoutRouteProps,
} from '../..';
import { computeRoute } from '../utils';

export function AstroMonitor(
  props: {
    path: string;
    params: Record<string, string | undefined>;
  } & MonitoringWithoutRouteProps,
) {
  const path = props.path;
  const route = computeRoute(path, props.params);

  return createElement(BaseMonitoring, {
    ...props,
    route,
    path,
  });
}
</file>

<file path="packages/scan/src/core/monitor/params/astro/index.ts">
// This file will not be packaged

export { default as Monitoring } from './Monitoring.astro';
</file>

<file path="packages/scan/src/core/monitor/params/next.ts">
'use client';

import { useParams, usePathname, useSearchParams } from 'next/navigation.js';
import { createElement, Suspense } from 'react';
import {
  Monitoring as BaseMonitoring,
  type MonitoringWithoutRouteProps,
} from '..';
import { computeRoute } from './utils';

/**
 * This hook works in both Next.js Pages and App Router:
 * - App Router: Uses the new useParams() hook directly
 * - Pages Router: useParams() returns empty object, falls back to searchParams
 * This fallback behavior ensures compatibility across both routing systems
 */
const useRoute = (): {
  route: string | null;
  path: string;
} => {
  const params = useParams();
  const searchParams = useSearchParams();
  const path = usePathname();

  // Until we have route parameters, we don't compute the route
  if (!params) {
    return { route: null, path };
  }
  // in Next.js@13, useParams() could return an empty object for pages router, and we default to searchParams.
  const finalParams = Object.keys(params).length
    ? (params as Record<string, string | Array<string>>)
    : Object.fromEntries(searchParams.entries());
  return { route: computeRoute(path, finalParams), path };
};
export function MonitoringInner(props: MonitoringWithoutRouteProps) {
  const { route, path } = useRoute();

  // we need to fix build so this doesn't get compiled to preact jsx
  return createElement(BaseMonitoring, {
    ...props,
    route,
    path,
  });
}

/**
 * The double 'use client' directive pattern is intentional:
 * 1. Top-level directive marks the entire module as client-side
 * 2. IIFE-wrapped component with its own directive ensures:
 *    - Component is properly tree-shaken (via @__PURE__)
 *    - Component maintains client context when code-split
 *    - Execution scope is preserved
 *
 * This pattern is particularly important for Next.js's module
 * system and its handling of Server/Client Components.
 */
export const Monitoring = /* @__PURE__ */ (() => {
  'use client';
  return function Monitoring(props: MonitoringWithoutRouteProps) {
    return createElement(
      Suspense,
      { fallback: null },
      createElement(MonitoringInner, props),
    );
  };
})();
</file>

<file path="packages/scan/src/core/monitor/params/react-router-v5.ts">
import { createElement } from 'react';
import { useRouteMatch, useLocation } from 'react-router';
import { Monitoring as BaseMonitoring, type MonitoringWithoutRouteProps} from '..';
import { computeRoute } from './utils';
import type { RouteInfo } from './types';

const useRoute = (): RouteInfo => {
  const match = useRouteMatch();
  const { pathname } = useLocation();
  const params = match?.params || {};

  if (!params) {
    return { route: null, path: pathname };
  }

  return {
    route: computeRoute(pathname, params),
    path: pathname,
  };
};

function ReactRouterV5Monitor(props: MonitoringWithoutRouteProps) {
  const { route, path } = useRoute();
  return createElement(BaseMonitoring, {
    ...props,
    route,
    path,
  });
}

export { ReactRouterV5Monitor as Monitoring };
</file>

<file path="packages/scan/src/core/monitor/params/react-router-v6.ts">
import { createElement } from 'react';
import { useParams, useLocation } from 'react-router';
import { Monitoring as BaseMonitoring, type MonitoringWithoutRouteProps } from '..';
import { computeReactRouterRoute } from './utils';
import type { RouteInfo } from './types';

const useRoute = (): RouteInfo => {
  const params = useParams();
  const { pathname } = useLocation();

  if (!params || Object.keys(params).length === 0) {
    return { route: null, path: pathname };
  }

  const validParams = Object.fromEntries(
    Object.entries(params).filter(([_, v]) => v !== undefined),
  ) as Record<string, string | Array<string>>;

  return {
    route: computeReactRouterRoute(pathname, validParams),
    path: pathname,
  };
};

function ReactRouterMonitor(props: MonitoringWithoutRouteProps) {
  const { route, path } = useRoute();
  return createElement(BaseMonitoring, {
    ...props,
    route,
    path,
  });
}

export { ReactRouterMonitor as Monitoring };
</file>

<file path="packages/scan/src/core/monitor/params/remix.ts">
import { createElement } from 'react';
import { useParams, useLocation } from '@remix-run/react';
import { Monitoring as BaseMonitoring, type MonitoringWithoutRouteProps} from '..';
import { computeReactRouterRoute } from './utils';
import type { RouteInfo } from './types';

const useRoute = (): RouteInfo => {
  const params = useParams();
  const { pathname } = useLocation();

  if (!params || Object.keys(params).length === 0) {
    return { route: null, path: pathname };
  }

  const validParams = params as Record<string, string>;

  return {
    route: computeReactRouterRoute(pathname, validParams),
    path: pathname,
  };
};

function RemixMonitor(props: MonitoringWithoutRouteProps) {
  const { route, path } = useRoute();
  return createElement(BaseMonitoring, {
    ...props,
    route,
    path,
  });
}

export { RemixMonitor as Monitoring };
</file>

<file path="packages/scan/src/core/monitor/params/types.ts">
export interface RouteInfo {
  route: string | null;
  path: string;
}
</file>

<file path="packages/scan/src/core/monitor/params/utils.ts">
// adapted from vercel analytics https://github.dev/vercel/analytics
interface DynamicSegmentFormatter {
  param: (key: string) => string;
  catchAll: (key: string) => string;
}

function computeRouteWithFormatter(
  pathname: string | null,
  pathParams: Record<string, string | Array<string>> | null,
  formatter: DynamicSegmentFormatter,
): string | null {
  if (!pathname || !pathParams) {
    return pathname;
  }

  let result = pathname;
  try {
    const entries = Object.entries(pathParams);
    // simple keys must be handled first
    for (const [key, value] of entries) {
      if (!Array.isArray(value)) {
        const matcher = turnValueToRegExp(value);
        if (matcher.test(result)) {
          result = result.replace(matcher, formatter.param(key));
        }
      }
    }
    // array values next
    for (const [key, value] of entries) {
      if (Array.isArray(value)) {
        const matcher = turnValueToRegExp(value.join('/'));
        if (matcher.test(result)) {
          result = result.replace(matcher, formatter.catchAll(key));
        }
      }
    }
    return result;
  } catch {
    return pathname;
  }
}

// Next.js style routes (default)
export function computeRoute(
  pathname: string | null,
  pathParams: Record<string, string | Array<string>> | null,
): string | null {
  return computeRouteWithFormatter(pathname, pathParams, {
    param: (key) => `/[${key}]`,
    catchAll: (key) => `/[...${key}]`,
  });
}

export function computeReactRouterRoute(
  pathname: string | null,
  pathParams: Record<string, string | Array<string>> | null,
): string | null {
  return computeRouteWithFormatter(pathname, pathParams, {
    param: (key) => `/:${key}`,
    catchAll: (key) => `/*${key}`,
  });
}

export function turnValueToRegExp(value: string): RegExp {
  return new RegExp(`/${escapeRegExp(value)}(?=[/?#]|$)`);
}

export function escapeRegExp(string: string): string {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
</file>

<file path="packages/scan/src/core/monitor/network.ts">
import { Store } from '..';
import { GZIP_MAX_LEN, GZIP_MIN_LEN, MAX_PENDING_REQUESTS } from './constants';
import type {
  Component,
  IngestRequest,
  Interaction,
  InternalInteraction,
} from './types';
import { getSession } from './utils';

const INTERACTION_TIME_TILL_COMPLETED = 4000;

const truncate = (value: number, decimalPlaces = 4) =>
  Number(value.toFixed(decimalPlaces));

export const flush = async (): Promise<void> => {
  const monitor = Store.monitor.value;
  if (
    !monitor ||
    !navigator.onLine ||
    !monitor.url ||
    !monitor.interactions.length
  ) {
    return;
  }
  const now = performance.now();
  // We might trigger flush before the interaction is completed,
  // so we need to split them into pending and completed by an arbitrary time.
  const pendingInteractions = new Array<InternalInteraction>();
  const completedInteractions = new Array<InternalInteraction>();

  const interactions = monitor.interactions;
  for (let i = 0; i < interactions.length; i++) {
    const interaction = interactions[i];
    const timeSinceStart = now - interaction.performanceEntry.startTime;
    if (timeSinceStart <= 30000) {
      // Skip interactions older than 30 seconds to prevent memory leaks
      if (timeSinceStart <= INTERACTION_TIME_TILL_COMPLETED) {
        pendingInteractions.push(interaction);
      } else {
        completedInteractions.push(interaction);
      }
    }
  }

  if (!completedInteractions.length)
    // nothing to flush
    return;

  // idempotent
  const session = await getSession({
    commit: monitor.commit,
    branch: monitor.branch,
  }).catch(() => null);

  if (!session) return;

  const aggregatedComponents = new Array<Component>();
  const aggregatedInteractions = new Array<Interaction>();
  for (let i = 0; i < completedInteractions.length; i++) {
    const interaction = completedInteractions[i];

    // META INFORMATION IS FOR DEBUGGING THIS MUST BE REMOVED SOON
    const {
      duration,
      entries,
      id,
      inputDelay,
      latency,
      presentationDelay,
      processingDuration,
      processingEnd,
      processingStart,
      referrer,
      startTime,
      timeOrigin,
      timeSinceTabInactive,
      timestamp,
      type,
      visibilityState,
    } = interaction.performanceEntry;
    aggregatedInteractions.push({
      id: i,
      path: interaction.componentPath,
      name: interaction.componentName,
      time: truncate(duration),
      timestamp,
      type,
      // fixme: we can aggregate around url|route|commit|branch better to compress payload
      url: interaction.url,
      route: interaction.route,
      commit: interaction.commit,
      branch: interaction.branch,
      uniqueInteractionId: interaction.uniqueInteractionId,
      meta: {
        performanceEntry: {
          id,
          inputDelay: truncate(inputDelay),
          latency: truncate(latency),
          presentationDelay: truncate(presentationDelay),
          processingDuration: truncate(processingDuration),
          processingEnd,
          processingStart,
          referrer,
          startTime,
          timeOrigin,
          timeSinceTabInactive,
          visibilityState,
          duration: truncate(duration),
          entries: entries.map((entry) => {
            const {
              duration,
              entryType,
              interactionId,
              name,
              processingEnd,
              processingStart,
              startTime,
            } = entry;
            return {
              duration: truncate(duration),
              entryType,
              interactionId,
              name,
              processingEnd,
              processingStart,
              startTime,
            };
          }),
        },
      },
    });

    const components = Array.from(interaction.components.entries());
    for (let j = 0; j < components.length; j++) {
      const [name, component] = components[j];
      aggregatedComponents.push({
        name,
        instances: component.fibers.size,
        interactionId: i,
        renders: component.renders,
        selfTime:
          typeof component.selfTime === 'number'
            ? truncate(component.selfTime)
            : component.selfTime,
        totalTime:
          typeof component.totalTime === 'number'
            ? truncate(component.totalTime)
            : component.totalTime,
      });
    }
  }

  const payload: IngestRequest = {
    interactions: aggregatedInteractions,
    components: aggregatedComponents,
    session: {
      ...session,
      url: window.location.toString(),
      route: monitor.route, // this might be inaccurate but used to caculate which paths all the unique sessions are coming from without having to join on the interactions table (expensive)
      wifi: session.wifi ?? '',
    },
  };

  monitor.pendingRequests++;
  monitor.interactions = pendingInteractions;
  try {
    transport(monitor.url, payload)
      .then(() => {
        monitor.pendingRequests--;
        // there may still be renders associated with these interaction, so don't flush just yet
      })
      .catch(async () => {
        // we let the next interval handle retrying, instead of explicitly retrying
        monitor.interactions = monitor.interactions.concat(
          completedInteractions,
        );
      });
  } catch {
    /* */
  }

  // Keep only recent interactions
  monitor.interactions = pendingInteractions;
};

const CONTENT_TYPE = 'application/json';
const supportsCompression = typeof CompressionStream === 'function';

export const compress = async (payload: string): Promise<ArrayBuffer> => {
  const stream = new Blob([payload], { type: CONTENT_TYPE })
    .stream()
    .pipeThrough(new CompressionStream('gzip'));
  return new Response(stream).arrayBuffer();
};

/**
 * Modified from @palette.dev/browser:
 *
 * @see https://gist.github.com/aidenybai/473689493f2d5d01bbc52e2da5950b45#file-palette-dev-browser-dist-palette-dev-mjs-L365
 */
interface RequestHeaders {
  'Content-Type': string;
  'Content-Encoding'?: string;
  'x-api-key'?: string;
}

export const transport = async (
  initialUrl: string,
  payload: IngestRequest,
): Promise<{ ok: boolean }> => {
  const fail = { ok: false };
  const json = JSON.stringify(payload);
  // gzip may not be worth it for small payloads,
  // only use it if the payload is large enough
  const shouldCompress = json.length > GZIP_MIN_LEN;
  const body =
    shouldCompress && supportsCompression ? await compress(json) : json;

  if (!navigator.onLine) return fail;
  const headerValues: RequestHeaders = {
    'Content-Type': CONTENT_TYPE,
    'Content-Encoding': shouldCompress ? 'gzip' : undefined,
    'x-api-key': Store.monitor.value?.apiKey ?? undefined,
  };
  let url = initialUrl;
  if (shouldCompress) url += '?z=1';
  const size = typeof body === 'string' ? body.length : body.byteLength;

  return fetch(url, {
    body,
    method: 'POST',
    referrerPolicy: 'origin',
    /**
     * Outgoing requests are usually cancelled when navigating to a different page, causing a "TypeError: Failed to
     * fetch" error and sending a "network_error" client-outcome - in Chrome, the request status shows "(cancelled)".
     * The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're
     * frequently sending events right before the user is switching pages (e.g., when finishing navigation transactions).
     *
     * This is the modern alternative to the navigator.sendBeacon API.
     * @see https://javascript.info/fetch-api#keepalive
     *
     * Gotchas:
     * - `keepalive` isn't supported by Firefox
     * - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch):
     *   If the sum of contentLength and inflightKeepaliveBytes is greater than 64 kibibytes, then return a network error.
     *   We will therefore only activate the flag when we're below that limit.
     * - There is also a limit of requests that can be open at the same time, so we also limit this to 15.
     *
     * @see https://github.com/getsentry/sentry-javascript/pull/7553
     */
    keepalive:
      GZIP_MAX_LEN > size &&
      MAX_PENDING_REQUESTS > (Store.monitor.value?.pendingRequests ?? 0),
    priority: 'low',
    // mode: 'no-cors',
    headers: headerValues as unknown as HeadersInit,
  });
};
</file>

<file path="packages/scan/src/core/monitor/types.ts">
import type { Fiber } from 'bippy';

export enum Device {
  DESKTOP = 0,
  TABLET = 1,
  MOBILE = 2,
}

export interface Session {
  id: string;
  device: Device;
  agent: string;
  wifi: string;
  cpu: number;
  gpu: string | null;
  mem: number;
  url: string;
  route: string | null;
  commit: string | null;
  branch: string | null;
}

export interface Interaction {
  id: string | number; // index of the interaction in the batch at ingest | server converts to a hashed string from route, type, name, path
  path: Array<string>; // the path of the interaction
  name: string; // name of interaction
  type: string; // type of interaction i.e pointer
  time: number; // time of interaction in ms
  timestamp: number;
  url: string;
  route: string | null; // the computed route that handles dynamic params

  // Regression tracking
  commit: string | null;
  branch: string | null;

  // clickhouse + ingest specific types
  projectId?: string;
  sessionId?: string;
  uniqueInteractionId: string;

  meta?: unknown;
}

export interface Component {
  interactionId: string | number; // grouping components by interaction
  name: string;
  renders: number; // how many times it re-rendered / instances (normalized)
  instances: number; // instances which will be used to get number of total renders by * by renders
  totalTime?: number;
  selfTime?: number;
}

export interface IngestRequest {
  interactions: Array<Interaction>;
  components: Array<Component>;
  session: Session;
}

// used internally in runtime for interaction tracking. converted to Interaction when flushed
export interface InternalInteraction {
  componentName: string;
  url: string;
  route: string | null;
  commit: string | null;
  branch: string | null;
  uniqueInteractionId: string; // uniqueInteractionId is unique to the session and provided by performance observer.
  componentPath: Array<string>;
  performanceEntry: PerformanceInteraction;
  components: Map<string, InternalComponentCollection>;
}
interface InternalComponentCollection {
  uniqueInteractionId: string;
  name: string;
  renders: number; // re-renders associated with the set of components in this collection
  totalTime?: number;
  selfTime?: number;
  fibers: Set<Fiber>; // no references will exist to this once array is cleared after flush, so we don't have to worry about memory leaks
  retiresAllowed: number; // if our server is down and we can't collect fibers/ user has no network, it will memory leak. We need to only allow a set amount of retries before it gets gcd
}

export interface PerformanceInteractionEntry extends PerformanceEntry {
  interactionId: string;
  target: Element;
  name: string;
  duration: number;
  startTime: number;
  processingStart: number;
  processingEnd: number;
  entryType: string;
}
export interface PerformanceInteraction {
  id: string;
  latency: number;
  entries: Array<PerformanceInteractionEntry>;
  target: Element;
  type: 'pointer' | 'keyboard';
  startTime: number;
  processingStart: number;
  processingEnd: number;
  duration: number;
  inputDelay: number;
  processingDuration: number;
  presentationDelay: number;
  timestamp: number;
  timeSinceTabInactive: number | 'never-hidden';
  visibilityState: DocumentVisibilityState;
  timeOrigin: number;
  referrer: string;
}
</file>

<file path="packages/scan/src/core/fast-serialize.test.ts">
import { describe, expect, it } from 'vitest';
import { fastSerialize } from '~core/instrumentation';

describe('fastSerialize', () => {
  it('serializes null', () => {
    expect(fastSerialize(null)).toBe('null');
  });

  it('serializes undefined', () => {
    expect(fastSerialize(undefined)).toBe('undefined');
  });

  it('serializes strings', () => {
    expect(fastSerialize('hello')).toBe('hello');
    expect(fastSerialize('')).toBe('');
  });

  it('serializes numbers', () => {
    expect(fastSerialize(42)).toBe('42');
    expect(fastSerialize(0)).toBe('0');
    expect(fastSerialize(Number.NaN)).toBe('NaN');
  });

  it('serializes booleans', () => {
    expect(fastSerialize(true)).toBe('true');
    expect(fastSerialize(false)).toBe('false');
  });

  it('serializes functions', () => {
    const testFunc = (_x: 2) => 3;
    expect(fastSerialize(testFunc)).toBe('(_x) => 3');
  });

  it('serializes arrays', () => {
    expect(fastSerialize([])).toBe('[]');
    expect(fastSerialize([1, 2, 3])).toBe('[3]');
  });

  it('serializes plain objects', () => {
    expect(fastSerialize({})).toBe('{}');
    expect(fastSerialize({ a: 1, b: 2 })).toBe('{2}');
  });

  it('serializes deeply nested objects with depth limit', () => {
    const nested = { a: { b: { c: 1 } } };
    expect(fastSerialize(nested, 0)).toBe('{1}');
    expect(fastSerialize(nested, -1)).toBe('…');
  });

  it('serializes objects with custom constructors', () => {
    class CustomClass {}
    const instance = new CustomClass();
    expect(fastSerialize(instance)).toBe('CustomClass{…}');
  });

  it('serializes unknown objects gracefully', () => {
    const date = new Date();
    const serialized = fastSerialize(date);
    expect(serialized.includes('Date')).toBe(true);
  });
});
</file>

<file path="packages/scan/src/html-to-image/apply-style.ts">
import type { Options } from './types'

export function applyStyle<T extends HTMLElement>(
  node: T,
  options: Options,
): T {
  const { style } = node

  if (options.backgroundColor) {
    style.backgroundColor = options.backgroundColor
  }

  if (options.width) {
    style.width = `${options.width}px`
  }

  if (options.height) {
    style.height = `${options.height}px`
  }

  const manual = options.style
  if (manual != null) {
    Object.keys(manual).forEach((key: any) => {
      style[key] = manual[key] as string
    })
  }

  return node
}
</file>

<file path="packages/scan/src/html-to-image/clone-node.ts">
import type { Options } from './types'
import { clonePseudoElements } from './clone-pseudos'
import {
  createImage,
  toArray,
  isInstanceOfElement,
  getStyleProperties,
} from './util'
import { getMimeType } from './mimes'
import { resourceToDataURL } from './dataurl'

async function cloneCanvasElement(canvas: HTMLCanvasElement) {
  const dataURL = canvas.toDataURL()
  if (dataURL === 'data:,') {
    return canvas.cloneNode(false) as HTMLCanvasElement
  }
  return createImage(dataURL)
}

async function cloneVideoElement(video: HTMLVideoElement, options: Options) {
  if (video.currentSrc) {
    const canvas = document.createElement('canvas')
    const ctx = canvas.getContext('2d')
    canvas.width = video.clientWidth
    canvas.height = video.clientHeight
    ctx?.drawImage(video, 0, 0, canvas.width, canvas.height)
    const dataURL = canvas.toDataURL()
    return createImage(dataURL)
  }

  const poster = video.poster
  const contentType = getMimeType(poster)
  const dataURL = await resourceToDataURL(poster, contentType, options)
  return createImage(dataURL)
}

async function cloneIFrameElement(iframe: HTMLIFrameElement, options: Options) {
  try {
    if (iframe?.contentDocument?.body) {
      return (await cloneNode(
        iframe.contentDocument.body,
        options,
        true,
      )) as HTMLBodyElement
    }
  } catch {
    // Failed to clone iframe
  }

  return iframe.cloneNode(false) as HTMLIFrameElement
}

async function cloneSingleNode<T extends HTMLElement>(
  node: T,
  options: Options,
): Promise<HTMLElement> {
  if (isInstanceOfElement(node, HTMLCanvasElement)) {
    return cloneCanvasElement(node)
  }

  if (isInstanceOfElement(node, HTMLVideoElement)) {
    return cloneVideoElement(node, options)
  }

  if (isInstanceOfElement(node, HTMLIFrameElement)) {
    return cloneIFrameElement(node, options)
  }

  return node.cloneNode(isSVGElement(node)) as T
}

const isSlotElement = (node: HTMLElement): node is HTMLSlotElement =>
  node.tagName != null && node.tagName.toUpperCase() === 'SLOT'

const isSVGElement = (node: HTMLElement): node is HTMLSlotElement =>
  node.tagName != null && node.tagName.toUpperCase() === 'SVG'

async function cloneChildren<T extends HTMLElement>(
  nativeNode: T,
  clonedNode: T,
  options: Options,
): Promise<T> {
  if (isSVGElement(clonedNode)) {
    return clonedNode
  }

  let children: T[] = []

  if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {
    children = toArray<T>(nativeNode.assignedNodes())
  } else if (
    isInstanceOfElement(nativeNode, HTMLIFrameElement) &&
    nativeNode.contentDocument?.body
  ) {
    children = toArray<T>(nativeNode.contentDocument.body.childNodes)
  } else {
    children = toArray<T>((nativeNode.shadowRoot ?? nativeNode).childNodes)
  }

  if (
    children.length === 0 ||
    isInstanceOfElement(nativeNode, HTMLVideoElement)
  ) {
    return clonedNode
  }

  await children.reduce(
    (deferred, child) =>
      deferred
        .then(() => cloneNode(child, options))
        .then((clonedChild: HTMLElement | null) => {
          if (clonedChild) {
            clonedNode.appendChild(clonedChild)
          }
        }),
    Promise.resolve(),
  )

  return clonedNode
}

function cloneCSSStyle<T extends HTMLElement>(
  nativeNode: T,
  clonedNode: T,
  options: Options,
) {
  const targetStyle = clonedNode.style
  if (!targetStyle) {
    return
  }

  const sourceStyle = window.getComputedStyle(nativeNode)
  if (sourceStyle.cssText) {
    targetStyle.cssText = sourceStyle.cssText
    targetStyle.transformOrigin = sourceStyle.transformOrigin
  } else {
    getStyleProperties(options).forEach((name) => {
      let value = sourceStyle.getPropertyValue(name)
      if (name === 'font-size' && value.endsWith('px')) {
        const reducedFont =
          Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1
        value = `${reducedFont}px`
      }

      if (
        isInstanceOfElement(nativeNode, HTMLIFrameElement) &&
        name === 'display' &&
        value === 'inline'
      ) {
        value = 'block'
      }

      if (name === 'd' && clonedNode.getAttribute('d')) {
        value = `path(${clonedNode.getAttribute('d')})`
      }

      targetStyle.setProperty(
        name,
        value,
        sourceStyle.getPropertyPriority(name),
      )
    })
  }
}

function cloneInputValue<T extends HTMLElement>(nativeNode: T, clonedNode: T) {
  if (isInstanceOfElement(nativeNode, HTMLTextAreaElement)) {
    clonedNode.innerHTML = nativeNode.value
  }

  if (isInstanceOfElement(nativeNode, HTMLInputElement)) {
    clonedNode.setAttribute('value', nativeNode.value)
  }
}

function cloneSelectValue<T extends HTMLElement>(nativeNode: T, clonedNode: T) {
  if (isInstanceOfElement(nativeNode, HTMLSelectElement)) {
    const clonedSelect = clonedNode as any as HTMLSelectElement
    const selectedOption = Array.from(clonedSelect.children).find(
      (child) => nativeNode.value === child.getAttribute('value'),
    )

    if (selectedOption) {
      selectedOption.setAttribute('selected', '')
    }
  }
}

function decorate<T extends HTMLElement>(
  nativeNode: T,
  clonedNode: T,
  options: Options,
): T {
  if (isInstanceOfElement(clonedNode, Element)) {
    cloneCSSStyle(nativeNode, clonedNode, options)
    clonePseudoElements(nativeNode, clonedNode, options)
    cloneInputValue(nativeNode, clonedNode)
    cloneSelectValue(nativeNode, clonedNode)
  }

  return clonedNode
}

async function ensureSVGSymbols<T extends HTMLElement>(
  clone: T,
  options: Options,
) {
  const uses = clone.querySelectorAll ? clone.querySelectorAll('use') : []
  if (uses.length === 0) {
    return clone
  }

  const processedDefs: { [key: string]: HTMLElement } = {}
  for (let i = 0; i < uses.length; i++) {
    const use = uses[i]
    const id = use.getAttribute('xlink:href')
    if (id) {
      const exist = clone.querySelector(id)
      const definition = document.querySelector(id) as HTMLElement
      if (!exist && definition && !processedDefs[id]) {
        // eslint-disable-next-line no-await-in-loop
        processedDefs[id] = (await cloneNode(definition, options, true))!
      }
    }
  }

  const nodes = Object.values(processedDefs)
  if (nodes.length) {
    const ns = 'http://www.w3.org/1999/xhtml'
    const svg = document.createElementNS(ns, 'svg')
    svg.setAttribute('xmlns', ns)
    svg.style.position = 'absolute'
    svg.style.width = '0'
    svg.style.height = '0'
    svg.style.overflow = 'hidden'
    svg.style.display = 'none'

    const defs = document.createElementNS(ns, 'defs')
    svg.appendChild(defs)

    for (let i = 0; i < nodes.length; i++) {
      defs.appendChild(nodes[i])
    }

    clone.appendChild(svg)
  }

  return clone
}

export async function cloneNode<T extends HTMLElement>(
  node: T,
  options: Options,
  isRoot?: boolean,
): Promise<T | null> {
  if (!isRoot && options.filter && !options.filter(node)) {
    return null
  }

  return Promise.resolve(node)
    .then((clonedNode) => cloneSingleNode(clonedNode, options) as Promise<T>)
    .then((clonedNode) => cloneChildren(node, clonedNode, options))
    .then((clonedNode) => decorate(node, clonedNode, options))
    .then((clonedNode) => ensureSVGSymbols(clonedNode, options))
}
</file>

<file path="packages/scan/src/html-to-image/clone-pseudos.ts">
import type { Options } from './types'
import { uuid, getStyleProperties } from './util'

type Pseudo = ':before' | ':after'

function formatCSSText(style: CSSStyleDeclaration) {
  const content = style.getPropertyValue('content')
  return `${style.cssText} content: '${content.replace(/'|"/g, '')}';`
}

function formatCSSProperties(style: CSSStyleDeclaration, options: Options) {
  return getStyleProperties(options)
    .map((name) => {
      const value = style.getPropertyValue(name)
      const priority = style.getPropertyPriority(name)

      return `${name}: ${value}${priority ? ' !important' : ''};`
    })
    .join(' ')
}

function getPseudoElementStyle(
  className: string,
  pseudo: Pseudo,
  style: CSSStyleDeclaration,
  options: Options,
): Text {
  const selector = `.${className}:${pseudo}`
  const cssText = style.cssText
    ? formatCSSText(style)
    : formatCSSProperties(style, options)

  return document.createTextNode(`${selector}{${cssText}}`)
}

function clonePseudoElement<T extends HTMLElement>(
  nativeNode: T,
  clonedNode: T,
  pseudo: Pseudo,
  options: Options,
) {
  const style = window.getComputedStyle(nativeNode, pseudo)
  const content = style.getPropertyValue('content')
  if (content === '' || content === 'none') {
    return
  }

  const className = uuid()
  try {
    clonedNode.className = `${clonedNode.className} ${className}`
  } catch (err) {
    return
  }

  const styleElement = document.createElement('style')
  styleElement.appendChild(
    getPseudoElementStyle(className, pseudo, style, options),
  )
  clonedNode.appendChild(styleElement)
}

export function clonePseudoElements<T extends HTMLElement>(
  nativeNode: T,
  clonedNode: T,
  options: Options,
) {
  clonePseudoElement(nativeNode, clonedNode, ':before', options)
  clonePseudoElement(nativeNode, clonedNode, ':after', options)
}
</file>

<file path="packages/scan/src/html-to-image/dataurl.ts">
import { Options } from './types'

function getContentFromDataUrl(dataURL: string) {
  return dataURL.split(/,/)[1]
}

export function isDataUrl(url: string) {
  return url.search(/^(data:)/) !== -1
}

export function makeDataUrl(content: string, mimeType: string) {
  return `data:${mimeType};base64,${content}`
}

export async function fetchAsDataURL<T>(
  url: string,
  init: RequestInit | undefined,
  process: (data: { result: string; res: Response }) => T,
): Promise<T> {
  const res = await fetch(url, init)
  if (res.status === 404) {
    throw new Error(`Resource "${res.url}" not found`)
  }
  const blob = await res.blob()
  return new Promise<T>((resolve, reject) => {
    const reader = new FileReader()
    reader.onerror = reject
    reader.onloadend = () => {
      try {
        resolve(process({ res, result: reader.result as string }))
      } catch (error) {
        reject(error)
      }
    }

    reader.readAsDataURL(blob)
  })
}

const cache: { [url: string]: string } = {}

function getCacheKey(
  url: string,
  contentType: string | undefined,
  includeQueryParams: boolean | undefined,
) {
  let key = url.replace(/\?.*/, '')

  if (includeQueryParams) {
    key = url
  }

  // font resource
  if (/ttf|otf|eot|woff2?/i.test(key)) {
    key = key.replace(/.*\//, '')
  }

  return contentType ? `[${contentType}]${key}` : key
}

export async function resourceToDataURL(
  resourceUrl: string,
  contentType: string | undefined,
  options: Options,
) {
  const cacheKey = getCacheKey(
    resourceUrl,
    contentType,
    options.includeQueryParams,
  )

  if (cache[cacheKey] != null) {
    return cache[cacheKey]
  }

  // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache
  if (options.cacheBust) {
    // eslint-disable-next-line no-param-reassign
    resourceUrl += (/\?/.test(resourceUrl) ? '&' : '?') + new Date().getTime()
  }

  let dataURL: string
  try {
    const content = await fetchAsDataURL(
      resourceUrl,
      options.fetchRequestInit,
      ({ res, result }) => {
        if (!contentType) {
          // eslint-disable-next-line no-param-reassign
          contentType = res.headers.get('Content-Type') || ''
        }
        return getContentFromDataUrl(result)
      },
    )
    dataURL = makeDataUrl(content, contentType!)
  } catch (error: any) {
    dataURL = options.imagePlaceholder || ''

    let msg = `Failed to fetch resource: ${resourceUrl}`
    if (error) {
      msg = typeof error === 'string' ? error : error.message
    }

    if (msg) {
      console.warn(msg)
    }
  }

  cache[cacheKey] = dataURL
  return dataURL
}
</file>

<file path="packages/scan/src/html-to-image/embed-images.ts">
import { Options } from './types'
import { embedResources } from './embed-resources'
import { toArray, isInstanceOfElement } from './util'
import { isDataUrl, resourceToDataURL } from './dataurl'
import { getMimeType } from './mimes'

async function embedProp(
  propName: string,
  node: HTMLElement,
  options: Options,
) {
  const propValue = node.style?.getPropertyValue(propName)
  if (propValue) {
    const cssString = await embedResources(propValue, null, options)
    node.style.setProperty(
      propName,
      cssString,
      node.style.getPropertyPriority(propName),
    )
    return true
  }
  return false
}

async function embedBackground<T extends HTMLElement>(
  clonedNode: T,
  options: Options,
) {
  ;(await embedProp('background', clonedNode, options)) ||
    (await embedProp('background-image', clonedNode, options))
  ;(await embedProp('mask', clonedNode, options)) ||
    (await embedProp('-webkit-mask', clonedNode, options)) ||
    (await embedProp('mask-image', clonedNode, options)) ||
    (await embedProp('-webkit-mask-image', clonedNode, options))
}

async function embedImageNode<T extends HTMLElement | SVGImageElement>(
  clonedNode: T,
  options: Options,
) {
  const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement);

  if (
    !(isImageElement && !isDataUrl(clonedNode.src)) &&
    !(
      isInstanceOfElement(clonedNode, SVGImageElement) &&
      !isDataUrl(clonedNode.href.baseVal)
    )
  ) {
    return;
  }

  const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal;

  // resourceToDataURL handles initial fetch errors and returns a fallback
  const dataURL = await resourceToDataURL(url, getMimeType(url), options);

  // Wait for the browser to process the assigned dataURL (or fallback)
  await new Promise((resolve, reject) => { // Keep reject for custom handler flexibility
    clonedNode.onload = resolve;
    clonedNode.onerror = options.onImageErrorHandler
      ? (...attributes) => { // If user provided a handler
          try {
            // Let the custom handler decide whether to resolve or reject
             Promise.resolve(options.onImageErrorHandler!(...attributes))
                .then(resolve) // Resolve if the handler resolves/returns non-promise
                .catch(reject); // Reject if the handler throws/rejects
          } catch (error) {
            console.error("[html-to-image] Error in custom onImageErrorHandler:", error);
            // If the handler itself throws, reject to signal the handler failed
            reject(error);
          }
        }
      : () => { // <-- Default case: Changed from reject to resolve
          console.warn(`[html-to-image] Failed to load image data URL (or placeholder) for: ${url}. Proceeding anyway.`);
          resolve(undefined); // Resolve to allow the process to continue
        };

    // Assign the dataURL (could be original or fallback)
    const image = clonedNode as HTMLImageElement;
    if (image.decode) {
       // Use decode for potentially better performance/control, but still resolve on error
       image.decode().then(resolve).catch(() => {
           console.warn(`[html-to-image] Image decode() failed for: ${url}. Proceeding anyway.`);
           resolve(undefined); // Resolve even if decode fails
       });
    }

    if (image.loading === 'lazy') {
      image.loading = 'eager';
    }

    if (isImageElement) {
      clonedNode.srcset = ''; // Clear srcset as we are using src
      clonedNode.src = dataURL;
    } else {
      clonedNode.href.baseVal = dataURL;
    }

    // Safety timeout in case load/error/decode events never fire
    const safetyTimeout = setTimeout(() => {
        console.warn(`[html-to-image] Image load timeout for ${url}. Proceeding.`);
        // Ensure listeners are removed before resolving to avoid potential double resolves
        clonedNode.removeEventListener('load', clearSafetyTimeout);
        clonedNode.removeEventListener('error', clearSafetyTimeout);
        resolve(undefined);
    }, 5000); // 5-second timeout

    const clearSafetyTimeout = () => clearTimeout(safetyTimeout);
    clonedNode.addEventListener('load', clearSafetyTimeout, { once: true });
    clonedNode.addEventListener('error', clearSafetyTimeout, { once: true });
    // No need to add listener for decode, its promise handles completion/error

  }); // End of Promise
} // End of embedImageNode

async function embedChildren<T extends HTMLElement>(
  clonedNode: T,
  options: Options,
) {
  const children = toArray<HTMLElement>(clonedNode.childNodes)
  const deferreds = children.map((child) => embedImages(child, options))
  await Promise.all(deferreds).then(() => clonedNode)
}

export async function embedImages<T extends HTMLElement>(
  clonedNode: T,
  options: Options,
) {
  if (isInstanceOfElement(clonedNode, Element)) {
    await embedBackground(clonedNode, options)
    await embedImageNode(clonedNode, options)
    await embedChildren(clonedNode, options)
  }
}
</file>

<file path="packages/scan/src/html-to-image/embed-resources.ts">
import { Options } from './types'
import { resolveUrl } from './util'
import { getMimeType } from './mimes'
import { isDataUrl, makeDataUrl, resourceToDataURL } from './dataurl'

const URL_REGEX = /url\((['"]?)([^'"]+?)\1\)/g
const URL_WITH_FORMAT_REGEX = /url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g
const FONT_SRC_REGEX = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g

function toRegex(url: string): RegExp {
  // eslint-disable-next-line no-useless-escape
  const escaped = url.replace(/([.*+?^${}()|\[\]\/\\])/g, '\\$1')
  return new RegExp(`(url\\(['"]?)(${escaped})(['"]?\\))`, 'g')
}

export function parseURLs(cssText: string): string[] {
  const urls: string[] = []

  cssText.replace(URL_REGEX, (raw, quotation, url) => {
    urls.push(url)
    return raw
  })

  return urls.filter((url) => !isDataUrl(url))
}

export async function embed(
  cssText: string,
  resourceURL: string,
  baseURL: string | null,
  options: Options,
  getContentFromUrl?: (url: string) => Promise<string>,
): Promise<string> {
  try {
    const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL
    const contentType = getMimeType(resourceURL)
    let dataURL: string
    if (getContentFromUrl) {
      const content = await getContentFromUrl(resolvedURL)
      dataURL = makeDataUrl(content, contentType)
    } else {
      dataURL = await resourceToDataURL(resolvedURL, contentType, options)
    }
    return cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`)
  } catch (error) {
    // pass
  }
  return cssText
}

function filterPreferredFontFormat(
  str: string,
  { preferredFontFormat }: Options,
): string {
  return !preferredFontFormat
    ? str
    : str.replace(FONT_SRC_REGEX, (match: string) => {
        // eslint-disable-next-line no-constant-condition
        while (true) {
          const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || []
          if (!format) {
            return ''
          }

          if (format === preferredFontFormat) {
            return `src: ${src};`
          }
        }
      })
}

export function shouldEmbed(url: string): boolean {
  return url.search(URL_REGEX) !== -1
}

export async function embedResources(
  cssText: string,
  baseUrl: string | null,
  options: Options,
): Promise<string> {
  if (!shouldEmbed(cssText)) {
    return cssText
  }

  const filteredCSSText = filterPreferredFontFormat(cssText, options)
  const urls = parseURLs(filteredCSSText)
  return urls.reduce(
    (deferred, url) =>
      deferred.then((css) => embed(css, url, baseUrl, options)),
    Promise.resolve(filteredCSSText),
  )
}
</file>

<file path="packages/scan/src/html-to-image/embed-webfonts.ts">
import type { Options } from './types'
import { toArray } from './util'
import { fetchAsDataURL } from './dataurl'
import { shouldEmbed, embedResources } from './embed-resources'

interface Metadata {
  url: string
  cssText: string
}

const cssFetchCache: { [href: string]: Metadata } = {}

async function fetchCSS(url: string) {
  let cache = cssFetchCache[url]
  if (cache != null) {
    return cache
  }

  const res = await fetch(url)
  const cssText = await res.text()
  cache = { url, cssText }

  cssFetchCache[url] = cache

  return cache
}

async function embedFonts(data: Metadata, options: Options): Promise<string> {
  let cssText = data.cssText
  const regexUrl = /url\(["']?([^"')]+)["']?\)/g
  const fontLocs = cssText.match(/url\([^)]+\)/g) || []
  const loadFonts = fontLocs.map(async (loc: string) => {
    let url = loc.replace(regexUrl, '$1')
    if (!url.startsWith('https://')) {
      url = new URL(url, data.url).href
    }

    return fetchAsDataURL<[string, string]>(
      url,
      options.fetchRequestInit,
      ({ result }) => {
        cssText = cssText.replace(loc, `url(${result})`)
        return [loc, result]
      },
    )
  })

  return Promise.all(loadFonts).then(() => cssText)
}

function parseCSS(source: string) {
  if (source == null) {
    return []
  }

  const result: string[] = []
  const commentsRegex = /(\/\*[\s\S]*?\*\/)/gi
  // strip out comments
  let cssText = source.replace(commentsRegex, '')

  // eslint-disable-next-line prefer-regex-literals
  const keyframesRegex = new RegExp(
    '((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})',
    'gi',
  )

  // eslint-disable-next-line no-constant-condition
  while (true) {
    const matches = keyframesRegex.exec(cssText)
    if (matches === null) {
      break
    }
    result.push(matches[0])
  }
  cssText = cssText.replace(keyframesRegex, '')

  const importRegex = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi
  // to match css & media queries together
  const combinedCSSRegex =
    '((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]' +
    '*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})'
  // unified regex
  const unifiedRegex = new RegExp(combinedCSSRegex, 'gi')

  // eslint-disable-next-line no-constant-condition
  while (true) {
    let matches = importRegex.exec(cssText)
    if (matches === null) {
      matches = unifiedRegex.exec(cssText)
      if (matches === null) {
        break
      } else {
        importRegex.lastIndex = unifiedRegex.lastIndex
      }
    } else {
      unifiedRegex.lastIndex = importRegex.lastIndex
    }
    result.push(matches[0])
  }

  return result
}

async function getCSSRules(
  styleSheets: CSSStyleSheet[],
  options: Options,
): Promise<CSSStyleRule[]> {
  const ret: CSSStyleRule[] = []
  const deferreds: Promise<number | void>[] = []

  // First loop inlines imports
  styleSheets.forEach((sheet) => {
    if ('cssRules' in sheet) {
      try {
        toArray<CSSRule>(sheet.cssRules || []).forEach((item, index) => {
          if (item.type === CSSRule.IMPORT_RULE) {
            let importIndex = index + 1
            const url = (item as CSSImportRule).href
            const deferred = fetchCSS(url)
              .then((metadata) => embedFonts(metadata, options))
              .then((cssText) =>
                parseCSS(cssText).forEach((rule) => {
                  try {
                    sheet.insertRule(
                      rule,
                      rule.startsWith('@import')
                        ? (importIndex += 1)
                        : sheet.cssRules.length,
                    )
                  } catch (error) {
                    console.error('Error inserting rule from remote css', {
                      rule,
                      error,
                    })
                  }
                }),
              )
              .catch((e) => {
                console.error('Error loading remote css', e.toString())
              })

            deferreds.push(deferred)
          }
        })
      } catch (e) {
        const inline =
          styleSheets.find((a) => a.href == null) || document.styleSheets[0]
        if (sheet.href != null) {
          deferreds.push(
            fetchCSS(sheet.href)
              .then((metadata) => embedFonts(metadata, options))
              .then((cssText) =>
                parseCSS(cssText).forEach((rule) => {
                  inline.insertRule(rule, inline.cssRules.length)
                }),
              )
              .catch((err: unknown) => {
                console.error('Error loading remote stylesheet', err)
              }),
          )
        }
        console.error('Error inlining remote css file', e)
      }
    }
  })

  return Promise.all(deferreds).then(() => {
    // Second loop parses rules
    styleSheets.forEach((sheet) => {
      if ('cssRules' in sheet) {
        try {
          toArray<CSSStyleRule>(sheet.cssRules || []).forEach((item) => {
            ret.push(item)
          })
        } catch (e) {
          console.error(`Error while reading CSS rules from ${sheet.href}`, e)
        }
      }
    })

    return ret
  })
}

function getWebFontRules(cssRules: CSSStyleRule[]): CSSStyleRule[] {
  return cssRules
    .filter((rule) => rule.type === CSSRule.FONT_FACE_RULE)
    .filter((rule) => shouldEmbed(rule.style.getPropertyValue('src')))
}

async function parseWebFontRules<T extends HTMLElement>(
  node: T,
  options: Options,
) {
  if (node.ownerDocument == null) {
    throw new Error('Provided element is not within a Document')
  }

  const styleSheets = toArray<CSSStyleSheet>(node.ownerDocument.styleSheets)
  const cssRules = await getCSSRules(styleSheets, options)

  return getWebFontRules(cssRules)
}

function normalizeFontFamily(font: string) {
  return font.trim().replace(/["']/g, '')
}

function getUsedFonts(node: HTMLElement) {
  const fonts = new Set<string>()
  function traverse(node: HTMLElement) {
    const fontFamily =
      node.style.fontFamily || getComputedStyle(node).fontFamily
    fontFamily.split(',').forEach((font) => {
      fonts.add(normalizeFontFamily(font))
    })

    Array.from(node.children).forEach((child) => {
      if (child instanceof HTMLElement) {
        traverse(child)
      }
    })
  }
  traverse(node)
  return fonts
}

export async function getWebFontCSS<T extends HTMLElement>(
  node: T,
  options: Options,
): Promise<string> {
  const rules = await parseWebFontRules(node, options)
  const usedFonts = getUsedFonts(node)
  const cssTexts = await Promise.all(
    rules
      .filter((rule) =>
        usedFonts.has(normalizeFontFamily(rule.style.fontFamily)),
      )
      .map((rule) => {
        const baseUrl = rule.parentStyleSheet
          ? rule.parentStyleSheet.href
          : null
        return embedResources(rule.cssText, baseUrl, options)
      }),
  )

  return cssTexts.join('\n')
}

export async function embedWebFonts<T extends HTMLElement>(
  clonedNode: T,
  options: Options,
) {
  const cssText =
    options.fontEmbedCSS != null
      ? options.fontEmbedCSS
      : options.skipFonts
      ? null
      : await getWebFontCSS(clonedNode, options)

  if (cssText) {
    const styleNode = document.createElement('style')
    const sytleContent = document.createTextNode(cssText)

    styleNode.appendChild(sytleContent)

    if (clonedNode.firstChild) {
      clonedNode.insertBefore(styleNode, clonedNode.firstChild)
    } else {
      clonedNode.appendChild(styleNode)
    }
  }
}
</file>

<file path="packages/scan/src/html-to-image/index.ts">
import { Options } from './types'
import { cloneNode } from './clone-node'
import { embedImages } from './embed-images'
import { applyStyle } from './apply-style'
import { embedWebFonts, getWebFontCSS } from './embed-webfonts'
import {
  getImageSize,
  getPixelRatio,
  createImage,
  canvasToBlob,
  nodeToDataURL,
  checkCanvasDimensions,
} from './util'

export { Options } from './types'

export async function toSvg<T extends HTMLElement>(
  node: T,
  options: Options = {},
): Promise<string> {
  const { width, height } = getImageSize(node, options)
  const clonedNode = (await cloneNode(node, options, true)) as HTMLElement
  await embedWebFonts(clonedNode, options)
  await embedImages(clonedNode, options)
  applyStyle(clonedNode, options)
  const datauri = await nodeToDataURL(clonedNode, width, height)
  return datauri
}

export async function toCanvas<T extends HTMLElement>(
  node: T,
  options: Options = {},
): Promise<HTMLCanvasElement> {
  const { width, height } = getImageSize(node, options)
  const svg = await toSvg(node, options)
  const img = await createImage(svg)

  const canvas = document.createElement('canvas')
  const context = canvas.getContext('2d')!
  const ratio = options.pixelRatio || getPixelRatio()
  const canvasWidth = options.canvasWidth || width
  const canvasHeight = options.canvasHeight || height

  canvas.width = canvasWidth * ratio
  canvas.height = canvasHeight * ratio

  if (!options.skipAutoScale) {
    checkCanvasDimensions(canvas)
  }
  canvas.style.width = `${canvasWidth}`
  canvas.style.height = `${canvasHeight}`

  if (options.backgroundColor) {
    context.fillStyle = options.backgroundColor
    context.fillRect(0, 0, canvas.width, canvas.height)
  }

  context.drawImage(img, 0, 0, canvas.width, canvas.height)

  return canvas
}

export async function toPixelData<T extends HTMLElement>(
  node: T,
  options: Options = {},
): Promise<Uint8ClampedArray> {
  const { width, height } = getImageSize(node, options)
  const canvas = await toCanvas(node, options)
  const ctx = canvas.getContext('2d')!
  return ctx.getImageData(0, 0, width, height).data
}

export async function toPng<T extends HTMLElement>(
  node: T,
  options: Options = {},
): Promise<string> {
  const canvas = await toCanvas(node, options)
  return canvas.toDataURL()
}

export async function toJpeg<T extends HTMLElement>(
  node: T,
  options: Options = {},
): Promise<string> {
  const canvas = await toCanvas(node, options)
  return canvas.toDataURL('image/jpeg', options.quality || 1)
}

export async function toBlob<T extends HTMLElement>(
  node: T,
  options: Options = {},
): Promise<Blob | null> {
  const canvas = await toCanvas(node, options)
  const blob = await canvasToBlob(canvas)
  return blob
}

export async function getFontEmbedCSS<T extends HTMLElement>(
  node: T,
  options: Options = {},
): Promise<string> {
  return getWebFontCSS(node, options)
}
</file>

<file path="packages/scan/src/html-to-image/mimes.ts">
const WOFF = 'application/font-woff'
const JPEG = 'image/jpeg'
const mimes: { [key: string]: string } = {
  woff: WOFF,
  woff2: WOFF,
  ttf: 'application/font-truetype',
  eot: 'application/vnd.ms-fontobject',
  png: 'image/png',
  jpg: JPEG,
  jpeg: JPEG,
  gif: 'image/gif',
  tiff: 'image/tiff',
  svg: 'image/svg+xml',
  webp: 'image/webp',
}

function getExtension(url: string): string {
  const match = /\.([^./]*?)$/g.exec(url)
  return match ? match[1] : ''
}

export function getMimeType(url: string): string {
  const extension = getExtension(url).toLowerCase()
  return mimes[extension] || ''
}
</file>

<file path="packages/scan/src/html-to-image/types.ts">
export interface Options {
  /**
   * Width in pixels to be applied to node before rendering.
   */
  width?: number
  /**
   * Height in pixels to be applied to node before rendering.
   */
  height?: number
  /**
   * A string value for the background color, any valid CSS color value.
   */
  backgroundColor?: string
  /**
   * Width in pixels to be applied to canvas on export.
   */
  canvasWidth?: number
  /**
   * Height in pixels to be applied to canvas on export.
   */
  canvasHeight?: number
  /**
   * An object whose properties to be copied to node's style before rendering.
   */
  style?: Partial<CSSStyleDeclaration>
  /**
   * An array of style properties to be copied to node's style before rendering.
   * For performance-critical scenarios, users may want to specify only the
   * required properties instead of all styles.
   */
  includeStyleProperties?: string[]
  /**
   * A function taking DOM node as argument. Should return `true` if passed
   * node should be included in the output. Excluding node means excluding
   * it's children as well.
   */
  filter?: (domNode: HTMLElement) => boolean
  /**
   * A number between `0` and `1` indicating image quality (e.g. 0.92 => 92%)
   * of the JPEG image.
   */
  quality?: number
  /**
   * Set to `true` to append the current time as a query string to URL
   * requests to enable cache busting.
   */
  cacheBust?: boolean
  /**
   * Set false to use all URL as cache key.
   * Default: false | undefined - which strips away the query parameters
   */
  includeQueryParams?: boolean
  /**
   * A data URL for a placeholder image that will be used when fetching
   * an image fails. Defaults to an empty string and will render empty
   * areas for failed images.
   */
  imagePlaceholder?: string
  /**
   * The pixel ratio of captured image. Defalut is the actual pixel ratio of
   * the device. Set 1 to use as initial-scale 1 for the image
   */
  pixelRatio?: number
  /**
   * Option to skip the fonts download and embed.
   */
  skipFonts?: boolean
  /**
   * The preferred font format. If specified all other font formats are ignored.
   */
  preferredFontFormat?:
    | 'woff'
    | 'woff2'
    | 'truetype'
    | 'opentype'
    | 'embedded-opentype'
    | 'svg'
    | string
  /**
   * A CSS string to specify for font embeds. If specified only this CSS will
   * be present in the resulting image. Use with `getFontEmbedCSS()` to
   * create embed CSS for use across multiple calls to library functions.
   */
  fontEmbedCSS?: string
  /**
   * A boolean to turn off auto scaling for truly massive images..
   */
  skipAutoScale?: boolean
  /**
   * A string indicating the image format. The default type is image/png; that type is also used if the given type isn't supported.
   */
  type?: string

  /**
   *
   *the second parameter of  window.fetch (Promise<Response> fetch(input[, init]))
   *
   */
  fetchRequestInit?: RequestInit
  /**
   * An event handler for the error event when any image in html has problem with loading.
   */
  onImageErrorHandler?: OnErrorEventHandler
}
</file>

<file path="packages/scan/src/html-to-image/util.ts">
import type { Options } from './types'

export function resolveUrl(url: string, baseUrl: string | null): string {
  // url is absolute already
  if (url.match(/^[a-z]+:\/\//i)) {
    return url
  }

  // url is absolute already, without protocol
  if (url.match(/^\/\//)) {
    return window.location.protocol + url
  }

  // dataURI, mailto:, tel:, etc.
  if (url.match(/^[a-z]+:/i)) {
    return url
  }

  const doc = document.implementation.createHTMLDocument()
  const base = doc.createElement('base')
  const a = doc.createElement('a')

  doc.head.appendChild(base)
  doc.body.appendChild(a)

  if (baseUrl) {
    base.href = baseUrl
  }

  a.href = url

  return a.href
}

export const uuid = (() => {
  // generate uuid for className of pseudo elements.
  // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.
  let counter = 0

  // ref: http://stackoverflow.com/a/6248722/2519373
  const random = () =>
    // eslint-disable-next-line no-bitwise
    `0000${((Math.random() * 36 ** 4) << 0).toString(36)}`.slice(-4)

  return () => {
    counter += 1
    return `u${random()}${counter}`
  }
})()

export function delay<T>(ms: number) {
  return (args: T) =>
    new Promise<T>((resolve) => {
      setTimeout(() => resolve(args), ms)
    })
}

export function toArray<T>(arrayLike: any): T[] {
  const arr: T[] = []

  for (let i = 0, l = arrayLike.length; i < l; i++) {
    arr.push(arrayLike[i])
  }

  return arr
}

let styleProps: string[] | null = null
export function getStyleProperties(options: Options = {}): string[] {
  if (styleProps) {
    return styleProps
  }

  if (options.includeStyleProperties) {
    styleProps = options.includeStyleProperties
    return styleProps
  }

  styleProps = toArray(window.getComputedStyle(document.documentElement))

  return styleProps
}

function px(node: HTMLElement, styleProperty: string) {
  const win = node.ownerDocument.defaultView || window
  const val = win.getComputedStyle(node).getPropertyValue(styleProperty)
  return val ? parseFloat(val.replace('px', '')) : 0
}

function getNodeWidth(node: HTMLElement) {
  const leftBorder = px(node, 'border-left-width')
  const rightBorder = px(node, 'border-right-width')
  return node.clientWidth + leftBorder + rightBorder
}

function getNodeHeight(node: HTMLElement) {
  const topBorder = px(node, 'border-top-width')
  const bottomBorder = px(node, 'border-bottom-width')
  return node.clientHeight + topBorder + bottomBorder
}

export function getImageSize(targetNode: HTMLElement, options: Options = {}) {
  const width = options.width || getNodeWidth(targetNode)
  const height = options.height || getNodeHeight(targetNode)

  return { width, height }
}

export function getPixelRatio() {
  let ratio

  let FINAL_PROCESS
  try {
    FINAL_PROCESS = process
  } catch (e) {
    // pass
  }

  const val =
    FINAL_PROCESS && FINAL_PROCESS.env
      ? FINAL_PROCESS.env.devicePixelRatio
      : null
  if (val) {
    ratio = parseInt(val, 10)
    if (Number.isNaN(ratio)) {
      ratio = 1
    }
  }
  return ratio || window.devicePixelRatio || 1
}

// @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size
const canvasDimensionLimit = 16384

export function checkCanvasDimensions(canvas: HTMLCanvasElement) {
  if (
    canvas.width > canvasDimensionLimit ||
    canvas.height > canvasDimensionLimit
  ) {
    if (
      canvas.width > canvasDimensionLimit &&
      canvas.height > canvasDimensionLimit
    ) {
      if (canvas.width > canvas.height) {
        canvas.height *= canvasDimensionLimit / canvas.width
        canvas.width = canvasDimensionLimit
      } else {
        canvas.width *= canvasDimensionLimit / canvas.height
        canvas.height = canvasDimensionLimit
      }
    } else if (canvas.width > canvasDimensionLimit) {
      canvas.height *= canvasDimensionLimit / canvas.width
      canvas.width = canvasDimensionLimit
    } else {
      canvas.width *= canvasDimensionLimit / canvas.height
      canvas.height = canvasDimensionLimit
    }
  }
}

export function canvasToBlob(
  canvas: HTMLCanvasElement,
  options: Options = {},
): Promise<Blob | null> {
  if (canvas.toBlob) {
    return new Promise((resolve) => {
      canvas.toBlob(
        resolve,
        options.type ? options.type : 'image/png',
        options.quality ? options.quality : 1,
      )
    })
  }

  return new Promise((resolve) => {
    const binaryString = window.atob(
      canvas
        .toDataURL(
          options.type ? options.type : undefined,
          options.quality ? options.quality : undefined,
        )
        .split(',')[1],
    )
    const len = binaryString.length
    const binaryArray = new Uint8Array(len)

    for (let i = 0; i < len; i += 1) {
      binaryArray[i] = binaryString.charCodeAt(i)
    }

    resolve(
      new Blob([binaryArray], {
        type: options.type ? options.type : 'image/png',
      }),
    )
  })
}

export function createImage(url: string): Promise<HTMLImageElement> {
  return new Promise((resolve, reject) => {
    const img = new Image()
    img.onload = () => {
      img.decode().then(() => {
        requestAnimationFrame(() => resolve(img))
      })
    }
    img.onerror = reject
    img.crossOrigin = 'anonymous'
    img.decoding = 'async'
    img.src = url
  })
}

export async function svgToDataURL(svg: SVGElement): Promise<string> {
  return Promise.resolve()
    .then(() => new XMLSerializer().serializeToString(svg))
    .then(encodeURIComponent)
    .then((html) => `data:image/svg+xml;charset=utf-8,${html}`)
}

export async function nodeToDataURL(
  node: HTMLElement,
  width: number,
  height: number,
): Promise<string> {
  const xmlns = 'http://www.w3.org/2000/svg'
  const svg = document.createElementNS(xmlns, 'svg')
  const foreignObject = document.createElementNS(xmlns, 'foreignObject')

  svg.setAttribute('width', `${width}`)
  svg.setAttribute('height', `${height}`)
  svg.setAttribute('viewBox', `0 0 ${width} ${height}`)

  foreignObject.setAttribute('width', '100%')
  foreignObject.setAttribute('height', '100%')
  foreignObject.setAttribute('x', '0')
  foreignObject.setAttribute('y', '0')
  foreignObject.setAttribute('externalResourcesRequired', 'true')

  svg.appendChild(foreignObject)
  foreignObject.appendChild(node)
  return svgToDataURL(svg)
}

export const isInstanceOfElement = <
  T extends typeof Element | typeof HTMLElement | typeof SVGImageElement,
>(
  node: Element | HTMLElement | SVGImageElement,
  instance: T,
): node is T['prototype'] => {
  if (node instanceof instance) return true

  const nodePrototype = Object.getPrototypeOf(node)

  if (nodePrototype === null) return false

  return (
    nodePrototype.constructor.name === instance.name ||
    isInstanceOfElement(nodePrototype, instance)
  )
}
</file>

<file path="packages/scan/src/new-outlines/offscreen-canvas.worker.ts">
import { OUTLINE_ARRAY_SIZE, drawCanvas, initCanvas } from './canvas';
import type { ActiveOutline } from './types';

let canvas: OffscreenCanvas | null = null;
let ctx: OffscreenCanvasRenderingContext2D | null = null;
let dpr = 1;

const activeOutlines: Map<string, ActiveOutline> = new Map();
let animationFrameId: number | null = null;

const draw = () => {
  if (!ctx || !canvas) return;

  const shouldContinue = drawCanvas(ctx, canvas, dpr, activeOutlines);

  if (shouldContinue) {
    animationFrameId = requestAnimationFrame(draw);
  } else {
    animationFrameId = null;
  }
};

self.onmessage = (event) => {
  const { type } = event.data;

  if (type === 'init') {
    canvas = event.data.canvas;
    dpr = event.data.dpr;

    if (canvas) {
      canvas.width = event.data.width;
      canvas.height = event.data.height;
      ctx = initCanvas(canvas, dpr) as OffscreenCanvasRenderingContext2D;
    }
  }

  if (!canvas || !ctx) return;

  if (type === 'resize') {
    dpr = event.data.dpr;
    canvas.width = event.data.width * dpr;
    canvas.height = event.data.height * dpr;
    ctx.resetTransform();
    ctx.scale(dpr, dpr);
    draw();

    return;
  }

  if (type === 'draw-outlines') {
    const { data, names } = event.data;

    const sharedView = new Float32Array(data);
    for (let i = 0; i < sharedView.length; i += OUTLINE_ARRAY_SIZE) {
      const x = sharedView[i + 2];
      const y = sharedView[i + 3];
      const width = sharedView[i + 4];
      const height = sharedView[i + 5];

      const didCommit = sharedView[i + 6] as 0 | 1;
      const outline = {
        id: sharedView[i],
        name: names[i / OUTLINE_ARRAY_SIZE],
        count: sharedView[i + 1],
        x,
        y,
        width,
        height,
        frame: 0,
        targetX: x,
        targetY: y,
        targetWidth: width,
        targetHeight: height,
        didCommit,
      };
      const key = String(outline.id);

      const existingOutline = activeOutlines.get(key);
      if (existingOutline) {
        existingOutline.count++;
        existingOutline.frame = 0;
        existingOutline.targetX = x;
        existingOutline.targetY = y;
        existingOutline.targetWidth = width;
        existingOutline.targetHeight = height;
        existingOutline.didCommit = didCommit;
      } else {
        activeOutlines.set(key, outline);
      }
    }

    if (!animationFrameId) {
      animationFrameId = requestAnimationFrame(draw);
    }

    return;
  }

  if (type === 'scroll') {
    const { deltaX, deltaY } = event.data;
    for (const outline of activeOutlines.values()) {
      const newX = outline.x - deltaX;
      const newY = outline.y - deltaY;
      outline.targetX = newX;
      outline.targetY = newY;
    }
  }
};
</file>

<file path="packages/scan/src/react-component-name/__tests__/arrow-function.test.ts">
import { describe, it, expect } from 'vitest';
import { transform } from './utils';

describe('arrow function components', () => {
  it('handles inline JSX return', async () => {
    const input = `
      export const Button = () => <button>Click</button>
    `;
    const result = await transform(input);

    expect(result).toContain("Button.displayName = 'Button'");
  });

  it('handles block with JSX return', async () => {
    const input = `
      const Modal = () => {
        return <div>Modal content</div>
      }
    `;
    const result = await transform(input);
    expect(result).toContain("Modal.displayName = 'Modal'");
  });

  it('handles conditional returns', async () => {
    const input = `
      const ConditionalComponent = ({ show }) => {
        if (show) {
          return <div>Shown</div>
        }
        return <div>Hidden</div>
      }
    `;
    const result = await transform(input);
    expect(result).toContain(
      "ConditionalComponent.displayName = 'ConditionalComponent'",
    );
  });

  it('handles early returns', async () => {
    const input = `
      const EarlyReturn = ({ loading, error, data }) => {
        if (loading) return <div>Loading...</div>
        if (error) return <div>Error: {error}</div>
        return <div>{data}</div>
      }
    `;
    const result = await transform(input);
    expect(result).toContain("EarlyReturn.displayName = 'EarlyReturn'");
  });
});
</file>

<file path="packages/scan/src/react-component-name/__tests__/complex-patterns.test.ts">
import { describe, it, expect } from 'vitest';
import { transform } from './utils';

describe('complex component patterns', () => {
  it('handles components with hooks', async () => {
    const input = `
      const TodoList = () => {
        const [todos, setTodos] = useState([])
        useEffect(() => {
          fetchTodos().then(setTodos)
        }, [])
        return <ul>{todos.map(todo => <li key={todo.id}>{todo.text}</li>)}</ul>
      }
    `;
    const result = await transform(input);
    expect(result).toContain("TodoList.displayName = 'TodoList'");
  });

  it('handles components with multiple state updates', async () => {
    const input = `
      const Counter = () => {
        const [count, setCount] = useState(0)
        const increment = () => setCount(c => c + 1)
        const decrement = () => setCount(c => c - 1)
        return (
          <div>
            <button onClick={decrement}>-</button>
            <span>{count}</span>
            <button onClick={increment}>+</button>
          </div>
        )
      }
    `;
    const result = await transform(input);
    expect(result).toContain("Counter.displayName = 'Counter'");
  });

  it('handles components with render props', async () => {
    const input = `
      const DataFetcher = ({ children, url }) => {
        const [data, setData] = useState(null)
        useEffect(() => {
          fetch(url).then(setData)
        }, [url])
        return <>{children(data)}</>
      }
    `;
    const result = await transform(input);
    expect(result).toContain("DataFetcher.displayName = 'DataFetcher'");
  });

  it('handles higher-order components', async () => {
    const input = `
      const withData = (WrappedComponent) => {
        const WithData = (props) => {
          const [data, setData] = useState(null)
          return <WrappedComponent data={data} {...props} />
        }
        return WithData
      }
    `;
    const result = await transform(input);
    expect(result).toContain("WithData.displayName = 'WithData'");
  });
});
</file>

<file path="packages/scan/src/react-component-name/__tests__/function-declarations.test.ts">
import { describe, it, expect } from 'vitest';
import { transform } from './utils';

describe('function declarations', () => {
  it('handles named function declarations', async () => {
    const input = `
      function Welcome(props) {
        return <h1>Hello, {props.name}</h1>
      }
    `;
    const result = await transform(input);
    expect(result).toContain("Welcome.displayName = 'Welcome'");
  });

  it('handles async components', async () => {
    const input = `
      async function AsyncComponent({ id }) {
        const data = await fetchData(id)
        return <div>{data}</div>
      }
    `;
    const result = await transform(input);
    expect(result).toContain("AsyncComponent.displayName = 'AsyncComponent'");
  });
});
</file>

<file path="packages/scan/src/react-component-name/__tests__/general-cases.test.ts">
import { describe, expect, it } from 'vitest';
import { transform } from './utils';

describe('edge cases', () => {
  it('handles nested component declarations', async () => {
    const input = `
      const Parent = () => {
        const NestedChild = () => <div>Child</div>
        return (
          <div>
            <NestedChild />
          </div>
        )
      }
    `;
    const result = await transform(input);
    expect(result).toContain("Parent.displayName = 'Parent'");
    expect(result).toContain("NestedChild.displayName = 'NestedChild'");
  });

  it('handles components with complex expressions', async () => {
    const input = `
      const DynamicComponent = () => {
        const content = useMemo(() => (
          <div>
            {data.map(item => (
              <Fragment key={item.id}>
                {item.visible && <span>{item.text}</span>}
              </Fragment>
            ))}
          </div>
        ), [data])

        return (
          <>
            {isLoading ? <Spinner /> : content}
          </>
        )
      }
    `;
    const result = await transform(input);
    expect(result).toContain(
      "DynamicComponent.displayName = 'DynamicComponent'",
    );
  });

  it('handles components with multiple returns in switch/case', async () => {
    const input = `
      const StatusComponent = ({ status }) => {
        switch (status) {
          case 'loading':
            return <Spinner />
          case 'error':
            return <Error />
          case 'empty':
            return <Empty />
          default:
            return <Content />
        }
      }
    `;
    const result = await transform(input);
    expect(result).toContain("StatusComponent.displayName = 'StatusComponent'");
  });

  it('handles components with try/catch blocks', async () => {
    const input = `
      const SafeComponent = () => {
        try {
          const data = riskyOperation()
          return <div>{data}</div>
        } catch (error) {
          return <div>Error: {error.message}</div>
        }
      }
    `;
    const result = await transform(input);
    expect(result).toContain("SafeComponent.displayName = 'SafeComponent'");
  });

  it('handles components returning primitive values', async () => {
    const input = `
      // Null component
      const EmptyComponent = () => null;

      // String component
      const TextComponent = () => "Hello World";

      // Number component
      const NumberComponent = () => 42;

      // Boolean component (though not very useful)
      const BooleanComponent = () => true;

      // Array of elements
      const ListComponent = () => [
        <div key="1">One</div>,
        <div key="2">Two</div>
      ];

      // Conditional primitive returns
      const ConditionalComponent = ({ value }) => {
        if (!value) return null;
        if (typeof value === 'string') return value;
        if (typeof value === 'number') return value.toString();
        return <div>{value}</div>;
      };

      // Dynamic children
      const DynamicComponent = ({ count }) => {
        return Array(count).fill(null).map((_, i) => <div key={i} />);
      };

      // Async component with suspense
      const AsyncComponent = () => {
        const resource = fetchData();
        if (!resource.isReady) {
          throw resource.promise;
        }
        return <div>{resource.read()}</div>;
      };

      // Portal component
      const PortalComponent = () => {
        return createPortal(<div>Portal content</div>, document.body);
      };

      // Fragment shorthand
      const FragmentComponent = () => <>Fragment content</>;

      // Nested arrays and fragments
      const NestedComponent = () => [
        <div key="1">First</div>,
        <>
          <div>Nested 1</div>
          <div>Nested 2</div>
        </>,
        [<div key="3">Deep nested</div>]
      ];
    `;
    const result = await transform(input);
    // expect(result).toContain("EmptyComponent.displayName = 'EmptyComponent'");
    // expect(result).toContain("TextComponent.displayName = 'TextComponent'");
    // expect(result).toContain("NumberComponent.displayName = 'NumberComponent'");
    // expect(result).toContain(
    //   "BooleanComponent.displayName = 'BooleanComponent'",
    // );
    expect(result).toContain("ListComponent.displayName = 'ListComponent'");
    expect(result).toContain(
      "ConditionalComponent.displayName = 'ConditionalComponent'",
    );
    expect(result).toContain(
      "DynamicComponent.displayName = 'DynamicComponent'",
    );
    expect(result).toContain("AsyncComponent.displayName = 'AsyncComponent'");
    expect(result).toContain("PortalComponent.displayName = 'PortalComponent'");
    expect(result).toContain(
      "FragmentComponent.displayName = 'FragmentComponent'",
    );
    expect(result).toContain("NestedComponent.displayName = 'NestedComponent'");
  });

  it('handles components with complex conditional returns', async () => {
    const input = `
      const ComplexComponent = ({ type, data }) => {
        switch (type) {
          case 'text': return data;
          case 'number': return data.toString();
          case 'array': return data.map(item => <div key={item.id}>{item.text}</div>);
          case 'element': return <div>{data}</div>;
          default: return null;
        }
      };

      const TernaryComponent = ({ condition, value }) =>
        condition
          ? value
          : value
            ? <span>{value}</span>
            : null;

      const ShortCircuitComponent = ({ items }) =>
        items?.length && items.map(item => <div key={item}>{item}</div>);

      const NullishComponent = ({ text }) =>
        text ?? <>Default text</>;

      const ChainedComponent = ({ a, b, c }) =>
        a?.b?.c ?? <div>Fallback</div>;

      // More Suspense examples
      const DataComponent = () => {
        const data = resource.read();
        return <div>{data}</div>;
      };

      const SuspenseImage = ({ src }) => {
        const resource = preloadImage(src);
        if (!resource.complete) {
          throw resource.promise;
        }
        return <img src={src} alt="" />;
      };

      const ProfileComponent = () => {
        const user = userResource.read();
        const posts = postsResource.read();
        if (!user || !posts) {
          throw Promise.all([user?.promise, posts?.promise]);
        }
        return (
          <div>
            <h1>{user.name}</h1>
            {posts.map(post => <div key={post.id}>{post.title}</div>)}
          </div>
        );
      };
    `;
    const result = await transform(input);
    expect(result).toContain(
      "ComplexComponent.displayName = 'ComplexComponent'",
    );
    expect(result).toContain(
      "TernaryComponent.displayName = 'TernaryComponent'",
    );
    expect(result).toContain(
      "ShortCircuitComponent.displayName = 'ShortCircuitComponent'",
    );
    expect(result).toContain(
      "NullishComponent.displayName = 'NullishComponent'",
    );
    expect(result).toContain(
      "ChainedComponent.displayName = 'ChainedComponent'",
    );
    expect(result).toContain("DataComponent.displayName = 'DataComponent'");
    expect(result).toContain("SuspenseImage.displayName = 'SuspenseImage'");
    expect(result).toContain(
      "ProfileComponent.displayName = 'ProfileComponent'",
    );
  });

  it('handles components with complex state and hooks', async () => {
    const input = `
      export const ValueUpdate = ({
        valueUpdate,
        className,
      }) => {
        const actions = useTraceStoreActions();
        const referredToHeapObject = useTraceStore(getReferredToHeapObjectSelector(valueUpdate));
        const constructorStackFrame = useTraceStore(
          referredToHeapObject ? constructorStackFrameSelector(referredToHeapObject.constructorStackFrameId) : () => null,
        );

        const referredToHeapObjectColor = constructorStackFrame ? getFrameColor(constructorStackFrame) : undefined;

        return (
          <AnimatedTrace
            animation={"grow"}
            style={{
              borderColor: referredToHeapObjectColor,
            }}
            key={valueUpdate.valueUpdateId}
            className={cn([
              referredToHeapObject && "border-4",
              referredToHeapObject && "m-[2px]",
            ])}
          >
            <div className="w-fit flex items-center">
              <Editable
                styles={{
                  notEditing: {
                    maxWidth: "20em",
                    minHeight: "0px",
                    height: "1.2rem",
                  },
                }}
                classNames={{
                  notEditing: {
                    input: className,
                  },
                }}
                focusedId={valueUpdate.valueUpdateId}
                key={valueUpdate.valueUpdateId}
                state={{
                  value: valueUpdate.value,
                  onTrash: () => {
                    actions.shared.deleteValueUpdate(valueUpdate.valueUpdateId);
                  },
                  onValueChange: (newValue) => {
                    actions.shared.changeVariableUpdateValue({
                      value: newValue,
                      valueUpdateId: valueUpdate.valueUpdateId,
                    });
                  },
                }}
              />
            </div>
          </AnimatedTrace>
        );
      };

      // Another example with complex state management
      const DataGrid = ({ data, onSort }) => {
        const [sortField, setSortField] = useState(null);
        const [sortDirection, setSortDirection] = useState('asc');
        const [filters, setFilters] = useState({});

        const sortedData = useMemo(() => {
          if (!sortField) return data;
          return [...data].sort((a, b) => {
            const aVal = a[sortField];
            const bVal = b[sortField];
            return sortDirection === 'asc' ? aVal - bVal : bVal - aVal;
          });
        }, [data, sortField, sortDirection]);

        const filteredData = useMemo(() => {
          return sortedData.filter(item => {
            return Object.entries(filters).every(([key, value]) => {
              return item[key].toString().toLowerCase().includes(value.toLowerCase());
            });
          });
        }, [sortedData, filters]);

        const handleHeaderClick = (field) => {
          if (sortField === field) {
            setSortDirection(prev => prev === 'asc' ? 'desc' : 'asc');
          } else {
            setSortField(field);
            setSortDirection('asc');
          }
          onSort?.({ field, direction: sortDirection });
        };

        return (
          <div className="data-grid">
            <div className="header">
              {Object.keys(data[0] || {}).map(field => (
                <div
                  key={field}
                  onClick={() => handleHeaderClick(field)}
                  className={cn([
                    'header-cell',
                    sortField === field && 'sorted',
                    sortField === field && sortDirection === 'desc' && 'desc'
                  ])}
                >
                  {field}
                </div>
              ))}
            </div>
            <div className="body">
              {filteredData.map((row, i) => (
                <div key={i} className="row">
                  {Object.values(row).map((cell, j) => (
                    <div key={j} className="cell">{cell}</div>
                  ))}
                </div>
              ))}
            </div>
          </div>
        );
      };
    `;
    const result = await transform(input);
    expect(result).toContain("ValueUpdate.displayName = 'ValueUpdate'");
    expect(result).toContain("DataGrid.displayName = 'DataGrid'");
  });

  it('handles all forwardRef patterns', async () => {
    const input = `
      import React from 'react';

      // Basic forwardRef
      const Button = React.forwardRef((props, ref) => (
        <button ref={ref} {...props} />
      ));

      // Named function in forwardRef
      const Input = React.forwardRef(function Input(props, ref) {
        return <input ref={ref} {...props} />;
      });

      // forwardRef with type annotations
      const Select = React.forwardRef<HTMLSelectElement, SelectProps>((props, ref) => (
        <select ref={ref} {...props} />
      ));

      // forwardRef with displayName already set (should preserve it)
      const TextArea = React.forwardRef((props, ref) => {
        return <textarea ref={ref} {...props} />;
      });
      TextArea.displayName = 'CustomTextArea';

      // Complex forwardRef with hooks and logic
      const Field = React.forwardRef((props, ref) => {
        const [value, setValue] = useState('');
        const internalRef = useRef(null);

        useImperativeHandle(ref, () => ({
          focus: () => internalRef.current?.focus(),
          reset: () => setValue('')
        }));

        return (
          <div>
            <input
              ref={internalRef}
              value={value}
              onChange={e => setValue(e.target.value)}
            />
          </div>
        );
      });

      // forwardRef with memo
      const MemoizedInput = React.memo(React.forwardRef((props, ref) => (
        <input ref={ref} {...props} />
      )));

      // forwardRef wrapped in HOC
      const EnhancedInput = withStyles(React.forwardRef((props, ref) => (
        <input ref={ref} {...props} />
      )));
    `;
    const result = await transform(input);
    expect(result).toContain("Button.displayName = 'Button'");
    expect(result).toContain("Input.displayName = 'Input'");
    expect(result).toContain("Select.displayName = 'Select'");
    expect(result).toContain("TextArea.displayName = 'CustomTextArea'"); // Should preserve existing, todo check for one

    expect(result).toContain("Field.displayName = 'Field'");
    expect(result).toContain("MemoizedInput.displayName = 'MemoizedInput'");
    expect(result).toContain("EnhancedInput.displayName = 'EnhancedInput'");
  });

  it('handles all memo patterns', async () => {
    const input = `
      import React from 'react';
      // Basic memo
      const Item = React.memo(props => (
        <div>{props.text}</div>
      ));

      // Named function in memo
      const Header = React.memo(function Header({ title }) {
        return <h1>{title}</h1>;
      });

      // memo with comparison function
      const ExpensiveList = React.memo(({ items }) => (
        <ul>
          {items.map(item => <li key={item.id}>{item.text}</li>)}
        </ul>
      ), (prevProps, nextProps) => prevProps.items === nextProps.items);


      // memo with type annotations
      const TypedButton = React.memo<ButtonProps>(props => (
        <button {...props} />
      ));

      // memo with displayName already set (should preserve it)
      const Footer = React.memo(props => (
        <footer>{props.children}</footer>
      ));
      Footer.displayName = 'CustomFooter';

      // Complex memo with hooks and logic
      const SearchBar = React.memo(({ onSearch }) => {
        const [query, setQuery] = useState('');
        const debouncedQuery = useDebounce(query, 300);

        useEffect(() => {
          onSearch(debouncedQuery);
        }, [debouncedQuery, onSearch]);

        return (
          <input
            type="search"
            value={query}
            onChange={e => setQuery(e.target.value)}
          />
        );
      });

      // Nested memo
      const NestedMemo = React.memo(React.memo(props => (
        <div>{props.text}</div>
      )));

      // memo wrapped in HOC
      const EnhancedList = withStyles(React.memo(props => (
        <ul>{props.items.map(item => <li key={item.id}>{item.text}</li>)}</ul>
      )));

      // memo with forwardRef
      const MemoInput = React.memo(React.forwardRef((props, ref) => (
        <input ref={ref} {...props} />
      )));
    `;

    const result = await transform(input);
    expect(result).toContain("Item.displayName = 'Item'");
    expect(result).toContain("Header.displayName = 'Header'");
    expect(result).toContain("ExpensiveList.displayName = 'ExpensiveList'");
    expect(result).toContain("TypedButton.displayName = 'TypedButton'");
    expect(result).toContain("Footer.displayName = 'CustomFooter'"); // Should preserve existing
    expect(result).toContain("SearchBar.displayName = 'SearchBar'");
    expect(result).toContain("NestedMemo.displayName = 'NestedMemo'");
    expect(result).toContain("EnhancedList.displayName = 'EnhancedList'");
    expect(result).toContain("MemoInput.displayName = 'MemoInput'");
  });

  it('handles components with various function calls returning JSX', async () => {
    const input = `
      const ArrayMethodsComponent = ({ items }) => {
        // Filter then map
        const filtered = items
          .filter(item => item.visible)
          .map(item => <div key={item.id}>{item.text}</div>);

        // Reduce to JSX
        const reduced = items.reduce((acc, item) => [
          ...acc,
          <div key={item.id}>{item.text}</div>
        ], []);

        // Custom function returning JSX
        const renderItem = (item) => <div>{item.text}</div>;

        // Method chaining with JSX returns
        const processed = items
          .slice(0, 5)
          .filter(item => item.score > 10)
          .map(renderItem);

        return (
          <>
            <div>{filtered}</div>
            <div>{reduced}</div>
            <div>{processed}</div>
            <div>{renderItem(items[0])}</div>
          </>
        );
      };

      // Custom utility functions returning JSX
      const renderList = (items) => items.map(item => <li key={item.id}>{item.text}</li>);
      const createWrapper = (content) => <div className="wrapper">{content}</div>;
      const withLayout = (Component) => (props) => (
        <div className="layout">
          <Component {...props} />
        </div>
      );

      const CustomFunctionsComponent = ({ items }) => {
        // Direct function calls returning JSX
        const list = renderList(items);
        const wrapped = createWrapper(<span>Content</span>);

        // Function composition
        const content = createWrapper(renderList(items));

        // HOC usage
        const WrappedComponent = withLayout(({ text }) => <div>{text}</div>);

        return (
          <>
            {list}
            {wrapped}
            {content}
            <WrappedComponent text="Hello" />
          </>
        );
      };

      // Promise/async function returns
      const AsyncComponent = ({ id }) => {
        const [data, setData] = useState(null);

        useEffect(() => {
          const fetchData = async () => {
            const result = await api.get(id);
            return <div>{result.data}</div>;
          };

          fetchData().then(setData);
        }, [id]);

        return data || <div>Loading...</div>;
      };

      // Complex method chaining
      const ChainedComponent = ({ data }) => {
        const result = Object.entries(data)
          .filter(([_, value]) => value.isValid)
          .map(([key, value]) => ({ key, ...value }))
          .reduce((acc, item) => ({
            ...acc,
            [item.key]: <div key={item.key}>{item.content}</div>
          }), {});

        return (
          <div>
            {Object.values(result)}
          </div>
        );
      };

      // Functional composition
      const compose = (...fns) => x => fns.reduceRight((v, f) => f(v), x);

      const withData = Component => props => {
        const data = useData();
        return <Component {...props} data={data} />;
      };

      const withTheme = Component => props => {
        const theme = useTheme();
        return <Component {...props} theme={theme} />;
      };

      const BaseComponent = ({ data, theme, label }) => (
        <div className={theme}>{data[label]}</div>
      );

      const EnhancedComponent = compose(
        withData,
        withTheme
      )(BaseComponent);
    `;

    const result = await transform(input);
    expect(result).toContain(
      "ArrayMethodsComponent.displayName = 'ArrayMethodsComponent'",
    );
    expect(result).toContain(
      "CustomFunctionsComponent.displayName = 'CustomFunctionsComponent'",
    );
    expect(result).toContain("AsyncComponent.displayName = 'AsyncComponent'");
    expect(result).toContain(
      "ChainedComponent.displayName = 'ChainedComponent'",
    );
    expect(result).toContain("BaseComponent.displayName = 'BaseComponent'");
    // expect(result).toContain(
    //   "EnhancedComponent.displayName = 'EnhancedComponent'",
    // );
  });

  it('handles shadcn-style component patterns', async () => {
    const input = `
      import React from 'react';
      // Basic shadcn component pattern
      const Button = React.forwardRef<
        HTMLButtonElement,
        React.ButtonHTMLAttributes<HTMLButtonElement>
      >(({ className, ...props }, ref) => (
        <button
          className={cn("rounded-lg px-4", className)}
          ref={ref}
          {...props}
        />
      ));

      // With variants using cva
      const button = cva(
        "rounded-lg px-4",
        {
          variants: {
            variant: {
              default: "bg-primary",
              secondary: "bg-secondary",
            },
            size: {
              default: "h-10",
              sm: "h-8",
              lg: "h-12",
            },
          },
          defaultVariants: {
            variant: "default",
            size: "default",
          },
        }
      );

      interface ButtonProps
        extends React.ButtonHTMLAttributes<HTMLButtonElement>,
          VariantProps<typeof button> {}

      const ButtonWithVariants = React.forwardRef<HTMLButtonElement, ButtonProps>(
        ({ className, variant, size, ...props }, ref) => {
          return (
            <button
              className={cn(button({ variant, size, className }))}
              ref={ref}
              {...props}
            />
          )
        }
      );

      // With slot compositions
      const Card = React.forwardRef<
        HTMLDivElement,
        React.HTMLAttributes<HTMLDivElement>
      >(({ className, ...props }, ref) => (
        <div
          ref={ref}
          className={cn("rounded-lg border", className)}
          {...props}
        />
      ));

      const CardHeader = React.forwardRef<
        HTMLDivElement,
        React.HTMLAttributes<HTMLDivElement>
      >(({ className, ...props }, ref) => (
        <div
          ref={ref}
          className={cn("flex flex-col space-y-1.5 p-6", className)}
          {...props}
        />
      ));

      // Component composition
      const Dialog = ({ children, ...props }) => (
        <DialogPrimitive.Root {...props}>
          {children}
        </DialogPrimitive.Root>
      );

      const DialogTrigger = React.forwardRef<
        React.ElementRef<typeof DialogPrimitive.Trigger>,
        React.ComponentPropsWithoutRef<typeof DialogPrimitive.Trigger>
      >(({ className, ...props }, ref) => (
        <DialogPrimitive.Trigger
          ref={ref}
          className={cn("", className)}
          {...props}
        />
      ));
    `;

    const result = await transform(input);
    expect(result).toContain("Button.displayName = 'Button'");
    expect(result).toContain(
      "ButtonWithVariants.displayName = 'ButtonWithVariants'",
    );
    expect(result).toContain("Card.displayName = 'Card'");
    expect(result).toContain("CardHeader.displayName = 'CardHeader'");
    expect(result).toContain("Dialog.displayName = 'Dialog'");
    expect(result).toContain("DialogTrigger.displayName = 'DialogTrigger'");
  });

  it('handles legacy and unconventional component patterns', async () => {
    const input = `


      // createReactClass (after createClass was removed from React)
      const CreateClassComponent = createReactClass({
        render() {
          return <div>Still Legacy</div>
        }
      });

      // Mixins (old pattern, but still exists)
      const mixins = {
        componentDidMount() {
          console.log('mounted');
        }
      };

      const WithMixins = createReactClass({
        mixins: [mixins],
        render() {
          return <div>With Mixins</div>
        }
      });

      // Factory pattern (common in older Material-UI and other libs)
      const createComponent = (config) => {
        class GeneratedComponent extends React.Component {
          render() {
            return <div>{config.text}</div>
          }
        }
        return GeneratedComponent;
      };
      const FactoryComponent = createComponent({ text: 'Factory' });

      // Decorator pattern (still common in MobX codebases)
      @observer
      class DecoratedComponent extends React.Component {
        render() {
          return <div>{this.props.data}</div>
        }
      }

      // Render props with multiple children functions
      const RenderPropComponent = ({ children, render, component: Component }) => (
        <div>
          {children(data)}
          {render(data)}
          <Component data={data} />
        </div>
      );

      // Old context pattern
      class OldContextComponent extends React.Component {
        static contextTypes = {
          theme: PropTypes.object
        };

        render() {
          return <div>{this.context.theme}</div>
        }
      }

      // Partial application component creation
      const createPartialComponent = (defaultProps) =>
        function PartialComponent(props) {
          return <div {...defaultProps} {...props} />;
        };
      const PartialButton = createPartialComponent({ type: 'button' });

      // jQuery-style plugins (seen in older React codebases)
      React.Component.prototype.plugin = function() {
        return <div>Plugin</div>;
      };
      class PluginComponent extends React.Component {
        render() {
          return <>{this.plugin()}</>;
        }
      }



      // Multiple inheritance simulation
      const withInheritance = Base => class extends Base {
        render() {
          return <div>Extended {super.render()}</div>;
        }
      };
      class BaseComponent extends React.Component {
        render() {
          return <div>Base</div>;
        }
      }
      const InheritedComponent = withInheritance(BaseComponent);
    `;

    const result = await transform(input);
    expect(result).toContain(
      "CreateClassComponent.displayName = 'CreateClassComponent'",
    );
    expect(result).toContain("WithMixins.displayName = 'WithMixins'");
    // expect(result).toContain(
    //   "FactoryComponent.displayName = 'FactoryComponent'",
    // );
    expect(result).toContain(
      "DecoratedComponent.displayName = 'DecoratedComponent'",
    );
    expect(result).toContain(
      "RenderPropComponent.displayName = 'RenderPropComponent'",
    );
    expect(result).toContain(
      "OldContextComponent.displayName = 'OldContextComponent'",
    );
    // expect(result).toContain("PartialButton.displayName = 'PartialButton'");
    expect(result).toContain("PluginComponent.displayName = 'PluginComponent'");
    // expect(result).toContain(
    //   "InheritedComponent.displayName = 'InheritedComponent'",
    // );
  });
});
</file>

<file path="packages/scan/src/react-component-name/__tests__/react-patterns.test.ts">
import { describe, it, expect } from 'vitest';
import { transform } from './utils';

describe('modern React patterns', () => {
  it('handles components with hooks and context', async () => {
    const input = `
      const UserProfile = () => {
        const { user } = useContext(UserContext)
        const { theme } = useContext(ThemeContext)
        return (
          <div className={theme}>
            <h1>{user.name}</h1>
            <p>{user.email}</p>
          </div>
        )
      }
    `;
    const result = await transform(input);
    expect(result).toContain("UserProfile.displayName = 'UserProfile'");
  });

  it('handles components with custom hooks', async () => {
    const input = `
      const SearchResults = () => {
        const { data, loading, error } = useQuery(SEARCH_QUERY)
        const { formatResult } = useSearchFormatter()

        if (loading) return <div>Loading...</div>
        if (error) return <div>Error!</div>

        return (
          <ul>
            {data.map(item => (
              <li key={item.id}>{formatResult(item)}</li>
            ))}
          </ul>
        )
      }
    `;
    const result = await transform(input);
    expect(result).toContain("SearchResults.displayName = 'SearchResults'");
  });

  it('handles components with suspense boundaries', async () => {
    const input = `
      const AsyncContent = () => {
        const data = useSuspenseQuery(QUERY)
        return (
          <Suspense fallback={<div>Loading...</div>}>
            <div>{data.content}</div>
          </Suspense>
        )
      }
    `;
    const result = await transform(input);
    expect(result).toContain("AsyncContent.displayName = 'AsyncContent'");
  });

  it('handles components with error boundaries', async () => {
    const input = `
      import React from 'react';

      class ErrorBoundary extends React.Component {
        state = { hasError: false }

        static getDerivedStateFromError(error) {
          return { hasError: true }
        }

        render() {
          if (this.state.hasError) {
            return <div>Something went wrong</div>
          }
          return this.props.children
        }
      }
    `;
    const result = await transform(input);
    expect(result).toContain("ErrorBoundary.displayName = 'ErrorBoundary'");
  });
});
</file>

<file path="packages/scan/src/react-component-name/__tests__/ts-patterns.test.ts">
import { describe, it, expect } from 'vitest';
import { transform } from './utils';

describe('typescript patterns', () => {
  it('handles components with type parameters', async () => {
    const input = `
      interface Props<T> {
        items: T[]
        renderItem: (item: T) => React.ReactNode
      }

      const List = <T extends unknown>({ items, renderItem }: Props<T>) => {
        return <div>{items.map(renderItem)}</div>
      }
    `;
    const result = await transform(input);
    expect(result).toContain("List.displayName = 'List'");
  });

  it('handles components with complex types', async () => {
    const input = `
      type Props = {
        id: string
        onClick: (e: React.MouseEvent) => void
        children: React.ReactNode
      } & Omit<React.ButtonHTMLAttributes<HTMLButtonElement>, 'onClick'>

      export const Button: React.FC<Props> = ({ id, onClick, children, ...rest }) => {
        return <button onClick={onClick} {...rest}>{children}</button>
      }
    `;
    const result = await transform(input);
    expect(result).toContain("Button.displayName = 'Button'");
  });
});
</file>

<file path="packages/scan/src/react-component-name/babel/get-descriptive-name.ts">
import type * as babel from '@babel/core';

export function getDescriptiveName(
  path: babel.NodePath,
  defaultName: string,
): string {
  let current: babel.NodePath | null = path;
  while (current) {
    switch (current.node.type) {
      case 'FunctionDeclaration':
      case 'FunctionExpression': {
        if (current.node.id) {
          return current.node.id.name;
        }
        break;
      }
      case 'VariableDeclarator': {
        if (current.node.id.type === 'Identifier') {
          return current.node.id.name;
        }
        break;
      }
      case 'ClassPrivateMethod':
      case 'ClassMethod':
      case 'ObjectMethod': {
        switch (current.node.key.type) {
          case 'Identifier':
            return current.node.key.name;
          case 'PrivateName':
            return current.node.key.id.name;
          default:
            break;
        }
        break;
      }
      default:
        break;
    }
    current = current.parentPath;
  }
  return defaultName;
}
</file>

<file path="packages/scan/src/react-component-name/babel/get-root-statement-path.ts">
import type * as babel from '@babel/core';
import * as t from '@babel/types';

export function getRootStatementPath(path: babel.NodePath): babel.NodePath {
  let current = path.parentPath;
  while (current) {
    const next = current.parentPath;
    if (next && t.isProgram(next.node)) {
      return current;
    }
    current = next;
  }
  return path;
}
</file>

<file path="packages/scan/src/react-component-name/babel/is-componentish-name.ts">
// This is just a Pascal heuristic
// we only assume a function is a component

import type { Options } from '../core/options';

// if the first character is in uppercase
export function isComponentishName(name: string, flags: Options['flags']) {
  return (
    name[0] >= 'A' &&
    name[0] <= 'Z' &&
    !flags?.ignoreComponentSubstrings?.some((substring) =>
      name.includes(substring),
    )
  );
}
</file>

<file path="packages/scan/src/react-component-name/babel/is-statement-top-level.ts">
import type * as babel from '@babel/core';
import type * as t from '@babel/types';

export function isStatementTopLevel(
  path: babel.NodePath<t.Statement>,
): boolean {
  let blockParent = path.scope.getBlockParent();
  const programParent = path.scope.getProgramParent();
  // a FunctionDeclaration binding refers to itself as the block parent
  if (blockParent.path === path) {
    blockParent = blockParent.parent;
  }

  return programParent === blockParent;
}
</file>

<file path="packages/scan/src/react-component-name/babel/path-references-import.ts">
import type { NodePath } from '@babel/core';
import * as t from '@babel/types';
import { isPathValid } from './is-path-valid';
import { unwrapPath } from './unwrap';

export const pathReferencesImport = (
  path: NodePath,
  moduleSource: string,
  importName: string[],
  asType: boolean,
  defaultNamespace = false,
): boolean => {
  const identifier = unwrapPath(path, t.isIdentifier);
  if (identifier) {
    const binding = path.scope.getBinding(identifier.node.name);
    if (binding && binding.kind === 'module') {
      const importPath = binding.path;
      const importParent = importPath.parentPath;
      if (
        isPathValid(importParent, t.isImportDeclaration) &&
        importParent.node.source.value === moduleSource
      ) {
        if (isPathValid(importPath, t.isImportSpecifier)) {
          const key = t.isIdentifier(importPath.node.imported)
            ? importPath.node.imported.name
            : importPath.node.imported.value;
          return importName.includes(key);
        }
        if (isPathValid(importPath, t.isImportDefaultSpecifier)) {
          return importName.includes('default');
        }
        if (isPathValid(importPath, t.isImportNamespaceSpecifier)) {
          return importName.includes('*');
        }
      }
    }
    return false;
  }
  const memberExpr =
    unwrapPath(path, t.isMemberExpression) ||
    unwrapPath(path, t.isOptionalMemberExpression);
  if (memberExpr) {
    const object = unwrapPath(memberExpr.get('object'), t.isIdentifier);
    if (!object) {
      return false;
    }
    const property = memberExpr.get('property');
    if (isPathValid(property, t.isIdentifier)) {
      return (
        importName.includes(property.node.name) &&
        (pathReferencesImport(object, moduleSource, ['*'], asType) ||
          (defaultNamespace &&
            pathReferencesImport(object, moduleSource, ['default'], asType)))
      );
    }
    if (isPathValid(property, t.isStringLiteral)) {
      return (
        importName.includes(property.node.value) &&
        (pathReferencesImport(object, moduleSource, ['*'], asType) ||
          (defaultNamespace &&
            pathReferencesImport(object, moduleSource, ['default'], asType)))
      );
    }
  }
  return false;
};
</file>

<file path="packages/scan/src/react-component-name/core/options.ts">
import type { FilterPattern } from '@rollup/pluginutils';

export interface Options {
  include?: FilterPattern;
  exclude?: FilterPattern;
  enforce?: 'pre' | 'post' | undefined;
  flags?: {
    noTryCatchDisplayNames?: boolean;
    noStyledComponents?: boolean;
    noCreateContext?: boolean;
    ignoreComponentSubstrings?: Array<string>;
  };
}

type Overwrite<T, U> = Pick<T, Exclude<keyof T, keyof U>> & U;

export type OptionsResolved = Overwrite<
  Required<Options>,
  Pick<Options, 'enforce'>
>;

export function resolveOptions(options: Options): OptionsResolved {
  return {
    include: options.include ?? [/\.[cm]?[jt]sx?$/],
    exclude: options.exclude ?? [/node_modules/],
    enforce: 'enforce' in options ? options.enforce : 'pre',
    flags: options.flags ?? {},
  };
}
</file>

<file path="packages/scan/src/react-component-name/astro.ts">
import type { Options } from '.';
import vite from './vite';

export default (options: Options = {}) => ({
  name: 'react-component-name',
  hooks: {
    // biome-ignore lint/suspicious/noExplicitAny: should be { config: AstroConfig }
    'astro:config:setup': (astro: any) => {
      astro.config.vite.plugins ||= [];
      astro.config.vite.plugins.push(vite(options));
    },
  },
});
</file>

<file path="packages/scan/src/react-component-name/esbuild.ts">
import { reactComponentNamePlugin } from '.'

export default reactComponentNamePlugin.esbuild
</file>

<file path="packages/scan/src/react-component-name/rolldown.ts">
import { reactComponentNamePlugin } from ".";


export default reactComponentNamePlugin.rolldown;
</file>

<file path="packages/scan/src/react-component-name/rollup.ts">
import reactComponentNamePlugin from '.';

export default reactComponentNamePlugin.rollup;
</file>

<file path="packages/scan/src/react-component-name/rspack.ts">
import reactComponentNamePlugin from '.';

export default reactComponentNamePlugin.rspack;
</file>

<file path="packages/scan/src/react-component-name/vite.ts">
import { reactComponentNamePlugin } from '.';

export default reactComponentNamePlugin.vite;
</file>

<file path="packages/scan/src/react-component-name/webpack.ts">
import { reactComponentNamePlugin } from '.';

export default reactComponentNamePlugin.webpack;
</file>

<file path="packages/scan/src/web/utils/preact/constant.ts">
import {
  type Attributes,
  type Component,
  type FunctionComponent,
  createElement,
} from 'preact';

function CONSTANT_UPDATE() {
  return false;
}

export function constant<P extends Attributes>(
  Component: FunctionComponent<P>,
) {
  function Memoed(this: Component<P>, props: P) {
    this.shouldComponentUpdate = CONSTANT_UPDATE;
    return createElement<P>(Component, props);
  }
  Memoed.displayName = `Memo(${Component.displayName || Component.name})`;
  Memoed.prototype.isReactComponent = true;
  Memoed._forwarded = true;
  return Memoed;
}
</file>

<file path="packages/scan/src/web/utils/preact/use-constant.ts">
import { useDebugValue } from 'preact/hooks';
import { useLazyRef } from './use-lazy-ref';

export function useConstant<T>(supplier: () => T): T {
  const value = useLazyRef(supplier).current;
  useDebugValue(value);
  return value;
}
</file>

<file path="packages/scan/src/web/utils/preact/use-lazy-ref.ts">
import { useDebugValue, useRef, type MutableRef } from 'preact/hooks';

export function useLazyRef<T>(supplier: () => T): MutableRef<T> {
  const ref = useRef<MutableRef<T> | null>();

  if (!ref.current) {
    ref.current = {
      current: supplier(),
    };
  }

  useDebugValue(ref.current);

  return ref.current;
}
</file>

<file path="packages/scan/src/web/utils/lerp.ts">
export const lerp = (start: number, end: number, t: number) => {
  return start + (end - start) * t;
};
</file>

<file path="packages/scan/src/web/utils/lru.ts">
class LRUNode<Key, Value> {
  public next: LRUNode<Key, Value> | undefined;
  public prev: LRUNode<Key, Value> | undefined;

  constructor(
    public key: Key,
    public value: Value,
  ) {}
}

/**
 * Doubly linked list LRU
 */
export class LRUMap<Key, Value> {
  private nodes = new Map<Key, LRUNode<Key, Value>>();

  private head: LRUNode<Key, Value> | undefined;
  private tail: LRUNode<Key, Value> | undefined;

  constructor(public limit: number) {}

  has(key: Key) {
    return this.nodes.has(key);
  }

  get(key: Key): Value | undefined {
    const result = this.nodes.get(key);
    if (result) {
      this.bubble(result);
      return result.value;
    }
    return undefined;
  }

  set(key: Key, value: Value): void {
    // If node already exists, bubble up
    if (this.nodes.has(key)) {
      const result = this.nodes.get(key);
      if (result) {
        this.bubble(result);
      }
      return;
    }

    // create a new node
    const node = new LRUNode(key, value);

    // Set node as head
    this.insertHead(node);

    // if the map is already at it's limit, remove the old tail
    if (this.nodes.size === this.limit && this.tail) {
      this.delete(this.tail.key);
    }

    this.nodes.set(key, node);
  }

  delete(key: Key): void {
    const result = this.nodes.get(key);

    if (result) {
      this.removeNode(result);
      this.nodes.delete(key);
    }
  }

  private insertHead(node: LRUNode<Key, Value>): void {
    if (this.head) {
      node.next = this.head;
      this.head.prev = node;
    } else {
      this.tail = node;
      node.next = undefined;
    }
    node.prev = undefined;
    this.head = node;
  }

  private removeNode(node: LRUNode<Key, Value>): void {
    // Link previous node to next node
    if (node.prev) {
      node.prev.next = node.next;
    }
    // and vice versa
    if (node.next) {
      node.next.prev = node.prev;
    }

    if (node === this.tail) {
      this.tail = node.prev;
      if (this.tail) {
        this.tail.next = undefined;
      }
    }
  }

  private insertBefore(
    node: LRUNode<Key, Value>,
    newNode: LRUNode<Key, Value>,
  ) {
    newNode.next = node;
    if (node.prev) {
      newNode.prev = node.prev;
      node.prev.next = newNode;
    } else {
      newNode.prev = undefined;
      this.head = newNode;
    }
    node.prev = newNode;
  }

  private bubble(node: LRUNode<Key, Value>) {
    if (node.prev) {
      // Remove the node
      this.removeNode(node);
      // swap places with previous node
      this.insertBefore(node.prev, node);
    }
  }
}
</file>

<file path="packages/scan/src/types.d.ts">
declare module './new-outlines/offscreen-canvas.worker' {
  const workerCode: string;
  export default workerCode;
}
</file>

<file path="packages/scan/src/worker-shim.ts">
// This gets injected into the bundle
export function createInlineWorker(code: string) {
  const blob = new Blob([code], { type: 'application/javascript' });
  const url = URL.createObjectURL(blob);
  return new Worker(url);
}
</file>

<file path="packages/scan/auto.d.ts">
export * from './dist/auto';
</file>

<file path="packages/scan/global.d.ts">
declare module '*.css' {
  const content: string;
  export default content;
}

declare module '*.astro' {
  const Component: unknown;
  export default Component;
}
</file>

<file path="packages/scan/worker-plugin.ts">
import * as esbuild from 'esbuild';

/**
 * A hacky plugin to build the worker file (resolving all imports), and inline
 * the javascript into a variable by replacing __WORKER_CODE__ string in bundle with the worker
 * build output
 */
export const workerPlugin = {
  name: 'worker-plugin',
  setup(build) {
    const workerResult = esbuild.buildSync({
      entryPoints: ['src/new-outlines/offscreen-canvas.worker.ts'],
      bundle: true,
      write: false,
      format: 'iife',
      platform: 'browser',
      minify: true,
    });
    const workerCode = workerResult.outputFiles[0].text;

    build.onEnd((result) => {
      if (!result.outputFiles) return;

      for (const file of result.outputFiles) {
        const newText = file.text.replace(
          'var workerCode = "__WORKER_CODE__"',
          `var workerCode = ${JSON.stringify(workerCode)}`,
        );
        file.contents = Buffer.from(newText);
      }
    });
  },
};
</file>

<file path="packages/scan/src/core/monitor/constants.ts">
/**
 * We do prototype caching for highly performant code, do not put browser specific code here without a guard.
 *
 * _{global} is also a hack that reduces the size of the bundle
 *
 * Examples:
 * @see https://github.com/ged-odoo/blockdom/blob/5849f0887ff8dc7f3f173f870ed850a89946fcfd/src/block_compiler.ts#L9
 * @see https://github.com/localvoid/ivi/blob/bd5bbe8c6b39a7be1051c16ea0a07b3df9a178bd/packages/ivi/src/client/core.ts#L13
 */

/**
 * Do not destructure exports or import React from "react" here.
 * From empirical ad-hoc testing, this breaks in certain scenarios.
 */
import * as React from 'react';
import { IS_CLIENT } from '~web/utils/constants';

/**
 * useRef will be undefined in "use server"
 *
 * @see https://nextjs.org/docs/messages/react-client-hook-in-server-component
 */
const isRSC = () => !React.useRef;
export const isSSR = () => !IS_CLIENT || isRSC();

interface WindowWithCypress extends Window {
  Cypress?: unknown;
}

export const isTest =
  (IS_CLIENT &&
    /**
     * @see https://docs.cypress.io/faq/questions/using-cypress-faq#Is-there-any-way-to-detect-if-my-app-is-running-under-Cypress
     */
    ((window as WindowWithCypress).Cypress ||
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/webdriver
       */
      navigator.webdriver)) ||
  /**
   * @see https://stackoverflow.com/a/60491322
   */
  // @ts-expect-error jest is a global in test
  typeof jest !== 'undefined';

export const VERSION = null; // todo
export const PAYLOAD_VERSION = null; // todo

export const MAX_QUEUE_SIZE = 300;
export const FLUSH_TIMEOUT = isTest
  ? 100 // Make sure there is no data loss in tests
  : process.env.NODE_ENV === 'production'
    ? 5000
    : 1000;
export const SESSION_EXPIRE_TIMEOUT = 300000; // 5 minutes
export const GZIP_MIN_LEN = 1000;
export const GZIP_MAX_LEN = 60000; // 1 minute
export const MAX_PENDING_REQUESTS = 15;
</file>

<file path="packages/scan/src/core/notifications/types.ts">
export interface PerformanceInteractionEntry extends PerformanceEntry {
  interactionId: string;
  target: Element;
  name: string;
  duration: number;
  startTime: number;
  processingStart: number;
  processingEnd: number;
  entryType: string;
}
export interface PerformanceInteraction {
  id: string;
  latency: number;
  entries: Array<PerformanceInteractionEntry>;
  target: Element | null;
  type: "pointer" | "keyboard";
  startTime: number;
  endTime: number;
  processingStart: number;
  processingEnd: number;
  duration: number;
  inputDelay: number;
  processingDuration: number;
  presentationDelay: number;
  timestamp: number;
  timeSinceTabInactive: number | "never-hidden";
  visibilityState: DocumentVisibilityState;
  timeOrigin: number;
  referrer: string;
  detailedTiming?: {
    jsHandlersTime: number; // pointerup -> click
    prePaintTime: number; // click -> RAF
    paintTime: number; // RAF -> setTimeout
    compositorTime: number; // remaining duration
  };
}
</file>

<file path="packages/scan/src/new-outlines/types.ts">
export interface OutlineData {
  id: number;
  name: string;
  count: number;
  x: number;
  y: number;
  width: number;
  height: number;
  didCommit: 0 | 1;
}

export type InlineOutlineData = [
  id: number,
  count: number,
  x: number,
  y: number,
  width: number,
  height: number,
  didCommit: 0 | 1,
];

export interface ActiveOutline {
  id: number;
  name: string;
  count: number;
  x: number;
  y: number;
  width: number;
  height: number;
  targetX: number;
  targetY: number;
  targetWidth: number;
  targetHeight: number;
  frame: number;
  didCommit: 1 | 0;
}

export interface BlueprintOutline {
  name: string;
  count: number;
  elements: Element[];
  didCommit: 1 | 0;
}

declare global {
  var __REACT_SCAN_STOP__: boolean;
  var ReactScan: {
    hasStopped: () => boolean;
    stop: () => void;
    cleanup: () => void;
    init: () => void;
    flushOutlines: () => void;
  };
}
</file>

<file path="packages/scan/src/react-component-name/__tests__/utils.ts">
import { type Options, reactComponentNamePlugin } from '..';

type TransformFn = (
  code: string,
  id: string,
) => Promise<{ code: string } | string | null>;

export const transform = async (code: string, options?: Options) => {
  const plugin = reactComponentNamePlugin.vite(options || {}) as {
    transform: TransformFn;
  };
  const transformFn = plugin.transform;
  if (!transformFn) return code;

  const result = await transformFn.call(
    {
      getCombinedSourcemap: () => null,
      error: console.error,
    },
    code,
    'test.tsx',
  );

  if (!result) return code;
  if (typeof result === 'string') return result;
  return result.code;
};
</file>

<file path="packages/scan/src/react-component-name/babel/index.ts">
import type { NodePath, PluginObj } from '@babel/core';
import * as t from '@babel/types';
import type { Options } from '../core/options';
import { isComponentishName } from './is-componentish-name';
import { pathReferencesImport } from './path-references-import';
import { unwrapNode, unwrapPath } from './unwrap';

function getAssignedDisplayNames(path: NodePath<t.Program>): Set<string> {
  const names = new Set<string>();
  path.traverse({
    AssignmentExpression(path) {
      const { node } = path;

      const memberExpr = unwrapNode(node.left, t.isMemberExpression);
      if (!memberExpr) {
        return;
      }
      const object = unwrapNode(memberExpr.object, t.isIdentifier);
      if (!object) {
        return;
      }
      if (
        t.isIdentifier(memberExpr.property) &&
        memberExpr.property.name === 'displayName'
      ) {
        names.add(object.name);
      }
    },
  });
  return names;
}

function isValidFunction(
  node: t.Node,
): node is t.ArrowFunctionExpression | t.FunctionExpression {
  return t.isArrowFunctionExpression(node) || t.isFunctionExpression(node);
}

function assignDisplayName(
  statement: NodePath<t.Statement>,
  name: string,
  dontAddTryCatch = false,
): void {
  if (dontAddTryCatch) {
    statement.insertAfter([
      t.expressionStatement(
        t.assignmentExpression(
          '=',
          t.memberExpression(t.identifier(name), t.identifier('displayName')),
          t.stringLiteral(name),
        ),
      ),
    ]);
  } else {
    statement.insertAfter([
      t.tryStatement(
        t.blockStatement([
          t.expressionStatement(
            t.assignmentExpression(
              '=',
              t.memberExpression(
                t.identifier(name),
                t.identifier('displayName'),
              ),
              t.stringLiteral(name),
            ),
          ),
        ]),
        t.catchClause(t.identifier('error'), t.blockStatement([])),
      ),
    ]);
  }
}

const REACT_CLASS = ['Component', 'PureComponent'];

function isNamespaceExport(
  namespace: string,
  moduleExports: string[],
  path: NodePath<t.Expression>,
): boolean {
  const identifier = unwrapPath(path, t.isIdentifier);
  if (identifier) {
    return moduleExports.includes(identifier.node.name);
  }
  const memberExpr = unwrapPath(path, t.isMemberExpression);
  if (memberExpr) {
    const object = unwrapPath(memberExpr.get('object'), t.isIdentifier);
    if (object && object.node.name === namespace) {
      const property = memberExpr.get('property');
      return (
        property.isIdentifier() && moduleExports.includes(property.node.name)
      );
    }
  }
  return false;
}

function isReactClassComponent(path: NodePath<t.Class>): boolean {
  const superClass = path.get('superClass');

  if (!superClass.isExpression()) {
    return false;
  }
  if (isNamespaceExport('React', REACT_CLASS, superClass)) {
    return true;
  }
  // The usual
  if (pathReferencesImport(superClass, 'react', REACT_CLASS, false, true)) {
    return true;
  }
  return false;
}

function isStyledComponent(
  moduleName: string,
  importName: string[],
  path: NodePath<t.Expression>,
): boolean {
  function isStyledImport(path: NodePath<t.Node>): boolean {
    return (
      (path.isIdentifier() && path.node.name === 'styled') ||
      pathReferencesImport(path, moduleName, importName, false, false)
    );
  }
  const callExpr = unwrapPath(path, t.isCallExpression);
  if (callExpr) {
    const callee = callExpr.get('callee');
    // styled('h1', () => {...});
    if (isStyledImport(callee)) {
      return true;
    }
    // styled.h1(() => {...})
    const memberExpr = unwrapPath(callee, t.isMemberExpression);
    if (memberExpr) {
      const object = unwrapPath(memberExpr.get('object'), t.isIdentifier);
      if (object && isStyledImport(object)) {
        return true;
      }
    }

    return false;
  }

  const taggedExpr = unwrapPath(path, t.isTaggedTemplateExpression);
  if (taggedExpr) {
    const tag = taggedExpr.get('tag');

    const memberExpr = unwrapPath(tag, t.isMemberExpression);
    if (memberExpr) {
      const object = unwrapPath(memberExpr.get('object'), t.isIdentifier);
      // styled.h1`...`;
      if (object && isStyledImport(object)) {
        return true;
      }

      return false;
    }

    // styled(Link)`...`
    const callExpr = unwrapPath(tag, t.isCallExpression);
    if (callExpr) {
      const callee = callExpr.get('callee');
      if (isStyledImport(callee)) {
        return true;
      }

      return false;
    }
  }
  return false;
}

const REACT_FACTORY = [
  'forwardRef',
  'memo',
  'createClass',
  // 'lazy',
];

function isReactComponent(
  expr: NodePath<t.Expression>,
  flags: Options['flags'],
): boolean {
  // Check for class components
  const classExpr = unwrapPath(expr, t.isClassExpression);
  if (classExpr && isReactClassComponent(classExpr)) {
    return true;
  }
  // Check for function components
  const funcExpr = unwrapPath(expr, isValidFunction);
  if (funcExpr && !funcExpr.node.generator && funcExpr.node.params.length < 3) {
    return true;
  }
  // Time for call exprs
  const callExpr = unwrapPath(expr, t.isCallExpression);
  if (callExpr) {
    const callee = callExpr.get('callee');
    // React
    const factory = [...REACT_FACTORY];
    if (!flags?.noCreateContext) {
      factory.push('createContext');
    }
    if (
      (callee.isExpression() &&
        isNamespaceExport('React', REACT_FACTORY, callee)) ||
      pathReferencesImport(callee, 'react', REACT_FACTORY, false, true)
    ) {
      return true;
    }
    const identifier = unwrapPath(callee, t.isIdentifier);
    if (identifier) {
      if (identifier.node.name === 'createReactClass') {
        return true;
      }
      // Assume HOCs
      if (/^with[A-Z]/.test(identifier.node.name)) {
        return true;
      }
    }
  }

  if (flags?.noStyledComponents) return false;
  if (isStyledComponent('@emotion/styled', ['default'], expr)) {
    return true;
  }
  if (isStyledComponent('styled-components', ['default'], expr)) {
    return true;
  }
  return false;
}

export const reactScanComponentNamePlugin = (options?: Options): PluginObj => ({
  name: 'react-scan/component-name',
  visitor: {
    Program(path) {
      const assignedNames = getAssignedDisplayNames(path);
      path.traverse({
        ClassDeclaration(path) {
          if (isReactClassComponent(path)) {
            if (!path.node.id) {
              return;
            }
            const name = path.node.id.name;
            if (assignedNames.has(name)) {
              return;
            }
            assignDisplayName(path, name, options?.flags?.noTryCatchDisplayNames);
          }
        },
        FunctionDeclaration(path) {
          const decl = path.node;

          if (
            // Check if the declaration has an identifier, and then check
            decl.id &&
            // if the name is component-ish
            isComponentishName(decl.id.name, options?.flags) &&
            !decl.generator &&
            // Might be component-like, but the only valid components
            // have zero, one or two (forwardRef) parameters
            decl.params.length < 3
          ) {
            if (!path.node.id) {
              return;
            }
            const name = path.node.id.name;
            if (assignedNames.has(name)) {
              return;
            }
            assignDisplayName(path, name, options?.flags?.noTryCatchDisplayNames);
          }
        },
        VariableDeclarator(path) {
          if (!path.parentPath.isVariableDeclaration()) {
            return;
          }
          const identifier = path.node.id;
          const init = path.get('init');
          if (!(init.isExpression() && t.isIdentifier(identifier))) {
            return;
          }
          if (!isComponentishName(identifier.name, options?.flags)) {
            return;
          }
          if (isReactComponent(init, options?.flags)) {
            const name = identifier.name;

            if (!assignedNames.has(name)) {
              assignDisplayName(
                path.parentPath,
                name,
                options?.flags?.noTryCatchDisplayNames,
              );
            }
          }
        },
      });
    },
  },
});
</file>

<file path="packages/scan/src/react-component-name/babel/is-nested-expression.ts">
import type * as t from '@babel/types';
type NestedExpression =
  | t.ParenthesizedExpression
  | t.TypeCastExpression
  | t.TSAsExpression
  | t.TSSatisfiesExpression
  | t.TSNonNullExpression
  | t.TSInstantiationExpression
  | t.TSTypeAssertion;

export const isNestedExpression = (node: t.Node): node is NestedExpression => {
  switch (node.type) {
    case 'ParenthesizedExpression':
    case 'TypeCastExpression':
    case 'TSAsExpression':
    case 'TSSatisfiesExpression':
    case 'TSNonNullExpression':
    case 'TSTypeAssertion':
    case 'TSInstantiationExpression':
      return true;
    default:
      return false;
  }
};
</file>

<file path="packages/scan/src/react-component-name/babel/is-path-valid.ts">
import type { NodePath } from '@babel/core';
import type * as t from '@babel/types';

type TypeFilter<V extends t.Node> = (node: t.Node) => node is V;

export const isPathValid = <V extends t.Node>(
  path: unknown,
  key: TypeFilter<V>,
): path is NodePath<V> => {
  return key((path as NodePath).node);
};
</file>

<file path="packages/scan/src/react-component-name/babel/unwrap.ts">
import type { NodePath } from '@babel/core';
import type * as t from '@babel/types';
import { isNestedExpression } from './is-nested-expression';
import { isPathValid } from './is-path-valid';

type TrueTypeFilter<U extends t.Node> = (node: t.Node) => node is U;
type TypeCheck<K> = K extends TrueTypeFilter<infer U> ? U : never;

type NodeTypeFilter = (node: t.Node) => boolean;

export const unwrapNode = <K extends NodeTypeFilter>(
  node: t.Node | null | undefined,
  key: K,
): TypeCheck<K> | undefined => {
  if (!node) {
    return undefined;
  }
  if (key(node)) {
    return node as TypeCheck<K>;
  }
  if (isNestedExpression(node)) {
    return unwrapNode(node.expression, key);
  }
  return undefined;
};

type PathTypeFilter<V extends t.Node> = (node: t.Node) => node is V;

export const unwrapPath = <V extends t.Node>(
  path: unknown,
  key: PathTypeFilter<V>,
): NodePath<V> | undefined => {
  if (isPathValid(path, key)) {
    return path;
  }
  if (isPathValid(path, isNestedExpression)) {
    return unwrapPath(path.get('expression'), key);
  }
  return undefined;
};
</file>

<file path="packages/scan/src/react-component-name/index.ts">
import { transformAsync } from '@babel/core';
import { createFilter } from '@rollup/pluginutils';
import { createUnplugin } from 'unplugin';
import { reactScanComponentNamePlugin } from './babel';
import type { Options } from './core/options';

export const transform = async (
  code: string,
  id: string,
  filter: (id: string) => boolean,
  options?: Options,
) => {
  if (!filter(id)) return null;

  try {
    const result = await transformAsync(code, {
      plugins: [reactScanComponentNamePlugin(options)],
      ignore: [/\/(?<c>build|node_modules)\//],
      parserOpts: {
        plugins: ['jsx', 'typescript', 'decorators'],
      },
      cloneInputAst: false,
      filename: id,
      ast: false,
      highlightCode: false,
      sourceMaps: true,
      configFile: false,
      babelrc: false,
      generatorOpts: {
        jsescOption: {
          quotes: 'single',
          minimal: true,
        },
      },
    });

    if (result?.code) {
      return { code: result.code ?? '', map: result.map };
    }

    return null;
  } catch (error) {
    // biome-ignore lint/suspicious/noConsole: Intended debug output
    console.error('Error processing file:', id, error);
    return null;
  }
};

export const DEFAULT_INCLUDE = '**/*.{mtsx,mjsx,tsx,jsx}';
export const DEFAULT_EXCLUDE = '**/node_modules/**';
export const reactComponentNamePlugin = createUnplugin<Options>(
  (options?: Options) => {
    // mirror to loader.ts when changing this
    const filter = createFilter(
      options?.include || DEFAULT_INCLUDE,
      options?.exclude || [
        DEFAULT_EXCLUDE,
        // Next.js pages dir specific
        '**/_app.{jsx,tsx,js,ts}',
        '**/_document.{jsx,tsx,js,ts}',
        '**/api/**/*',
        // Million.js specific
        '**/.million/**/*',
      ],
    );

    return {
      name: 'react-component-name',
      enforce: 'post',
      async transform(code, id) {
        return transform(code, id, filter, options);
      },
    };
  },
);

export default reactComponentNamePlugin;
export type { Options };
</file>

<file path="packages/scan/src/react-component-name/loader.ts">
import { type FilterPattern, createFilter } from '@rollup/pluginutils';
import { DEFAULT_EXCLUDE, DEFAULT_INCLUDE, transform } from '.';

interface LoaderContext {
  getOptions(): { include?: FilterPattern; exclude?: FilterPattern };
  resourcePath: string;
  async(): (
    error: Error | null,
    content?: string,
    sourceMap?: string | object,
  ) => void;
}

export default async function ReactComponentNameLoader(
  this: LoaderContext,
  code: string,
  sourceMap: string | object | undefined,
) {
  const parsedMap =
    typeof sourceMap === 'string' ? JSON.parse(sourceMap) : sourceMap;
  const callback = this.async();
  try {
    const options = this.getOptions();
    const id = this.resourcePath;
    const filter = createFilter(
      options?.include || DEFAULT_INCLUDE,
      options?.exclude || [
        DEFAULT_EXCLUDE,
        // Next.js pages dir specific
        '**/_app.{jsx,tsx,js,ts}',
        '**/_document.{jsx,tsx,js,ts}',
        '**/api/**/*',
        // Million.js specific
        '**/.million/**/*',
      ],
    );
    if (!filter(id)) return callback(null, code, parsedMap);

    const result = await transform(code, id, filter);

    callback(
      null,
      result?.code || '',
      result?.map ? JSON.stringify(result.map) : undefined,
    );
  } catch (e) {
    callback(e as Error);
  }
}
</file>

<file path="packages/scan/src/web/hooks/use-delayed-value.ts">
import { useEffect, useState } from 'preact/hooks';

/**
 * Delays a boolean value change by a specified duration.
 * Perfect for coordinating animations with state changes.
 *
 * @param {boolean} value - The boolean value to delay
 * @param {number} onDelay - Milliseconds to wait before changing to true
 * @param {number} [offDelay] - Milliseconds to wait before changing to false (defaults to onDelay)
 * @returns {boolean} The delayed value
 *
 * @example
 * // Delay both transitions by 300ms
 * const isVisible = useDelayedValue(show, 300);
 *
 * @example
 * // Quick show (100ms), slow hide (500ms)
 * const isVisible = useDelayedValue(show, 100, 500);
 *
 * @example
 * // Use with CSS transitions
 * const isVisible = useDelayedValue(show, 300);
 * return (
 *   <div
 *     className="transition-all duration-300"
 *     style={{
 *       opacity: isVisible ? 1 : 0,
 *       transform: isVisible ? 'none' : 'translateY(4px)'
 *     }}
 *   >
 *     {content}
 *   </div>
 * );
 */
export const useDelayedValue = (
  value: boolean,
  onDelay: number,
  offDelay: number = onDelay,
): boolean => {
  const [delayedValue, setDelayedValue] = useState(value);

  /*
   * biome-ignore lint/correctness/useExhaustiveDependencies:
   * delayedValue is intentionally omitted to prevent unnecessary timeouts
   * and used only in the early return check
   */
  useEffect(() => {
    if (value === delayedValue) return;

    const delay = value ? onDelay : offDelay;
    const timeout = setTimeout(() => setDelayedValue(value), delay);

    return () => clearTimeout(timeout);
  }, [value, onDelay, offDelay]);

  return delayedValue;
};
</file>

<file path="packages/scan/src/web/hooks/use-merged-refs.ts">
import type { Ref, RefCallback } from 'preact';
import { type MutableRefObject, useCallback } from 'preact/compat';

type PossibleRef<T> = Ref<T> | undefined;

const assignRef = <T>(ref: PossibleRef<T>, value: T) => {
  if (typeof ref === 'function') {
    ref(value);
  } else if (ref !== null) {
    (ref as MutableRefObject<T>).current = value;
  }
};

const mergeRefs = <T>(...refs: PossibleRef<T>[]) => {
  return (node: T) => {
    for (const ref of refs) {
      if (ref) {
        assignRef(ref, node);
      }
    }
  };
};

export const useMergedRefs = <T>(...refs: PossibleRef<T>[]) => {
  return useCallback(mergeRefs(...refs), [...refs]) as RefCallback<T>;
};
</file>

<file path="packages/scan/src/web/hooks/use-virtual-list.ts">
import {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'preact/hooks';

export interface VirtualItem {
  key: number;
  index: number;
  start: number;
}

export const useVirtualList = (options: {
  count: number;
  getScrollElement: () => HTMLElement | null;
  estimateSize: () => number;
  overscan?: number;
}) => {
  const { count, getScrollElement, estimateSize, overscan = 5 } = options;
  const [scrollTop, setScrollTop] = useState(0);
  const [containerHeight, setContainerHeight] = useState(0);
  const refResizeObserver = useRef<ResizeObserver>();
  const refScrollElement = useRef<HTMLElement | null>(null);
  const refRafId = useRef<number | null>(null);
  const itemHeight = estimateSize();

  const updateContainer = useCallback((entries?: ResizeObserverEntry[]) => {
    if (!refScrollElement.current) return;

    const height =
      entries?.[0]?.contentRect.height ??
      refScrollElement.current.getBoundingClientRect().height;
    setContainerHeight(height);
  }, []);

  const debouncedUpdateContainer = useCallback(() => {
    if (refRafId.current !== null) {
      cancelAnimationFrame(refRafId.current);
    }
    refRafId.current = requestAnimationFrame(() => {
      updateContainer();
      refRafId.current = null;
    });
  }, [updateContainer]);

  useEffect(() => {
    const element = getScrollElement();
    if (!element) return;

    refScrollElement.current = element;

    const handleScroll = () => {
      if (!refScrollElement.current) return;
      setScrollTop(refScrollElement.current.scrollTop);
    };

    updateContainer();

    if (!refResizeObserver.current) {
      refResizeObserver.current = new ResizeObserver(() => {
        debouncedUpdateContainer();
      });
    }
    refResizeObserver.current.observe(element);

    element.addEventListener('scroll', handleScroll, { passive: true });

    const mutationObserver = new MutationObserver(debouncedUpdateContainer);
    mutationObserver.observe(element, {
      attributes: true,
      childList: true,
      subtree: true,
    });

    return () => {
      element.removeEventListener('scroll', handleScroll);
      if (refResizeObserver.current) {
        refResizeObserver.current.disconnect();
      }
      mutationObserver.disconnect();
      if (refRafId.current !== null) {
        cancelAnimationFrame(refRafId.current);
      }
    };
  }, [getScrollElement, updateContainer, debouncedUpdateContainer]);

  const visibleRange = useMemo(() => {
    const start = Math.floor(scrollTop / itemHeight);
    const visibleCount = Math.ceil(containerHeight / itemHeight);

    return {
      start: Math.max(0, start - overscan),
      end: Math.min(count, start + visibleCount + overscan),
    };
  }, [scrollTop, itemHeight, containerHeight, count, overscan]);

  const items = useMemo(() => {
    const virtualItems: VirtualItem[] = [];
    for (let index = visibleRange.start; index < visibleRange.end; index++) {
      virtualItems.push({
        key: index,
        index,
        start: index * itemHeight,
      });
    }
    return virtualItems;
  }, [visibleRange, itemHeight]);

  return {
    virtualItems: items,
    totalSize: count * itemHeight,
    scrollTop,
    containerHeight,
  };
};
</file>

<file path="packages/scan/src/web/utils/constants.ts">
export const IS_CLIENT = typeof window !== 'undefined';
</file>

<file path="packages/scan/src/web/utils/geiger.ts">
// MIT License
// Copyright (c) 2025 Kristian Dupont

import { isFirefox, readLocalStorage } from './helpers';

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// Taken from: https://github.com/kristiandupont/react-geiger/blob/main/src/Geiger.tsx

// Simple throttle for high-frequency calls
let lastPlayTime = 0;
const MIN_INTERVAL = 32; // ~30fps throttle

// Pre-calculate common values
const BASE_VOLUME = 0.5;
const FREQ_MULTIPLIER = 200;
const DEFAULT_VOLUME = 0.5;

// Ensure volume is between 0 and 1
const storedVolume = Math.max(
  0,
  Math.min(1, readLocalStorage<number>('react-scan-volume') ?? DEFAULT_VOLUME),
);

// Audio configurations for different browsers
const config = {
  firefox: {
    duration: 0.02,
    oscillatorType: 'sine' as const,
    startFreq: 220,
    endFreq: 110,
    attack: 0.0005,
    volumeMultiplier: storedVolume,
  },
  default: {
    duration: 0.001,
    oscillatorType: 'sine' as const,
    startFreq: 440,
    endFreq: 220,
    attack: 0.0005,
    volumeMultiplier: storedVolume,
  },
} as const; // Make entire config readonly

// Cache the selected config
const audioConfig = isFirefox ? config.firefox : config.default;

/**
 * Plays a Geiger counter-like click sound
 * Cross-browser compatible version (Firefox, Chrome, Safari)
 */
export const playGeigerClickSound = (
  audioContext: AudioContext,
  amplitude: number,
) => {
  const now = performance.now();
  if (now - lastPlayTime < MIN_INTERVAL) {
    return;
  }
  lastPlayTime = now;

  // Cache currentTime for consistent timing
  const currentTime = audioContext.currentTime;
  const { duration, oscillatorType, startFreq, endFreq, attack } = audioConfig;

  // Pre-calculate volume once
  const volume =
    Math.max(BASE_VOLUME, amplitude) * audioConfig.volumeMultiplier;

  // Create and configure nodes in one go
  const oscillator = new OscillatorNode(audioContext, {
    type: oscillatorType,
    frequency: startFreq + amplitude * FREQ_MULTIPLIER,
  });

  const gainNode = new GainNode(audioContext, {
    gain: 0,
  });

  // Schedule all parameters
  oscillator.frequency.exponentialRampToValueAtTime(
    endFreq,
    currentTime + duration,
  );
  gainNode.gain.linearRampToValueAtTime(volume, currentTime + attack);

  // Connect and schedule playback
  oscillator.connect(gainNode).connect(audioContext.destination);

  oscillator.start(currentTime);
  oscillator.stop(currentTime + duration);
};
</file>

<file path="packages/scan/src/web/utils/log.ts">
// @ts-nocheck
import { ChangeReason, type Render } from '~core/instrumentation';
import { getLabelText } from '~core/utils';

export const log = (renders: Array<Render>) => {
  const logMap = new Map<
    string,
    Array<{ prev: unknown; next: unknown; type: string; unstable?: boolean }>
  >();
  for (let i = 0, len = renders.length; i < len; i++) {
    const render = renders[i];

    if (!render.componentName) continue;

    const changeLog = logMap.get(render.componentName) ?? [];
    renders;
    const labelText = getLabelText([
      {
        aggregatedCount: 1,

        computedKey: null,
        name: render.componentName,
        frame: null,
        ...render,
        changes: {
          // TODO(Alexis): use a faster reduction method
          type: render.changes.reduce((set, change) => set | change.type, 0),
          unstable: render.changes.some((change) => change.unstable),
        },
        phase: render.phase,
        computedCurrent: null,
      },
    ]);
    if (!labelText) continue;

    let prevChangedProps: Record<string, unknown> | null = null;
    let nextChangedProps: Record<string, unknown> | null = null;

    if (render.changes) {
      for (let i = 0, len = render.changes.length; i < len; i++) {
        const { name, prevValue, nextValue, unstable, type } =
          render.changes[i];
        if (type === ChangeReason.Props) {
          prevChangedProps ??= {};
          nextChangedProps ??= {};
          prevChangedProps[`${unstable ? '⚠️' : ''}${name} (prev)`] = prevValue;
          nextChangedProps[`${unstable ? '⚠️' : ''}${name} (next)`] = nextValue;
        } else {
          changeLog.push({
            prev: prevValue,
            next: nextValue,
            type: type === ChangeReason.Context ? 'context' : 'state',
            unstable: unstable ?? false,
          });
        }
      }
    }

    if (prevChangedProps && nextChangedProps) {
      changeLog.push({
        prev: prevChangedProps,
        next: nextChangedProps,
        type: 'props',
        unstable: false,
      });
    }

    logMap.set(labelText, changeLog);
  }
  for (const [name, changeLog] of Array.from(logMap.entries())) {
    // biome-ignore lint/suspicious/noConsole: Intended debug output
    console.group(
      `%c${name}`,
      'background: hsla(0,0%,70%,.3); border-radius:3px; padding: 0 2px;',
    );
    for (const { type, prev, next, unstable } of changeLog) {
      // biome-ignore lint/suspicious/noConsole: Intended debug output
      console.log(`${type}:`, unstable ? '⚠️' : '', prev, '!==', next);
    }
    // biome-ignore lint/suspicious/noConsole: Intended debug output
    console.groupEnd();
  }
};

export const logIntro = () => {
  if (window.hideIntro) {
    window.hideIntro = undefined;
    return;
  }
  // biome-ignore lint/suspicious/noConsole: Intended debug output
  console.log(
    '%c[·] %cReact Scan',
    'font-weight:bold;color:#7a68e8;font-size:20px;',
    'font-weight:bold;font-size:14px;',
  );
  // biome-ignore lint/suspicious/noConsole: Intended debug output
  console.log(
    'Try React Scan Monitoring to target performance issues in production: https://react-scan.com/monitoring',
  );
};
</file>

<file path="packages/scan/src/web/views/inspector/whats-changed/use-change-store.ts">
import { useEffect, useRef, useState } from 'preact/hooks';
import {
  ChangesListener,
  ChangesPayload,
  ContextChange,
  Store,
} from '~core/index';
import { Fiber, getFiberId } from 'bippy';
import { isEqual } from '~core/utils';
import { signal } from '@preact/signals';

const CHANGES_QUEUE_INTERVAL = 50;

interface SectionData {
  current: Array<{ name: string; value: unknown }>;
  changes: Set<string>;
}

export interface InspectorData {
  fiberProps: SectionData;
  fiberState: SectionData;
  fiberContext: SectionData;
}
interface InspectorState extends InspectorData {
  fiber: Fiber | null;
}

export const inspectorState = signal<InspectorState>({
  fiber: null,
  fiberProps: { current: [], changes: new Set() },
  fiberState: { current: [], changes: new Set() },
  fiberContext: { current: [], changes: new Set() },
});

export type AggregatedChanges = {
  count: number;
  currentValue: unknown;
  previousValue: unknown;
  name: string;
  lastUpdated: number;
  id: string;
};

export type AllAggregatedChanges = {
  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
  propsChanges: Map<any, AggregatedChanges>;
  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
  stateChanges: Map<any, AggregatedChanges>;
  contextChanges: Map<
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    any,
    | { changes: AggregatedChanges; kind: 'initialized' }
    | {
        // this looks weird, because it is
        // its a work around to allow context changes to be sent impotently
        // (react-scan internals do not yet handle sending context changes the render they change)
        kind: 'partially-initialized';
        value: unknown;
        name: string;
        lastUpdated: number;
        id: string;
      }
  >;
};

const getContextChangesValue = (
  discriminated:
    | { kind: 'partially-initialized'; value: unknown }
    | { kind: 'initialized'; changes: AggregatedChanges },
) => {
  switch (discriminated.kind) {
    case 'initialized': {
      return discriminated.changes.currentValue;
    }
    case 'partially-initialized': {
      return discriminated.value;
    }
  }
};
const processChanges = (
  changes: Array<{ name: string; value: unknown; prevValue?: unknown }>,
  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
  targetMap: Map<any, AggregatedChanges>,
) => {
  for (const change of changes) {
    const existing = targetMap.get(change.name);

    if (existing) {
      targetMap.set(existing.name, {
        count: existing.count + 1,
        currentValue: change.value,
        id: existing.name,
        lastUpdated: Date.now(),
        name: existing.name,
        previousValue: change.prevValue,
      });
      continue;
    }

    targetMap.set(change.name, {
      count: 1,
      currentValue: change.value,
      id: change.name,
      lastUpdated: Date.now(),
      name: change.name,
      previousValue: change.prevValue,
    });
  }
};

const processContextChanges = (
  contextChanges: Array<ContextChange>,
  aggregatedChanges: AllAggregatedChanges,
) => {
  for (const change of contextChanges) {
    const existing = aggregatedChanges.contextChanges.get(change.contextType);

    if (existing) {
      if (isEqual(getContextChangesValue(existing), change.value)) {
        continue;
      }
      if (existing.kind === 'partially-initialized') {
        aggregatedChanges.contextChanges.set(change.contextType, {
          kind: 'initialized',
          changes: {
            count: 1,
            currentValue: change.value,
            id: change.contextType.toString(), // come back to this why was this ever expected to be a number?
            lastUpdated: Date.now(),
            name: change.name,
            previousValue: existing.value,
          },
        });
        continue;
      }

      aggregatedChanges.contextChanges.set(change.contextType, {
        kind: 'initialized',
        changes: {
          count: existing.changes.count + 1,
          currentValue: change.value,
          id: change.contextType.toString(),
          lastUpdated: Date.now(),
          name: change.name,
          previousValue: existing.changes.currentValue,
        },
      });

      continue;
    }

    aggregatedChanges.contextChanges.set(change.contextType, {
      kind: 'partially-initialized',
      id: change.contextType.toString(),
      lastUpdated: Date.now(),
      name: change.name,
      value: change.value,
    });
  }
};

const collapseQueue = (queue: Array<ChangesPayload>) => {
  const localAggregatedChanges: AllAggregatedChanges = {
    contextChanges: new Map(),
    propsChanges: new Map(),
    stateChanges: new Map(),
  };

  queue.forEach((changes) => {
    // context is a special case since we don't send precise diffs and need to be idempotent
    processContextChanges(changes.contextChanges, localAggregatedChanges);

    processChanges(changes.stateChanges, localAggregatedChanges.stateChanges);

    processChanges(changes.propsChanges, localAggregatedChanges.propsChanges);
  });

  return localAggregatedChanges;
};
const mergeSimpleChanges = <
  T extends
    | AllAggregatedChanges['propsChanges']
    | AllAggregatedChanges['stateChanges'],
>(
  existingChanges: T,
  incomingChanges: T,
): T => {
  const mergedChanges = new Map();

  existingChanges.forEach((value, key) => {
    mergedChanges.set(key, value);
  });

  incomingChanges.forEach((incomingChange, key) => {
    const existing = mergedChanges.get(key);

    if (!existing) {
      mergedChanges.set(key, incomingChange);
      return;
    }

    mergedChanges.set(key, {
      count: existing.count + incomingChange.count,
      currentValue: incomingChange.currentValue,
      id: incomingChange.id,
      lastUpdated: incomingChange.lastUpdated,
      name: incomingChange.name,
      previousValue: incomingChange.previousValue,
    });
  });

  return mergedChanges as T;
};

const mergeContextChanges = (
  existing: AllAggregatedChanges,
  incoming: AllAggregatedChanges,
) => {
  const contextChanges: AllAggregatedChanges['contextChanges'] = new Map();

  existing.contextChanges.forEach((value, key) => {
    contextChanges.set(key, value);
  });

  incoming.contextChanges.forEach((incomingChange, key) => {
    const existingChange = contextChanges.get(key);

    if (!existingChange) {
      contextChanges.set(key, incomingChange);
      return;
    }
    if (
      getContextChangesValue(incomingChange) ===
      getContextChangesValue(existingChange)
    ) {
      // we do this for a second time just in context merge to handle the partial initialization case (the collapsed queue will not have the information to remove the partially initialized set of changes)
      return;
    }

    switch (existingChange.kind) {
      case 'initialized': {
        switch (incomingChange.kind) {
          case 'initialized': {
            const preInitEntryOffset = 1;
            contextChanges.set(key, {
              kind: 'initialized',
              changes: {
                ...incomingChange.changes,
                // if existing was initialized, the pre-initialization done by the collapsed queue was not necessary, so we need to increment count to account for the preInit entry
                count:
                  incomingChange.changes.count +
                  existingChange.changes.count +
                  preInitEntryOffset,
                currentValue: incomingChange.changes.currentValue,

                previousValue: incomingChange.changes.previousValue, // we always want to show this value, since this will be the true state transition (if you make the previousValue the last seen currentValue, u will have weird behavior with primitive state updates)
              },
            });
            return;
          }
          case 'partially-initialized': {
            contextChanges.set(key, {
              kind: 'initialized',
              changes: {
                count: existingChange.changes.count + 1,
                currentValue: incomingChange.value,
                id: incomingChange.id,
                lastUpdated: incomingChange.lastUpdated,
                name: incomingChange.name,
                previousValue: existingChange.changes.currentValue,
              },
            });
            return;
          }
        }
      }
      case 'partially-initialized': {
        switch (incomingChange.kind) {
          case 'initialized': {
            contextChanges.set(key, {
              kind: 'initialized',
              changes: {
                count: incomingChange.changes.count + 1,
                currentValue: incomingChange.changes.currentValue,
                id: incomingChange.changes.id,
                lastUpdated: incomingChange.changes.lastUpdated,
                name: incomingChange.changes.name,
                previousValue: existingChange.value,
              },
            });
            return;
          }
          case 'partially-initialized': {
            contextChanges.set(key, {
              kind: 'initialized',
              changes: {
                count: 1,
                currentValue: incomingChange.value,
                id: incomingChange.id,
                lastUpdated: incomingChange.lastUpdated,
                name: incomingChange.name,
                previousValue: existingChange.value,
              },
            });
            return;
          }
        }
      }
    }
  });

  return contextChanges;
};

const mergeChanges = (
  existing: AllAggregatedChanges,
  incoming: AllAggregatedChanges,
): AllAggregatedChanges => {
  const contextChanges = mergeContextChanges(existing, incoming);

  const propChanges = mergeSimpleChanges(
    existing.propsChanges,
    incoming.propsChanges,
  );
  const stateChanges = mergeSimpleChanges(
    existing.stateChanges,
    incoming.stateChanges,
  );

  return {
    contextChanges,
    propsChanges: propChanges,
    stateChanges,
  };
};

/**
 * Calculate total count of changes across props, state and context
 */
export const calculateTotalChanges = (changes: AllAggregatedChanges) => {
  return (
    Array.from(changes.propsChanges.values()).reduce(
      (acc, change) => acc + change.count,
      0,
    ) +
    Array.from(changes.stateChanges.values()).reduce(
      (acc, change) => acc + change.count,
      0,
    ) +
    Array.from(changes.contextChanges.values())
      .filter(
        (change): change is Extract<typeof change, { kind: 'initialized' }> =>
          change.kind === 'initialized',
      )
      .reduce((acc, change) => acc + change.changes.count, 0)
  );
};

export const useInspectedFiberChangeStore = (opts?: {
  onChangeUpdate?: (countUpdated: number) => void;
}) => {
  const pendingChanges = useRef<{ queue: ChangesPayload[] }>({ queue: [] });
  // flushed state read from queue stream
  const [aggregatedChanges, setAggregatedChanges] =
    useState<AllAggregatedChanges>({
      propsChanges: new Map(),
      stateChanges: new Map(),
      contextChanges: new Map(),
    });

  const fiber =
    Store.inspectState.value.kind === 'focused'
      ? Store.inspectState.value.fiber
      : null;
  const fiberId = fiber ? getFiberId(fiber) : null;

  // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>
  useEffect(() => {
    const interval = setInterval(() => {
      // optimization to avoid unconditional renders
      if (pendingChanges.current.queue.length === 0) return;

      setAggregatedChanges((prevAggregatedChanges) => {
        const queueChanges = collapseQueue(pendingChanges.current.queue);
        const merged = mergeChanges(prevAggregatedChanges, queueChanges);
        const prevTotal = calculateTotalChanges(prevAggregatedChanges);
        const newTotal = calculateTotalChanges(merged);
        const changeCount = newTotal - prevTotal;
        opts?.onChangeUpdate?.(changeCount);

        return merged;
      });

      pendingChanges.current.queue = [];
    }, CHANGES_QUEUE_INTERVAL);

    return () => {
      clearInterval(interval);
    };
  }, [fiber]);

  // un-throttled subscription
  useEffect(() => {
    if (!fiberId) {
      return;
    }
    const listener: ChangesListener = (change) => {
      pendingChanges.current?.queue.push(change);
    };

    let listeners = Store.changesListeners.get(fiberId);

    if (!listeners) {
      listeners = [];
      Store.changesListeners.set(fiberId, listeners);
    }

    listeners.push(listener);

    return () => {
      setAggregatedChanges({
        propsChanges: new Map(),
        stateChanges: new Map(),
        contextChanges: new Map(),
      });
      pendingChanges.current.queue = [];
      Store.changesListeners.set(
        fiberId,
        Store.changesListeners.get(fiberId)?.filter((l) => l !== listener) ??
          [],
      );
    };
  }, [fiberId]);

  // cleanup
  // biome-ignore lint/correctness/useExhaustiveDependencies: component should really remount when fiber changes, but instead we just re-run effects (should fix)
  useEffect(() => {
    return () => {
      setAggregatedChanges({
        propsChanges: new Map(),
        stateChanges: new Map(),
        contextChanges: new Map(),
      });
      pendingChanges.current.queue = [];
    };
  }, [fiberId]);

  return aggregatedChanges;
};
</file>

<file path="packages/scan/src/web/views/inspector/flash-overlay.ts">
interface FlashEntry {
  element: HTMLElement;
  overlay: HTMLElement;
  scrollCleanup?: () => void;
}

const fadeOutTimers = new WeakMap<HTMLElement, ReturnType<typeof setTimeout>>();

const trackElementPosition = (
  element: Element,
  callback: (element: Element) => void,
): (() => void) => {
  const handleScroll = callback.bind(null, element);

  document.addEventListener('scroll', handleScroll, {
    passive: true,
    capture: true,
  });

  return () => {
    document.removeEventListener('scroll', handleScroll, { capture: true });
  };
};

export const flashManager = {
  activeFlashes: new Map<HTMLElement, FlashEntry>(),

  create(container: HTMLElement) {
    const existingOverlay = container.querySelector(
      '.react-scan-flash-overlay',
    );

    const overlay =
      existingOverlay instanceof HTMLElement
        ? existingOverlay
        : (() => {
            const newOverlay = document.createElement('div');
            newOverlay.className = 'react-scan-flash-overlay';
            container.appendChild(newOverlay);

            const scrollCleanup = trackElementPosition(container, () => {
              if (container.querySelector('.react-scan-flash-overlay')) {
                this.create(container);
              }
            });

            this.activeFlashes.set(container, {
              element: container,
              overlay: newOverlay,
              scrollCleanup,
            });

            return newOverlay;
          })();

    const existingTimer = fadeOutTimers.get(overlay);
    if (existingTimer) {
      clearTimeout(existingTimer);
      fadeOutTimers.delete(overlay);
    }

    requestAnimationFrame(() => {
      overlay.style.transition = 'none';
      overlay.style.opacity = '0.9';

      const timerId = setTimeout(() => {
        overlay.style.transition = 'opacity 150ms ease-out';
        overlay.style.opacity = '0';

        const cleanupTimer = setTimeout(() => {
          if (overlay.parentNode) {
            overlay.parentNode.removeChild(overlay);
          }
          const entry = this.activeFlashes.get(container);
          if (entry?.scrollCleanup) {
            entry.scrollCleanup();
          }
          this.activeFlashes.delete(container);
          fadeOutTimers.delete(overlay);
        }, 150);

        fadeOutTimers.set(overlay, cleanupTimer);
      }, 300);

      fadeOutTimers.set(overlay, timerId);
    });
  },

  cleanup(container: HTMLElement) {
    const entry = this.activeFlashes.get(container);
    if (entry) {
      const existingTimer = fadeOutTimers.get(entry.overlay);
      if (existingTimer) {
        clearTimeout(existingTimer);
        fadeOutTimers.delete(entry.overlay);
      }
      if (entry.overlay.parentNode) {
        entry.overlay.parentNode.removeChild(entry.overlay);
      }
      if (entry.scrollCleanup) {
        entry.scrollCleanup();
      }
      this.activeFlashes.delete(container);
    }
  },

  cleanupAll() {
    for (const [, entry] of this.activeFlashes) {
      this.cleanup(entry.element);
    }
  },
};
</file>

<file path="packages/scan/src/web/views/inspector/logging.ts">
/**
 * Safely stringifies any value, handling circular references and special types
 */
export function safeStringify(value: unknown): string {
  const seen = new WeakSet();

  return JSON.stringify(
    value,
    (_key, value) => {
      if (typeof value === 'function') {
        return '[Function]';
      }
      if (value instanceof Error) {
        return `[Error: ${value.message}]`;
      }
      if (value instanceof RegExp) {
        return value.toString();
      }
      if (value instanceof Map) {
        return `Map(${value.size})`;
      }
      if (value instanceof Set) {
        return `Set(${value.size})`;
      }
      if (typeof value === 'object' && value !== null) {
        if (seen.has(value)) {
          return '[Circular]';
        }
        seen.add(value);
      }
      return value;
    },
    2,
  );
}
</file>

<file path="packages/scan/src/web/views/inspector/states.ts">
import { signal } from '@preact/signals';
import type { Fiber } from 'bippy';
import type { ComponentType } from 'preact';
import { flashManager } from './flash-overlay';
import { type SectionData, resetTracking } from './timeline/utils';

export interface MinimalFiberInfo {
  id?: string | number;
  key: string | null;
  type: ComponentType<unknown> | string;
  displayName: string;
  selfTime: number;
  totalTime: number;
}

export interface TimelineUpdate {
  timestamp: number;
  fiberInfo: MinimalFiberInfo;
  props: SectionData;
  state: SectionData;
  context: SectionData;
  stateNames: string[];
}

export interface TimelineState {
  updates: Array<TimelineUpdate>;
  currentFiber: Fiber | null;
  totalUpdates: number;
  windowOffset: number;
  currentIndex: number;
  isViewingHistory: boolean;
  latestFiber: Fiber | null;
  isVisible: boolean;
  playbackSpeed: 1 | 2 | 4;
}

export const TIMELINE_MAX_UPDATES = 1000;

export const timelineStateDefault: TimelineState = {
  updates: [],
  currentFiber: null,
  totalUpdates: 0,
  windowOffset: 0,
  currentIndex: 0,
  isViewingHistory: false,
  latestFiber: null,
  isVisible: false,
  playbackSpeed: 1,
};

export const timelineState = signal<TimelineState>(timelineStateDefault);

export const inspectorUpdateSignal = signal<number>(0);

let pendingUpdates: Array<{ update: TimelineUpdate; fiber: Fiber | null }> = [];
let batchTimeout: ReturnType<typeof setTimeout> | null = null;

const batchUpdates = () => {
  if (pendingUpdates.length === 0) return;

  const batchedUpdates = [...pendingUpdates];

  const { updates, totalUpdates, currentIndex, isViewingHistory } =
    timelineState.value;
  const newUpdates = [...updates];
  let newTotalUpdates = totalUpdates;

  for (const { update } of batchedUpdates) {
    if (newUpdates.length >= TIMELINE_MAX_UPDATES) {
      newUpdates.shift();
    }
    newUpdates.push(update);
    newTotalUpdates++;
  }

  const newWindowOffset = Math.max(0, newTotalUpdates - TIMELINE_MAX_UPDATES);

  let newCurrentIndex: number;
  if (isViewingHistory) {
    if (currentIndex === totalUpdates - 1) {
      newCurrentIndex = newUpdates.length - 1;
    } else if (currentIndex === 0) {
      newCurrentIndex = 0;
    } else {
      if (newWindowOffset === 0) {
        newCurrentIndex = currentIndex;
      } else {
        newCurrentIndex = currentIndex - 1;
      }
    }
  } else {
    newCurrentIndex = newUpdates.length - 1;
  }

  const lastUpdate = batchedUpdates[batchedUpdates.length - 1];

  timelineState.value = {
    ...timelineState.value,
    latestFiber: lastUpdate.fiber,
    updates: newUpdates,
    totalUpdates: newTotalUpdates,
    windowOffset: newWindowOffset,
    currentIndex: newCurrentIndex,
    isViewingHistory,
  };

  // Only after signal is updated, remove the processed updates
  pendingUpdates = pendingUpdates.slice(batchedUpdates.length);
};

export const timelineActions = {
  showTimeline: () => {
    timelineState.value = {
      ...timelineState.value,
      isVisible: true,
    };
  },

  hideTimeline: () => {
    timelineState.value = {
      ...timelineState.value,
      isVisible: false,
      currentIndex: timelineState.value.updates.length - 1,
    };
  },

  updateFrame: (index: number, isViewingHistory: boolean) => {
    timelineState.value = {
      ...timelineState.value,
      currentIndex: index,
      isViewingHistory,
    };
  },

  updatePlaybackSpeed: (speed: TimelineState['playbackSpeed']) => {
    timelineState.value = {
      ...timelineState.value,
      playbackSpeed: speed,
    };
  },

  addUpdate: (update: TimelineUpdate, latestFiber: Fiber | null) => {
    pendingUpdates.push({ update, fiber: latestFiber });

    if (!batchTimeout) {
      const processBatch = () => {
        batchUpdates();

        batchTimeout = null;

        if (pendingUpdates.length > 0) {
          batchTimeout = setTimeout(processBatch, 96);
        }
      };

      batchTimeout = setTimeout(processBatch, 96);
    }
  },

  reset: () => {
    if (batchTimeout) {
      clearTimeout(batchTimeout);
      batchTimeout = null;
    }
    pendingUpdates = [];
    timelineState.value = timelineStateDefault;
  },
};

export const globalInspectorState = {
  lastRendered: new Map<string, unknown>(),
  expandedPaths: new Set<string>(),
  cleanup: () => {
    globalInspectorState.lastRendered.clear();
    globalInspectorState.expandedPaths.clear();
    flashManager.cleanupAll();
    resetTracking();
    timelineState.value = timelineStateDefault;
  },
};
</file>

<file path="packages/scan/src/web/views/inspector/utils.ts">
import {
  type Fiber,
  FunctionComponentTag,
  type MemoizedState,
  getDisplayName,
  getTimings,
  isCompositeFiber,
  isHostFiber,
  traverseFiber,
} from 'bippy';
import { type PropsChange, ReactScanInternals } from '~core/index';
import { ChangeReason } from '~core/instrumentation';
import { isEqual } from '~core/utils';
import { batchGetBoundingRects } from '~web/utils/outline';
import { globalInspectorState } from '.';
import type { ExtendedReactRenderer } from '../../../types';
import { TIMELINE_MAX_UPDATES } from './states';
import type { MinimalFiberInfo } from './states';
import { getAllFiberContexts, getStateNames } from './timeline/utils';

interface StateItem {
  name: string;
  value: unknown;
}

// todo, change this to currently focused fiber
export type States =
  | {
      kind: 'inspecting';
      hoveredDomElement: Element | null;
    }
  | {
      kind: 'inspect-off';
    }
  | {
      kind: 'focused';
      focusedDomElement: Element;
      fiber: Fiber;
    }
  | {
      kind: 'uninitialized';
    };

interface ReactRootContainer {
  _reactRootContainer?: {
    _internalRoot?: {
      current?: {
        child: Fiber;
      };
    };
  };
}

interface ReactInternalProps {
  [key: string]: Fiber;
}

export const getFiberFromElement = (element: Element): Fiber | null => {
  if ('__REACT_DEVTOOLS_GLOBAL_HOOK__' in window) {
    const hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!hook?.renderers) return null;

    for (const [, renderer] of Array.from(hook.renderers)) {
      try {
        const fiber = renderer.findFiberByHostInstance?.(element);
        if (fiber) return fiber;
      } catch {
        // If React is mid-render, references to previous nodes may disappear
      }
    }
  }

  if ('_reactRootContainer' in element) {
    const elementWithRoot = element as unknown as ReactRootContainer;
    const rootContainer = elementWithRoot._reactRootContainer;
    return rootContainer?._internalRoot?.current?.child ?? null;
  }

  for (const key in element) {
    if (
      key.startsWith('__reactInternalInstance$') ||
      key.startsWith('__reactFiber')
    ) {
      const elementWithFiber = element as unknown as ReactInternalProps;
      return elementWithFiber[key];
    }
  }
  return null;
};

export const getFirstStateNode = (fiber: Fiber): Element | null => {
  let current: Fiber | null = fiber;
  while (current) {
    if (current.stateNode instanceof Element) {
      return current.stateNode;
    }

    if (!current.child) {
      break;
    }
    current = current.child;
  }

  while (current) {
    if (current.stateNode instanceof Element) {
      return current.stateNode;
    }

    if (!current.return) {
      break;
    }
    current = current.return;
  }
  return null;
};

export const getNearestFiberFromElement = (
  element: Element | null,
): Fiber | null => {
  if (!element) return null;

  try {
    const fiber = getFiberFromElement(element);
    if (!fiber) return null;

    const res = getParentCompositeFiber(fiber);
    return res ? res[0] : null;
  } catch {
    return null;
  }
};

export const getParentCompositeFiber = (
  fiber: Fiber,
): readonly [Fiber, Fiber | null] | null => {
  let current: Fiber | null = fiber;
  let prevHost: Fiber | null = null;

  while (current) {
    if (isCompositeFiber(current)) return [current, prevHost] as const;
    if (isHostFiber(current) && !prevHost) prevHost = current;
    current = current.return;
  }

  return null;
};


const isFiberInTree = (fiber: Fiber, root: Fiber): boolean => {
  {
    // const root= fiberRootCache.get(fiber) || (fiber.alternate && fiberRootCache.get(fiber.alternate) )
    // if (root){
    //   return root
    // }
    const res = !!traverseFiber(root, (searchFiber) => searchFiber === fiber);

    return res;
  }
};

export const isCurrentTree = (fiber: Fiber) => {
  let curr: Fiber | null = fiber;
  let rootFiber: Fiber | null = null;

  while (curr) {
    // todo: make sure removing null check doesn't break
    // todo: document that fiber stores root in stateNode
    if (!curr.stateNode) {
      curr = curr.return;
      continue;
    }
    // if the app never rendered then fiber roots will always return false, but thats fine since we don't care which
    // fiber we read from when there never has been a re-render
    // todo: document that better
    if (ReactScanInternals.instrumentation?.fiberRoots.has(curr.stateNode)) {
      rootFiber = curr;

      break;
    }

    curr = curr.return;
  }

  if (!rootFiber) {
    return false;
  }

  const fiberRoot = rootFiber.stateNode;
  const currentRootFiber = fiberRoot.current;

  return isFiberInTree(fiber, currentRootFiber);
};

export const getAssociatedFiberRect = async (element: Element) => {
  const associatedFiber = getNearestFiberFromElement(element);

  if (!associatedFiber) return null;
  const stateNode = getFirstStateNode(associatedFiber);
  if (!stateNode) return null;

  const rect = (await batchGetBoundingRects([stateNode])).get(stateNode);
  if (!rect) return null;
  return rect;
};

// todo-before-stable(rob): refactor these
export const getCompositeComponentFromElement = (element: Element) => {
  const associatedFiber = getNearestFiberFromElement(element);

  if (!associatedFiber) return {};

  const stateNode = getFirstStateNode(associatedFiber);
  if (!stateNode) return {};
  const parentCompositeFiberInfo = getParentCompositeFiber(associatedFiber);
  if (!parentCompositeFiberInfo) {
    return {};
  }
  const [parentCompositeFiber] = parentCompositeFiberInfo;

  return {
    parentCompositeFiber,
  };
};

export const getCompositeFiberFromElement = (
  element: Element,
  knownFiber?: Fiber,
) => {
  if (!element.isConnected) return {};

  let fiber = knownFiber ?? getNearestFiberFromElement(element);
  if (!fiber) return {};

  // Find root once and cache it
  let curr: Fiber | null = fiber;
  let rootFiber: Fiber | null = null;
  let currentRootFiber: Fiber | null = null;

  while (curr) {
    if (!curr.stateNode) {
      curr = curr.return;
      continue;
    }
    if (ReactScanInternals.instrumentation?.fiberRoots.has(curr.stateNode)) {
      rootFiber = curr;
      currentRootFiber = curr.stateNode.current;
      break;
    }
    curr = curr.return;
  }

  if (!rootFiber || !currentRootFiber) return {};

  // Get the current associated fiber using cached root
  fiber = isFiberInTree(fiber, currentRootFiber)
    ? fiber
    : (fiber.alternate ?? fiber);
  if (!fiber) return {};

  if (!getFirstStateNode(fiber)) return {};

  // Get parent composite fiber
  const parentCompositeFiber = getParentCompositeFiber(fiber)?.[0];
  if (!parentCompositeFiber) return {};

  // Use cached root to check parent fiber
  return {
    parentCompositeFiber: isFiberInTree(parentCompositeFiber, currentRootFiber)
      ? parentCompositeFiber
      : (parentCompositeFiber.alternate ?? parentCompositeFiber),
  };
};

export const getChangedPropsDetailed = (fiber: Fiber): Array<PropsChange> => {
  const currentProps = fiber.memoizedProps ?? {};
  const previousProps = fiber.alternate?.memoizedProps ?? {};
  const changes: Array<PropsChange> = [];

  for (const key in currentProps) {
    if (key === 'children') continue;

    const currentValue = currentProps[key];
    const prevValue = previousProps[key];

    if (!isEqual(currentValue, prevValue)) {
      changes.push({
        name: key,
        value: currentValue,
        prevValue,
        type: ChangeReason.Props,
      });
    }
  }

  return changes;
};

export interface OverrideMethods {
  overrideProps:
    | ((fiber: Fiber, path: string[], value: unknown) => void)
    | null;
  overrideHookState:
    | ((fiber: Fiber, id: string, path: string[], value: unknown) => void)
    | null;
  overrideContext:
    | ((fiber: Fiber, contextType: unknown, value: unknown) => void)
    | null;
}

const isRecord = (value: unknown): value is Record<string, unknown> => {
  return value !== null && typeof value === 'object';
};

export const getOverrideMethods = (): OverrideMethods => {
  let overrideProps: OverrideMethods['overrideProps'] = null;
  let overrideHookState: OverrideMethods['overrideHookState'] = null;
  let overrideContext: OverrideMethods['overrideContext'] = null;

  if ('__REACT_DEVTOOLS_GLOBAL_HOOK__' in window) {
    const hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!hook?.renderers) {
      return {
        overrideProps: null,
        overrideHookState: null,
        overrideContext: null,
      };
    }

    for (const [, renderer] of Array.from(hook.renderers)) {
      try {
        const devToolsRenderer = renderer as ExtendedReactRenderer;

        if (overrideHookState) {
          const prevOverrideHookState = overrideHookState;
          overrideHookState = (
            fiber: Fiber,
            id: string,
            path: string[],
            value: unknown,
          ) => {
            // Find the hook
            let current = fiber.memoizedState;
            for (let i = 0; i < Number(id); i++) {
              if (!current?.next) break;
              current = current.next;
            }

            if (current?.queue) {
              // Update through React's queue mechanism
              const queue = current.queue;
              if (isRecord(queue) && 'dispatch' in queue) {
                const dispatch = queue.dispatch as (value: unknown) => void;
                dispatch(value);
                return;
              }
            }

            // Chain updates through all renderers to ensure consistency across different React renderers
            // (e.g., React DOM + React Native Web in the same app)
            prevOverrideHookState(fiber, id, path, value);
            devToolsRenderer.overrideHookState?.(fiber, id, path, value);
          };
        } else if (devToolsRenderer.overrideHookState) {
          overrideHookState = devToolsRenderer.overrideHookState;
        }

        if (overrideProps) {
          const prevOverrideProps = overrideProps;
          overrideProps = (
            fiber: Fiber,
            path: Array<string>,
            value: unknown,
          ) => {
            // Chain updates through all renderers to maintain consistency
            prevOverrideProps(fiber, path, value);
            devToolsRenderer.overrideProps?.(fiber, path, value);
          };
        } else if (devToolsRenderer.overrideProps) {
          overrideProps = devToolsRenderer.overrideProps;
        }

        // For context, we don't need the chaining pattern since we're using overrideProps internally
        // to update the context provider's value prop, which already handles the chaining
        overrideContext = (
          fiber: Fiber,
          contextType: unknown,
          value: unknown,
        ) => {
          // Find the provider fiber for this context
          let current: Fiber | null = fiber;
          while (current) {
            const type = current.type as { Provider?: unknown };
            if (type === contextType || type?.Provider === contextType) {
              // Found the provider, update both current and alternate fibers
              if (overrideProps) {
                overrideProps(current, ['value'], value);
                if (current.alternate) {
                  overrideProps(current.alternate, ['value'], value);
                }
              }
              break;
            }
            current = current.return;
          }
        };
      } catch {
        /**/
      }
    }
  }

  return { overrideProps, overrideHookState, overrideContext };
};

export const nonVisualTags = new Set([
  'HTML',
  'HEAD',
  'META',
  'TITLE',
  'BASE',
  'SCRIPT',
  'SCRIPT',
  'STYLE',
  'LINK',
  'NOSCRIPT',
  'SOURCE',
  'TRACK',
  'EMBED',
  'OBJECT',
  'PARAM',
  'TEMPLATE',
  'PORTAL',
  'SLOT',
  'AREA',
  'XML',
  'DOCTYPE',
  'COMMENT',
]);

export const findComponentDOMNode = (
  fiber: Fiber,
  excludeNonVisualTags = true,
): HTMLElement | null => {
  if (fiber.stateNode && 'nodeType' in fiber.stateNode) {
    const element = fiber.stateNode as HTMLElement;
    if (
      excludeNonVisualTags &&
      element.tagName &&
      nonVisualTags.has(element.tagName.toLowerCase())
    ) {
      return null;
    }
    return element;
  }

  let child = fiber.child;
  while (child) {
    const result = findComponentDOMNode(child, excludeNonVisualTags);
    if (result) return result;
    child = child.sibling;
  }

  return null;
};

export interface InspectableElement {
  element: HTMLElement;
  depth: number;
  name: string;
  fiber: Fiber;
}

export const getInspectableElements = (
  root: HTMLElement = document.body,
): Array<InspectableElement> => {
  const result: Array<InspectableElement> = [];

  const findInspectableFiber = (
    element: HTMLElement | null,
  ): HTMLElement | null => {
    if (!element) return null;

    const { parentCompositeFiber } = getCompositeComponentFromElement(element);
    if (!parentCompositeFiber) return null;

    const componentRoot = findComponentDOMNode(parentCompositeFiber);
    return componentRoot === element ? element : null;
  };

  const traverse = (element: HTMLElement, depth = 0) => {
    const inspectable = findInspectableFiber(element);
    if (inspectable) {
      const { parentCompositeFiber } =
        getCompositeComponentFromElement(inspectable);

      if (!parentCompositeFiber) return;

      result.push({
        element: inspectable,
        depth,
        name: getDisplayName(parentCompositeFiber.type) ?? 'Unknown',
        fiber: parentCompositeFiber,
      });
    }

    // Traverse children first (depth-first)
    for (const child of Array.from(element.children)) {
      traverse(child as HTMLElement, inspectable ? depth + 1 : depth);
    }
  };

  traverse(root);
  return result;
};

const fiberMap = new WeakMap<HTMLElement, Fiber>();

export const getInspectableAncestors = (
  element: HTMLElement,
): Array<InspectableElement> => {
  const result: Array<InspectableElement> = [];

  const findInspectableFiber = (
    element: HTMLElement | null,
  ): HTMLElement | null => {
    if (!element) return null;
    const { parentCompositeFiber } = getCompositeComponentFromElement(element);
    if (!parentCompositeFiber) return null;

    const componentRoot = findComponentDOMNode(parentCompositeFiber);
    if (componentRoot === element) {
      // Store the fiber reference in WeakMap
      fiberMap.set(element, parentCompositeFiber);
      return element;
    }
    return null;
  };

  let current: HTMLElement | null = element;
  while (current && current !== document.body) {
    const inspectable = findInspectableFiber(current);
    if (inspectable) {
      // Get fiber from WeakMap
      const fiber = fiberMap.get(inspectable);
      if (fiber) {
        result.unshift({
          element: inspectable,
          depth: 0,
          name: getDisplayName(fiber.type) ?? 'Unknown',
          fiber,
        });
      }
    }
    current = current.parentElement;
  }

  return result;
};

type DiffResult = {
  type: 'primitive' | 'reference' | 'object';
  changes: Array<{
    path: string[];
    prevValue: unknown;
    currentValue: unknown;
    sameFunction?: boolean;
  }>;
  hasDeepChanges: boolean;
};

type DiffChange = {
  path: string[];
  prevValue: unknown;
  currentValue: unknown;
  sameFunction?: boolean;
};

type InspectableValue =
  | Record<string, unknown>
  | Array<unknown>
  | Map<unknown, unknown>
  | Set<unknown>
  | ArrayBuffer
  | DataView
  | Int8Array
  | Uint8Array
  | Uint8ClampedArray
  | Int16Array
  | Uint16Array
  | Int32Array
  | Uint32Array
  | Float32Array
  | Float64Array
  | BigInt64Array
  | BigUint64Array;

export type AggregatedChanges = {
  count: number;
  // unstable: boolean;
  currentValue: unknown;
  previousValue: unknown;
  // displayName?:string
  name: string;
};

export const isExpandable = (value: unknown): value is InspectableValue => {
  if (value === null || typeof value !== 'object' || isPromise(value)) {
    return false;
  }

  if (value instanceof ArrayBuffer) {
    return true;
  }

  if (value instanceof DataView) {
    return true;
  }

  if (ArrayBuffer.isView(value)) {
    return true;
  }

  if (value instanceof Map || value instanceof Set) {
    return value.size > 0;
  }

  if (Array.isArray(value)) {
    return value.length > 0;
  }

  return Object.keys(value).length > 0;
};

export const isEditableValue = (
  value: unknown,
  parentPath?: string,
): boolean => {
  if (value == null) return true;

  if (isPromise(value)) return false;

  if (typeof value === 'function') {
    return false;
  }

  if (parentPath) {
    const parts = parentPath.split('.');
    let currentPath = '';
    for (const part of parts) {
      currentPath = currentPath ? `${currentPath}.${part}` : part;
      const obj = globalInspectorState.lastRendered.get(currentPath);
      if (
        obj instanceof DataView ||
        obj instanceof ArrayBuffer ||
        ArrayBuffer.isView(obj)
      ) {
        return false;
      }
    }
  }

  switch (value.constructor) {
    case Date:
    case RegExp:
    case Error:
      return true;
    default:
      switch (typeof value) {
        case 'string':
        case 'number':
        case 'boolean':
        case 'bigint':
          return true;
        default:
          return false;
      }
  }
};

export const getPath = (
  componentName: string,
  section: string,
  parentPath: string,
  key: string,
): string => {
  if (parentPath) {
    return `${componentName}.${parentPath}.${key}`;
  }

  if (section === 'context' && !key.startsWith('context.')) {
    return `${componentName}.${section}.context.${key}`;
  }

  return `${componentName}.${section}.${key}`;
};

export const sanitizeString = (value: string): string => {
  return value
    .replace(/[<>]/g, '')
    .replace(/javascript:/gi, '')
    .replace(/data:/gi, '')
    .replace(/on\w+=/gi, '')
    .slice(0, 50000);
};

export const sanitizeErrorMessage = (error: string): string => {
  return error
    .replace(/[<>]/g, '')
    .replace(/&/g, '&amp;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;')
    .replace(/\//g, '&#x2F;');
};

export const formatValue = (value: unknown): string => {
  const metadata = ensureRecord(value);
  return metadata.displayValue as string;
};

export const formatForClipboard = (value: unknown): string => {
  try {
    if (value === null) return 'null';
    if (value === undefined) return 'undefined';
    if (isPromise(value)) return 'Promise';

    if (typeof value === 'function') {
      const fnStr = value.toString();
      try {
        const formatted = fnStr
          .replace(/\s+/g, ' ') // Normalize whitespace
          .replace(/{\s+/g, '{\n  ') // Add newline after {
          .replace(/;\s+/g, ';\n  ') // Add newline after ;
          .replace(/}\s*$/g, '\n}') // Add newline before final }
          .replace(/\(\s+/g, '(') // Remove space after (
          .replace(/\s+\)/g, ')') // Remove space before )
          .replace(/,\s+/g, ', '); // Normalize comma spacing

        return formatted;
      } catch {
        return fnStr;
      }
    }

    switch (true) {
      case value instanceof Date:
        return value.toISOString();
      case value instanceof RegExp:
        return value.toString();
      case value instanceof Error:
        return `${value.name}: ${value.message}`;
      case value instanceof Map:
        return JSON.stringify(Array.from(value.entries()), null, 2);
      case value instanceof Set:
        return JSON.stringify(Array.from(value), null, 2);
      case value instanceof DataView:
        return JSON.stringify(
          Array.from(new Uint8Array(value.buffer)),
          null,
          2,
        );
      case value instanceof ArrayBuffer:
        return JSON.stringify(Array.from(new Uint8Array(value)), null, 2);
      case ArrayBuffer.isView(value) && 'length' in value:
        return JSON.stringify(
          Array.from(value as unknown as ArrayLike<number>),
          null,
          2,
        );
      case Array.isArray(value):
        return JSON.stringify(value, null, 2);
      case typeof value === 'object':
        return JSON.stringify(value, null, 2);
      default:
        return String(value);
    }
  } catch {
    return String(value);
  }
};

export const parseArrayValue = (value: string): Array<unknown> => {
  if (value.trim() === '[]') return [];

  const result: Array<unknown> = [];
  let current = '';
  let depth = 0;
  let inString = false;
  let escapeNext = false;

  for (let i = 0; i < value.length; i++) {
    const char = value[i];

    if (escapeNext) {
      current += char;
      escapeNext = false;
      continue;
    }

    if (char === '\\') {
      escapeNext = true;
    }

    if (char === '"') {
      inString = !inString;
      current += char;
      continue;
    }

    if (inString) {
      current += char;
      continue;
    }

    if (char === '[' || char === '{') {
      depth++;
      current += char;
      continue;
    }

    if (char === ']' || char === '}') {
      depth--;
      current += char;
      continue;
    }

    if (char === ',' && depth === 0) {
      if (current.trim()) {
        result.push(parseValue(current.trim(), ''));
      }
      current = '';
      continue;
    }

    current += char;
  }

  if (current.trim()) {
    result.push(parseValue(current.trim(), ''));
  }

  return result;
};

export const parseValue = (value: string, currentType: unknown): unknown => {
  try {
    switch (typeof currentType) {
      case 'number':
        return Number(value);
      case 'string':
        return value;
      case 'boolean':
        return value === 'true';
      case 'bigint':
        return BigInt(value);
      case 'undefined':
        return undefined;
      case 'object': {
        if (!currentType) {
          return null;
        }

        if (Array.isArray(currentType)) {
          return parseArrayValue(value.slice(1, -1));
        }

        if (currentType instanceof RegExp) {
          try {
            const match = /^\/(?<pattern>.*)\/(?<flags>[gimuy]*)$/.exec(value);
            if (match?.groups) {
              return new RegExp(match.groups.pattern, match.groups.flags);
            }
            return new RegExp(value);
          } catch {
            return currentType;
          }
        }

        if (currentType instanceof Map) {
          const entries = value
            .slice(1, -1)
            .split(', ')
            .map((entry) => {
              const [key, val] = entry.split(' => ');
              return [parseValue(key, ''), parseValue(val, '')] as [
                unknown,
                unknown,
              ];
            });
          return new Map(entries);
        }

        if (currentType instanceof Set) {
          const values = value
            .slice(1, -1)
            .split(', ')
            .map((v) => parseValue(v, ''));
          return new Set(values);
        }
        const entries = value
          .slice(1, -1)
          .split(', ')
          .map((entry) => {
            const [key, val] = entry.split(': ');
            return [key, parseValue(val, '')];
          });
        return Object.fromEntries(entries);
      }
    }

    return value;
  } catch {
    return currentType;
  }
};

export const detectValueType = (
  value: string,
): {
  type: 'string' | 'number' | 'undefined' | 'null' | 'boolean';
  value: unknown;
} => {
  const trimmed = value.trim();

  switch (trimmed) {
    case 'undefined':
      return { type: 'undefined', value: undefined };
    case 'null':
      return { type: 'null', value: null };
    case 'true':
      return { type: 'boolean', value: true };
    case 'false':
      return { type: 'boolean', value: false };
  }

  if (/^".*"$/.test(trimmed)) {
    return { type: 'string', value: trimmed.slice(1, -1) };
  }

  if (/^-?\d+(?:\.\d+)?$/.test(trimmed)) {
    return { type: 'number', value: Number(trimmed) };
  }

  return { type: 'string', value: `"${trimmed}"` };
};

export const formatInitialValue = (value: unknown): string => {
  if (value === undefined) return 'undefined';
  if (value === null) return 'null';
  if (typeof value === 'string') return `"${value}"`;
  return String(value);
};

export const updateNestedValue = (
  obj: unknown,
  path: Array<string>,
  value: unknown,
): unknown => {
  try {
    if (path.length === 0) return value;

    const [key, ...rest] = path;

    // Handle our special array of {name, value} pairs
    if (
      Array.isArray(obj) &&
      obj.every((item): item is StateItem => 'name' in item && 'value' in item)
    ) {
      const index = obj.findIndex((item) => item.name === key);
      if (index === -1) return obj;

      const newArray = [...obj];
      if (rest.length === 0) {
        newArray[index] = { ...newArray[index], value };
      } else {
        newArray[index] = {
          ...newArray[index],
          value: updateNestedValue(newArray[index].value, rest, value),
        };
      }
      return newArray;
    }

    if (obj instanceof Map) {
      const newMap = new Map(obj);
      if (rest.length === 0) {
        newMap.set(key, value);
      } else {
        const currentValue = newMap.get(key);
        newMap.set(key, updateNestedValue(currentValue, rest, value));
      }
      return newMap;
    }

    if (Array.isArray(obj)) {
      const index = Number.parseInt(key, 10);
      const newArray = [...obj];
      if (rest.length === 0) {
        newArray[index] = value;
      } else {
        newArray[index] = updateNestedValue(obj[index], rest, value);
      }
      return newArray;
    }

    if (obj && typeof obj === 'object') {
      if (rest.length === 0) {
        return { ...obj, [key]: value };
      }
      return {
        ...obj,
        [key]: updateNestedValue(
          (obj as Record<string, unknown>)[key],
          rest,
          value,
        ),
      };
    }

    return value;
  } catch {
    return obj;
  }
};

export const areFunctionsEqual = (prev: unknown, current: unknown): boolean => {
  try {
    // Check if both values are actually functions
    if (typeof prev !== 'function' || typeof current !== 'function') {
      return false;
    }

    // Now we know both are functions, we can safely call toString()
    return prev.toString() === current.toString();
  } catch {
    return false;
  }
};

export const getObjectDiff = (
  prev: unknown,
  current: unknown,
  path: string[] = [],
  seen = new WeakSet(),
): DiffResult => {
  if (prev === current) {
    return { type: 'primitive', changes: [], hasDeepChanges: false };
  }

  if (typeof prev === 'function' && typeof current === 'function') {
    const isSameFunction = areFunctionsEqual(prev, current);
    return {
      type: 'primitive',
      changes: [
        {
          path,
          prevValue: prev,
          currentValue: current,
          sameFunction: isSameFunction,
        },
      ],
      hasDeepChanges: !isSameFunction,
    };
  }

  if (
    prev === null ||
    current === null ||
    prev === undefined ||
    current === undefined ||
    typeof prev !== 'object' ||
    typeof current !== 'object'
  ) {
    return {
      type: 'primitive',
      changes: [{ path, prevValue: prev, currentValue: current }],
      hasDeepChanges: true,
    };
  }

  if (seen.has(prev) || seen.has(current)) {
    return {
      type: 'object',
      changes: [{ path, prevValue: '[Circular]', currentValue: '[Circular]' }],
      hasDeepChanges: false,
    };
  }

  seen.add(prev);
  seen.add(current);

  const prevObj = prev as Record<string, unknown>;
  const currentObj = current as Record<string, unknown>;
  const allKeys = new Set([
    ...Object.keys(prevObj),
    ...Object.keys(currentObj),
  ]);
  const changes: Array<DiffChange> = [];
  let hasDeepChanges = false;

  for (const key of allKeys) {
    const prevValue = prevObj[key];
    const currentValue = currentObj[key];

    if (prevValue !== currentValue) {
      if (
        typeof prevValue === 'object' &&
        typeof currentValue === 'object' &&
        prevValue !== null &&
        currentValue !== null
      ) {
        const nestedDiff = getObjectDiff(
          prevValue,
          currentValue,
          [...path, key],
          seen,
        );
        changes.push(...nestedDiff.changes);
        if (nestedDiff.hasDeepChanges) {
          hasDeepChanges = true;
        }
      } else {
        changes.push({
          path: [...path, key],
          prevValue,
          currentValue,
        });
        hasDeepChanges = true;
      }
    }
  }

  return {
    type: 'object',
    changes,
    hasDeepChanges,
  };
};

export const formatPath = (path: string[]): string => {
  if (path.length === 0) return '';

  return path.reduce((acc, segment, i) => {
    // Check if segment is a number (array index)
    if (/^\d+$/.test(segment)) {
      return `${acc}[${segment}]`;
    }
    // Add dot separator only if not first segment and previous segment wasn't an array index
    return i === 0 ? segment : `${acc}.${segment}`;
  }, '');
};

export const formatFunctionBody = (body: string): string => {
  // Remove newlines and extra spaces
  let formatted = body.replace(/\s+/g, ' ').trim();

  // Add newlines after {, ; and before }
  formatted = formatted
    .replace(/{/g, '{\n  ')
    .replace(/;/g, ';\n  ')
    .replace(/}/g, '\n}')
    .replace(/{\s+}/g, '{ }'); // Clean up empty blocks

  // Clean up arrow functions
  formatted = formatted.replace(/=> {\n/g, '=> {').replace(/\n\s*}\s*$/g, ' }');

  return formatted;
};

export function hackyJsFormatter(code: string) {
  //
  // 1) Collapse runs of whitespace to single spaces
  //
  const normalizedCode = code.replace(/\s+/g, ' ').trim();

  //
  // 2) Tokenize
  //    We'll separate out:
  //    - parentheses: ( )
  //    - braces: { }
  //    - brackets: [ ]
  //    - angle brackets: < >
  //    - semicolon: ;
  //    - comma: ,
  //    - arrow =>
  //    - colon :
  //    - question mark ?
  //    - exclamation mark ! (for TS non-null etc.)
  //
  //    We'll also try to combine () or [] or {} or <> if they appear empty.
  //
  const rawTokens = [];
  let current = '';
  for (let i = 0; i < normalizedCode.length; i++) {
    const c = normalizedCode[i];

    // Detect arrow =>
    if (c === '=' && normalizedCode[i + 1] === '>') {
      if (current.trim()) rawTokens.push(current.trim());
      rawTokens.push('=>');
      current = '';
      i++;
      continue;
    }

    // Single/double char punctuation
    if (/[(){}[\];,<>:\?!]/.test(c)) {
      // If we had something in current, push it
      if (current.trim()) {
        rawTokens.push(current.trim());
      }
      rawTokens.push(c);
      current = '';
    } else if (/\s/.test(c)) {
      // whitespace ends the current token
      if (current.trim()) {
        rawTokens.push(current.trim());
      }
      current = '';
    } else {
      current += c;
    }
  }
  if (current.trim()) {
    rawTokens.push(current.trim());
  }

  //
  // 3) Combine immediate pairs of empty brackets, e.g. '(' + ')' => '()'
  //    This helps keep arrow param empty parens on one line, etc.
  //
  const merged: Array<string> = [];
  for (let i = 0; i < rawTokens.length; i++) {
    const t = rawTokens[i];
    const n = rawTokens[i + 1];
    if (
      (t === '(' && n === ')') ||
      (t === '[' && n === ']') ||
      (t === '{' && n === '}') ||
      (t === '<' && n === '>')
    ) {
      merged.push(t + n); // '()', '[]', '{}', '<>'
      i++;
    } else {
      merged.push(t);
    }
  }

  //
  // 4) We want to detect arrow param lists:
  //    i.e. "(" ... ")" immediately followed by "=>"
  //    so we can keep them on one line.
  //
  //    Also, detect generic param lists:
  //    i.e. identifier "<" ... ">" (then maybe "(" ) for function calls or type declarations
  //
  //    We'll store indexes in sets: arrowParamSet, genericSet
  //
  const arrowParamSet = new Set(); // indexes inside arrow param lists
  const genericSet = new Set(); // indexes inside generics <...>

  function findMatchingPair(
    openTok: string,
    closeTok: string,
    startIndex: number,
  ) {
    // e.g. openTok = '(', closeTok = ')'
    let depth = 0;
    for (let j = startIndex; j < merged.length; j++) {
      const token = merged[j];
      if (token === openTok) depth++;
      else if (token === closeTok) {
        depth--;
        if (depth === 0) return j;
      }
    }
    return -1;
  }

  // Detect arrow param sets
  for (let i = 0; i < merged.length; i++) {
    const t = merged[i];
    if (t === '(') {
      const closeIndex = findMatchingPair('(', ')', i);
      if (closeIndex !== -1 && merged[closeIndex + 1] === '=>') {
        // Mark all tokens from i..closeIndex as arrow param
        for (let k = i; k <= closeIndex; k++) {
          arrowParamSet.add(k);
        }
      }
    }
  }

  // Detect generics, e.g. foo<...> or MyType<...>
  // We do a naive approach: if we see something that looks like an identifier
  // followed immediately by '<', we assume it's a generic.
  for (let i = 1; i < merged.length; i++) {
    const prev = merged[i - 1];
    const t = merged[i];
    // If prev is an identifier and t is '<', find matching '>'
    if (/^[a-zA-Z0-9_$]+$/.test(prev) && t === '<') {
      const closeIndex = findMatchingPair('<', '>', i);
      if (closeIndex !== -1) {
        // Mark i..closeIndex as generic
        for (let k = i; k <= closeIndex; k++) {
          genericSet.add(k);
        }
      }
    }
  }

  //
  // 5) Build lines with indentation. We maintain a stack for open brackets.
  //
  let indentLevel = 0;
  const indentStr = '  '; // 2 spaces
  const lines: Array<string> = [];
  let line = '';

  function pushLine() {
    if (line.trim()) {
      lines.push(line.replace(/\s+$/, ''));
    }
    line = '';
  }
  function newLine() {
    pushLine();
    line = indentStr.repeat(indentLevel);
  }

  const stack: Array<string> = [];
  function stackTop() {
    return stack.length ? stack[stack.length - 1] : null;
  }

  function placeToken(tok: string, noSpaceBefore = false) {
    if (!line.trim()) {
      // line is empty aside from indentation
      line += tok;
    } else {
      if (noSpaceBefore || /^[),;:\].}>]$/.test(tok)) {
        line += tok;
      } else {
        line += ` ${tok}`;
      }
    }
  }

  for (let i = 0; i < merged.length; i++) {
    const tok = merged[i];
    const next = merged[i + 1] || '';

    // Open brackets
    if (['(', '{', '[', '<'].includes(tok)) {
      placeToken(tok);
      stack.push(tok);

      // If '{', definitely newline + indent
      if (tok === '{') {
        indentLevel++;
        newLine();
      } else if (tok === '(' || tok === '[' || tok === '<') {
        // If we are in arrowParamSet or genericSet, keep it on one line
        if (
          (arrowParamSet.has(i) && tok === '(') ||
          (genericSet.has(i) && tok === '<')
        ) {
          // Don't break lines after commas etc.
          // We won't do multiline logic for these.
        } else {
          // If next is not a direct close, go multiline
          const directClose = {
            '(': ')',
            '[': ']',
            '<': '>',
          }[tok];
          if (
            next !== directClose &&
            next !== '()' &&
            next !== '[]' &&
            next !== '<>'
          ) {
            indentLevel++;
            newLine();
          }
        }
      }
    }

    // Close brackets
    else if ([')', '}', ']', '>'].includes(tok)) {
      // pop stack
      const opening = stackTop();
      if (
        (tok === ')' && opening === '(') ||
        (tok === ']' && opening === '[') ||
        (tok === '>' && opening === '<')
      ) {
        // if not arrowParamSet or genericSet, multiline
        if (
          !(arrowParamSet.has(i) && tok === ')') &&
          !(genericSet.has(i) && tok === '>')
        ) {
          indentLevel = Math.max(indentLevel - 1, 0);
          newLine();
        }
      } else if (tok === '}' && opening === '{') {
        indentLevel = Math.max(indentLevel - 1, 0);
        newLine();
      }
      stack.pop();
      placeToken(tok);
      if (tok === '}') {
        // break line after }
        newLine();
      }
    }

    // Combined empty pairs like '()', '[]', '{}', '<>'
    else if (/^\(\)|\[\]|\{\}|\<\>$/.test(tok)) {
      placeToken(tok);

      // Arrow =>
    } else if (tok === '=>') {
      placeToken(tok);
      // We'll let the next token (maybe '{') handle line breaks.

      // Semicolon
    } else if (tok === ';') {
      placeToken(tok, true);
      newLine();

      // Comma
    } else if (tok === ',') {
      placeToken(tok, true);
      // If inside an arrow param set or generic set, don't break
      // Otherwise, if top is {, (, [ or <, break line
      const top = stackTop();
      if (
        !(arrowParamSet.has(i) && top === '(') &&
        !(genericSet.has(i) && top === '<')
      ) {
        if (top && ['{', '[', '(', '<'].includes(top)) {
          newLine();
        }
      }

      // Everything else (identifiers, operators, colons, question marks, etc.)
    } else {
      placeToken(tok);
    }
  }

  pushLine();

  // Remove extra blank lines
  return lines
    .join('\n')
    .replace(/\n\s*\n+/g, '\n')
    .trim();
}

// Update the formatFunctionPreview to use the new formatter
export const formatFunctionPreview = (
  fn: { toString(): string },
  expanded = false,
): string => {
  try {
    const fnStr = fn.toString();
    const match = fnStr.match(
      /(?:function\s*)?(?:\(([^)]*)\)|([^=>\s]+))\s*=>?/,
    );
    if (!match) return 'ƒ';

    const params = match[1] || match[2] || '';
    const cleanParams = params.replace(/\s+/g, '');

    if (!expanded) {
      return `ƒ (${cleanParams}) => ...`;
    }

    // For expanded view, use the new formatter
    return hackyJsFormatter(fnStr);
  } catch {
    return 'ƒ';
  }
};

export const formatValuePreview = (value: unknown): string => {
  if (value === null) return 'null';
  if (value === undefined) return 'undefined';
  if (typeof value === 'string')
    return `"${value.length > 150 ? `${value.slice(0, 20)}...` : value}"`;
  if (typeof value === 'number' || typeof value === 'boolean')
    return String(value);
  if (typeof value === 'function') return formatFunctionPreview(value);
  if (Array.isArray(value)) return `Array(${value.length})`;
  if (value instanceof Map) return `Map(${value.size})`;
  if (value instanceof Set) return `Set(${value.size})`;
  if (value instanceof Date) return value.toISOString();
  if (value instanceof RegExp) return value.toString();
  if (value instanceof Error) return `${value.name}: ${value.message}`;
  if (typeof value === 'object') {
    const keys = Object.keys(value as object);
    return `{${keys.length > 2 ? `${keys.slice(0, 2).join(', ')}, ...` : keys.join(', ')}}`;
  }
  return String(value);
};

export const safeGetValue = (
  value: unknown,
): { value: unknown; error?: string } => {
  if (value === null || value === undefined) return { value };
  if (typeof value === 'function') return { value };
  if (typeof value !== 'object') return { value };

  if (value instanceof Promise) {
    // Handle promises without accessing them
    return { value: 'Promise' };
  }

  try {
    // Handle potential proxy traps or getter errors
    const proto = Object.getPrototypeOf(value);
    if (proto === Promise.prototype || proto?.constructor?.name === 'Promise') {
      return { value: 'Promise' };
    }

    return { value };
  } catch {
    return { value: null, error: 'Error accessing value' };
  }
};

export interface TimelineSliderValues {
  leftValue: number;
  min: number;
  max: number;
  value: number;
  rightValue: number;
}

export const calculateSliderValues = (
  totalUpdates: number,
  currentIndex: number,
): TimelineSliderValues => {
  if (totalUpdates <= TIMELINE_MAX_UPDATES) {
    return {
      leftValue: 0,
      min: 0,
      max: totalUpdates - 1,
      value: currentIndex,
      rightValue: totalUpdates - 1,
    };
  }

  return {
    leftValue: totalUpdates - TIMELINE_MAX_UPDATES,
    min: 0,
    max: TIMELINE_MAX_UPDATES - 1,
    value: currentIndex,
    rightValue: totalUpdates - 1,
  };
};

// be careful, this is an implementation detail is not stable or reliable across all react versions https://github.com/facebook/react/pull/15124
// type UpdateQueue<S, A> = {
//   last: Update<S, A> | null,
//   dispatch: (A => mixed) | null,
//   eagerReducer: ((S, A) => S) | null,
//   eagerState: S | null,
// };

interface ExtendedMemoizedState extends MemoizedState {
  queue?: {
    lastRenderedState: unknown;
  } | null;
  element?: unknown;
}

export const isDirectComponent = (fiber: Fiber): boolean => {
  if (!fiber || !fiber.type) return false;

  const isFunctionalComponent = typeof fiber.type === 'function';
  const isClassComponent = fiber.type?.prototype?.isReactComponent ?? false;

  if (!(isFunctionalComponent || isClassComponent)) return false;

  if (isClassComponent) {
    return true;
  }

  let memoizedState = fiber.memoizedState;
  while (memoizedState) {
    if (memoizedState.queue) {
      return true;
    }
    const nextState: ExtendedMemoizedState | null = memoizedState.next;
    if (!nextState) break;
    memoizedState = nextState;
  }

  return false;
};

export const isPromise = (value: unknown): value is Promise<unknown> => {
  return (
    !!value &&
    (value instanceof Promise || (typeof value === 'object' && 'then' in value))
  );
};

export const ensureRecord = (
  value: unknown,
  maxDepth = 2,
  seen = new WeakSet<object>(),
): Record<string, unknown> => {
  if (isPromise(value)) {
    return { type: 'promise', displayValue: 'Promise' };
  }

  if (value === null) {
    return { type: 'null', displayValue: 'null' };
  }

  if (value === undefined) {
    return { type: 'undefined', displayValue: 'undefined' };
  }

  switch (typeof value) {
    case 'object': {
      if (seen.has(value)) {
        return { type: 'circular', displayValue: '[Circular Reference]' };
      }

      if (!value) return { type: 'null', displayValue: 'null' };

      seen.add(value);

      try {
        const result: Record<string, unknown> = {};

        if (value instanceof Element) {
          result.type = 'Element';
          result.tagName = value.tagName.toLowerCase();
          result.displayValue = value.tagName.toLowerCase();
          return result;
        }

        if (value instanceof Map) {
          result.type = 'Map';
          result.size = value.size;
          result.displayValue = `Map(${value.size})`;

          if (maxDepth > 0) {
            const entries: Record<string, unknown> = {};
            let index = 0;
            for (const [key, val] of value.entries()) {
              if (index >= 50) break;
              try {
                entries[String(key)] = ensureRecord(val, maxDepth - 1, seen);
              } catch {
                entries[String(index)] = {
                  type: 'error',
                  displayValue: 'Error accessing Map entry',
                };
              }
              index++;
            }
            result.entries = entries;
          }
          return result;
        }

        if (value instanceof Set) {
          result.type = 'Set';
          result.size = value.size;
          result.displayValue = `Set(${value.size})`;

          if (maxDepth > 0) {
            const items = [];
            let count = 0;
            for (const item of value) {
              if (count >= 50) break;
              items.push(ensureRecord(item, maxDepth - 1, seen));
              count++;
            }
            result.items = items;
          }
          return result;
        }

        if (value instanceof Date) {
          result.type = 'Date';
          result.value = value.toISOString();
          result.displayValue = value.toLocaleString();
          return result;
        }

        if (value instanceof RegExp) {
          result.type = 'RegExp';
          result.value = value.toString();
          result.displayValue = value.toString();
          return result;
        }

        if (value instanceof Error) {
          result.type = 'Error';
          result.name = value.name;
          result.message = value.message;
          result.displayValue = `${value.name}: ${value.message}`;
          return result;
        }

        if (value instanceof ArrayBuffer) {
          result.type = 'ArrayBuffer';
          result.byteLength = value.byteLength;
          result.displayValue = `ArrayBuffer(${value.byteLength})`;
          return result;
        }

        if (value instanceof DataView) {
          result.type = 'DataView';
          result.byteLength = value.byteLength;
          result.displayValue = `DataView(${value.byteLength})`;
          return result;
        }

        if (ArrayBuffer.isView(value)) {
          const typedArray = value as unknown as {
            length: number;
            constructor: { name: string };
            buffer: ArrayBuffer;
          };
          result.type = typedArray.constructor.name;
          result.length = typedArray.length;
          result.byteLength = typedArray.buffer.byteLength;
          result.displayValue = `${typedArray.constructor.name}(${typedArray.length})`;
          return result;
        }

        if (Array.isArray(value)) {
          result.type = 'array';
          result.length = value.length;
          result.displayValue = `Array(${value.length})`;

          if (maxDepth > 0) {
            result.items = value
              .slice(0, 50)
              .map((item) => ensureRecord(item, maxDepth - 1, seen));
          }
          return result;
        }

        const keys = Object.keys(value);
        result.type = 'object';
        result.size = keys.length;
        result.displayValue =
          keys.length <= 5
            ? `{${keys.join(', ')}}`
            : `{${keys.slice(0, 5).join(', ')}, ...${keys.length - 5}}`;

        if (maxDepth > 0) {
          const entries: Record<string, unknown> = {};
          for (const key of keys.slice(0, 50)) {
            try {
              entries[key] = ensureRecord(
                (value as Record<string, unknown>)[key],
                maxDepth - 1,
                seen,
              );
            } catch {
              entries[key] = {
                type: 'error',
                displayValue: 'Error accessing property',
              };
            }
          }
          result.entries = entries;
        }
        return result;
      } finally {
        seen.delete(value);
      }
    }
    case 'string':
      return {
        type: 'string',
        value,
        displayValue: `"${value}"`,
      };
    case 'function':
      return {
        type: 'function',
        displayValue: 'ƒ()',
        name: value.name || 'anonymous',
      };
    default:
      return {
        type: typeof value,
        value,
        displayValue: String(value),
      };
  }
};

export const getCurrentFiberState = (
  fiber: Fiber,
): Record<string, unknown> | null => {
  if (fiber.tag !== FunctionComponentTag || !isDirectComponent(fiber)) {
    return null;
  }

  const currentIsNewer = fiber.alternate
    ? (fiber.actualStartTime ?? 0) > (fiber.alternate.actualStartTime ?? 0)
    : true;

  const memoizedState: ExtendedMemoizedState | null = currentIsNewer
    ? fiber.memoizedState
    : (fiber.alternate?.memoizedState ?? fiber.memoizedState);

  if (!memoizedState) return null;

  return memoizedState;
};

export const replayComponent = async (fiber: Fiber): Promise<void> => {
  const { overrideProps, overrideHookState, overrideContext } =
    getOverrideMethods();
  if (!overrideProps || !overrideHookState || !fiber) return;

  try {
    // Handle props updates
    const currentProps = fiber.memoizedProps || {};
    const propKeys = Object.keys(currentProps).filter((key) => {
      const value = currentProps[key];
      if (Array.isArray(value) || typeof value === 'string') {
        return !Number.isInteger(Number(key)) && key !== 'length';
      }
      return true;
    });

    for (const key of propKeys) {
      try {
        const value = currentProps[key];
        // For arrays and objects, we need to clone to trigger updates
        const propValue = Array.isArray(value)
          ? [...value]
          : typeof value === 'object' && value !== null
            ? { ...value }
            : value;
        overrideProps(fiber, [key], propValue);
      } catch {}
    }

    // Handle state updates
    const currentState = getCurrentFiberState(fiber);
    if (currentState) {
      const stateNames = getStateNames(fiber);

      // First, handle named state hooks
      for (const [key, value] of Object.entries(currentState)) {
        try {
          const namedStateIndex = stateNames.indexOf(key);
          if (namedStateIndex !== -1) {
            const hookId = namedStateIndex.toString();
            // For arrays and objects, we need to clone to trigger updates
            const stateValue = Array.isArray(value)
              ? [...value]
              : typeof value === 'object' && value !== null
                ? { ...value }
                : value;
            overrideHookState(fiber, hookId, [], stateValue);
          }
        } catch {}
      }

      // Then handle unnamed state hooks
      let hookIndex = 0;
      let currentHook = fiber.memoizedState;
      while (currentHook !== null) {
        try {
          const hookId = hookIndex.toString();
          const value = currentHook.memoizedState;

          // Only update if this hook isn't already handled by named states
          if (!stateNames.includes(hookId)) {
            // For arrays and objects, we need to clone to trigger updates
            const stateValue = Array.isArray(value)
              ? [...value]
              : typeof value === 'object' && value !== null
                ? { ...value }
                : value;
            overrideHookState(fiber, hookId, [], stateValue);
          }
        } catch {}

        currentHook = currentHook.next as typeof currentHook;
        hookIndex++;
      }
    }

    // Handle context updates
    if (overrideContext) {
      const contexts = getAllFiberContexts(fiber);
      if (contexts) {
        for (const [contextType, ctx] of contexts) {
          try {
            // Find the provider fiber for this context
            let current: Fiber | null = fiber;
            while (current) {
              const type = current.type as { Provider?: unknown };
              if (type === contextType || type?.Provider === contextType) {
                // Get the value we want to update to
                const newValue = ctx.value;
                if (newValue === undefined || newValue === null) break;

                // Only update if the value has actually changed
                const currentValue = current.memoizedProps?.value;
                if (isEqual(currentValue, newValue)) break;

                // Update the provider's value prop
                overrideProps(current, ['value'], newValue);
                if (current.alternate) {
                  overrideProps(current.alternate, ['value'], newValue);
                }
                break;
              }
              current = current.return;
            }
          } catch {}
        }
      }
    }

    // Recursively handle children
    let child = fiber.child;
    while (child) {
      await replayComponent(child);
      child = child.sibling;
    }
  } catch {}
};

export const extractMinimalFiberInfo = (fiber: Fiber): MinimalFiberInfo => {
  const timings = getTimings(fiber);
  return {
    displayName: getDisplayName(fiber) || 'Unknown',
    type: fiber.type,
    key: fiber.key,
    id: fiber.index,
    selfTime: timings?.selfTime ?? null,
    totalTime: timings?.totalTime ?? null,
  };
};
</file>

<file path="packages/scan/src/web/widget/helpers.ts">
import { MIN_SIZE, SAFE_AREA } from '../constants';
import type { Corner, Position, ResizeHandleProps, Size } from './types';

class WindowDimensions {
  maxWidth: number;
  maxHeight: number;

  constructor(
    public width: number,
    public height: number,
  ) {
    this.maxWidth = width - SAFE_AREA * 2;
    this.maxHeight = height - SAFE_AREA * 2;
  }

  rightEdge(width: number): number {
    return this.width - width - SAFE_AREA;
  }

  bottomEdge(height: number): number {
    return this.height - height - SAFE_AREA;
  }

  isFullWidth(width: number): boolean {
    return width >= this.maxWidth;
  }

  isFullHeight(height: number): boolean {
    return height >= this.maxHeight;
  }
}

let cachedWindowDimensions: WindowDimensions | undefined;

export const getWindowDimensions = () => {
  const currentWidth = window.innerWidth;
  const currentHeight = window.innerHeight;

  if (
    cachedWindowDimensions &&
    cachedWindowDimensions.width === currentWidth &&
    cachedWindowDimensions.height === currentHeight
  ) {
    return cachedWindowDimensions;
  }

  cachedWindowDimensions = new WindowDimensions(currentWidth, currentHeight);

  return cachedWindowDimensions;
};

export const getOppositeCorner = (
  position: ResizeHandleProps['position'],
  currentCorner: Corner,
  isFullScreen: boolean,
  isFullWidth?: boolean,
  isFullHeight?: boolean,
): Corner => {
  // For full screen mode
  if (isFullScreen) {
    if (position === 'top-left') return 'bottom-right';
    if (position === 'top-right') return 'bottom-left';
    if (position === 'bottom-left') return 'top-right';
    if (position === 'bottom-right') return 'top-left';

    const [vertical, horizontal] = currentCorner.split('-');
    if (position === 'left') return `${vertical}-right` as Corner;
    if (position === 'right') return `${vertical}-left` as Corner;
    if (position === 'top') return `bottom-${horizontal}` as Corner;
    if (position === 'bottom') return `top-${horizontal}` as Corner;
  }

  // For full width mode
  if (isFullWidth) {
    if (position === 'left')
      return `${currentCorner.split('-')[0]}-right` as Corner;
    if (position === 'right')
      return `${currentCorner.split('-')[0]}-left` as Corner;
  }

  // For full height mode
  if (isFullHeight) {
    if (position === 'top')
      return `bottom-${currentCorner.split('-')[1]}` as Corner;
    if (position === 'bottom')
      return `top-${currentCorner.split('-')[1]}` as Corner;
  }

  return currentCorner;
};

export const calculatePosition = (
  corner: Corner,
  width: number,
  height: number,
): Position => {
  const windowWidth = window.innerWidth;
  const windowHeight = window.innerHeight;

  // Check if widget is minimized
  const isMinimized = width === MIN_SIZE.width;

  // Only bound dimensions if minimized
  const effectiveWidth = isMinimized
    ? width
    : Math.min(width, windowWidth - SAFE_AREA * 2);
  const effectiveHeight = isMinimized
    ? height
    : Math.min(height, windowHeight - SAFE_AREA * 2);

  // Calculate base positions
  let x: number;
  let y: number;

  switch (corner) {
    case 'top-right':
      x = windowWidth - effectiveWidth - SAFE_AREA;
      y = SAFE_AREA;
      break;
    case 'bottom-right':
      x = windowWidth - effectiveWidth - SAFE_AREA;
      y = windowHeight - effectiveHeight - SAFE_AREA;
      break;
    case 'bottom-left':
      x = SAFE_AREA;
      y = windowHeight - effectiveHeight - SAFE_AREA;
      break;
    case 'top-left':
      x = SAFE_AREA;
      y = SAFE_AREA;
      break;
    default:
      x = SAFE_AREA;
      y = SAFE_AREA;
      break;
  }

  // Only ensure positions are within bounds if minimized
  if (isMinimized) {
    x = Math.max(
      SAFE_AREA,
      Math.min(x, windowWidth - effectiveWidth - SAFE_AREA),
    );
    y = Math.max(
      SAFE_AREA,
      Math.min(y, windowHeight - effectiveHeight - SAFE_AREA),
    );
  }

  return { x, y };
};

const positionMatchesCorner = (
  position: ResizeHandleProps['position'],
  corner: Corner,
): boolean => {
  const [vertical, horizontal] = corner.split('-');
  return position !== vertical && position !== horizontal;
};

export const getHandleVisibility = (
  position: ResizeHandleProps['position'],
  corner: Corner,
  isFullWidth: boolean,
  isFullHeight: boolean,
): boolean => {
  if (isFullWidth && isFullHeight) {
    return true;
  }

  // Normal state
  if (!isFullWidth && !isFullHeight) {
    return positionMatchesCorner(position, corner);
  }

  // Full width state
  if (isFullWidth) {
    return position !== corner.split('-')[0];
  }

  // Full height state
  if (isFullHeight) {
    return position !== corner.split('-')[1];
  }

  return false;
};

export const calculateBoundedSize = (
  currentSize: number,
  delta: number,
  isWidth: boolean,
): number => {
  const min = isWidth ? MIN_SIZE.width : MIN_SIZE.initialHeight;
  const max = isWidth
    ? getWindowDimensions().maxWidth
    : getWindowDimensions().maxHeight;

  const newSize = currentSize + delta;
  return Math.min(Math.max(min, newSize), max);
};

export const calculateNewSizeAndPosition = (
  position: ResizeHandleProps['position'],
  initialSize: Size,
  initialPosition: Position,
  deltaX: number,
  deltaY: number,
): { newSize: Size; newPosition: Position } => {
  const maxWidth = window.innerWidth - SAFE_AREA * 2;
  const maxHeight = window.innerHeight - SAFE_AREA * 2;

  let newWidth = initialSize.width;
  let newHeight = initialSize.height;
  let newX = initialPosition.x;
  let newY = initialPosition.y;

  // horizontal resize
  if (position.includes('right')) {
    // Check if we have enough space on the right
    const availableWidth = window.innerWidth - initialPosition.x - SAFE_AREA;
    const proposedWidth = Math.min(initialSize.width + deltaX, availableWidth);
    newWidth = Math.min(maxWidth, Math.max(MIN_SIZE.width, proposedWidth));
  }
  if (position.includes('left')) {
    // Check if we have enough space on the left
    const availableWidth = initialPosition.x + initialSize.width - SAFE_AREA;
    const proposedWidth = Math.min(initialSize.width - deltaX, availableWidth);
    newWidth = Math.min(maxWidth, Math.max(MIN_SIZE.width, proposedWidth));
    newX = initialPosition.x - (newWidth - initialSize.width);
  }

  // vertical resize
  if (position.includes('bottom')) {
    // Check if we have enough space at the bottom
    const availableHeight = window.innerHeight - initialPosition.y - SAFE_AREA;
    const proposedHeight = Math.min(
      initialSize.height + deltaY,
      availableHeight,
    );
    newHeight = Math.min(
      maxHeight,
      Math.max(MIN_SIZE.initialHeight, proposedHeight),
    );
  }
  if (position.includes('top')) {
    // Check if we have enough space at the top
    const availableHeight = initialPosition.y + initialSize.height - SAFE_AREA;
    const proposedHeight = Math.min(
      initialSize.height - deltaY,
      availableHeight,
    );
    newHeight = Math.min(
      maxHeight,
      Math.max(MIN_SIZE.initialHeight, proposedHeight),
    );
    newY = initialPosition.y - (newHeight - initialSize.height);
  }

  // Ensure position stays within bounds
  newX = Math.max(
    SAFE_AREA,
    Math.min(newX, window.innerWidth - SAFE_AREA - newWidth),
  );
  newY = Math.max(
    SAFE_AREA,
    Math.min(newY, window.innerHeight - SAFE_AREA - newHeight),
  );

  return {
    newSize: { width: newWidth, height: newHeight },
    newPosition: { x: newX, y: newY },
  };
};

export const getClosestCorner = (position: Position): Corner => {
  const windowDims = getWindowDimensions();

  const distances: Record<Corner, number> = {
    'top-left': Math.hypot(position.x, position.y),
    'top-right': Math.hypot(windowDims.maxWidth - position.x, position.y),
    'bottom-left': Math.hypot(position.x, windowDims.maxHeight - position.y),
    'bottom-right': Math.hypot(
      windowDims.maxWidth - position.x,
      windowDims.maxHeight - position.y,
    ),
  };

  let closest: Corner = 'top-left';

  for (const key in distances) {
    if (distances[key as Corner] < distances[closest]) {
      closest = key as Corner;
    }
  }

  return closest;
};

// Helper to determine best corner based on cursor position, widget size, and movement
export const getBestCorner = (
  mouseX: number,
  mouseY: number,
  initialMouseX?: number,
  initialMouseY?: number,
  threshold = 100,
): Corner => {
  const deltaX = initialMouseX !== undefined ? mouseX - initialMouseX : 0;
  const deltaY = initialMouseY !== undefined ? mouseY - initialMouseY : 0;

  const windowCenterX = window.innerWidth / 2;
  const windowCenterY = window.innerHeight / 2;

  // Determine movement direction
  const movingRight = deltaX > threshold;
  const movingLeft = deltaX < -threshold;
  const movingDown = deltaY > threshold;
  const movingUp = deltaY < -threshold;

  // If horizontal movement
  if (movingRight || movingLeft) {
    const isBottom = mouseY > windowCenterY;
    return movingRight
      ? isBottom
        ? 'bottom-right'
        : 'top-right'
      : isBottom
        ? 'bottom-left'
        : 'top-left';
  }

  // If vertical movement
  if (movingDown || movingUp) {
    const isRight = mouseX > windowCenterX;
    return movingDown
      ? isRight
        ? 'bottom-right'
        : 'bottom-left'
      : isRight
        ? 'top-right'
        : 'top-left';
  }

  // If no significant movement, use quadrant-based position
  return mouseX > windowCenterX
    ? mouseY > windowCenterY
      ? 'bottom-right'
      : 'top-right'
    : mouseY > windowCenterY
      ? 'bottom-left'
      : 'top-left';
};
</file>

<file path="packages/scan/src/web/widget/types.ts">
export interface Position {
  x: number;
  y: number;
}

export interface Size {
  width: number;
  height: number;
}

export type Corner = 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';

export interface ResizeHandleProps {
  position: Corner | 'top' | 'bottom' | 'left' | 'right';
}

export interface WidgetDimensions {
  isFullWidth: boolean;
  isFullHeight: boolean;
  width: number;
  height: number;
  position: Position;
}

export interface ComponentsTreeConfig {
  width: number;
}

export interface WidgetConfig {
  corner: Corner;
  dimensions: WidgetDimensions;
  lastDimensions: WidgetDimensions;
  componentsTree: ComponentsTreeConfig;
}

export interface WidgetSettings {
  corner: Corner;
  dimensions: WidgetDimensions;
  lastDimensions: WidgetDimensions;
  componentsTree: ComponentsTreeConfig;
}
</file>

<file path="packages/scan/src/auto.ts">
// Prioritize bippy side-effect
import 'bippy';

import { IS_CLIENT } from '~web/utils/constants';
import { scan } from './index';

if (IS_CLIENT) {
  scan();
  window.reactScan = scan;
}

export * from './core';
</file>

<file path="packages/scan/src/index.ts">
// Bippy has a side-effect that installs the hook.
import 'bippy';

export * from './core/index';
</file>

<file path="packages/scan/src/install-hook.ts">
export { getRDTHook as init } from 'bippy';
</file>

<file path="packages/scan/src/new-outlines/canvas.ts">
import type { ActiveOutline, OutlineData } from './types';

export const OUTLINE_ARRAY_SIZE = 7;
const MONO_FONT =
  'Menlo,Consolas,Monaco,Liberation Mono,Lucida Console,monospace';

const INTERPOLATION_SPEED = 0.1;
const lerp = (start: number, end: number) => {
  return Math.floor(start + (end - start) * INTERPOLATION_SPEED);
};

const MAX_PARTS_LENGTH = 4;
const MAX_LABEL_LENGTH = 40;
const TOTAL_FRAMES = 45;

const PRIMARY_COLOR = '115,97,230';
// const SECONDARY_COLOR = '128,128,128';

function sortEntry(prev: [number, string[]], next: [number, string[]]): number {
  return next[0] - prev[0];
}

function getSortedEntries(
  countByNames: Map<number, string[]>,
): [number, string[]][] {
  const entries = [...countByNames.entries()];
  return entries.sort(sortEntry);
}

function getLabelTextPart([count, names]: [number, string[]]): string {
  let part = `${names.slice(0, MAX_PARTS_LENGTH).join(', ')} ×${count}`;
  if (part.length > MAX_LABEL_LENGTH) {
    part = `${part.slice(0, MAX_LABEL_LENGTH)}…`;
  }
  return part;
}

export const getLabelText = (outlines: ActiveOutline[]): string => {
  const nameByCount = new Map<string, number>();
  for (const { name, count } of outlines) {
    nameByCount.set(name, (nameByCount.get(name) || 0) + count);
  }

  const countByNames = new Map<number, string[]>();
  for (const [name, count] of nameByCount) {
    const names = countByNames.get(count);
    if (names) {
      names.push(name);
    } else {
      countByNames.set(count, [name]);
    }
  }

  // TODO(Alexis): Optimize
  const partsEntries = getSortedEntries(countByNames);
  let labelText = getLabelTextPart(partsEntries[0]);
  for (let i = 1, len = partsEntries.length; i < len; i++) {
    labelText += ', ' + getLabelTextPart(partsEntries[i]);
  }

  if (labelText.length > MAX_LABEL_LENGTH) {
    return `${labelText.slice(0, MAX_LABEL_LENGTH)}…`;
  }

  return labelText;
};

export const getAreaFromOutlines = (outlines: ActiveOutline[]) => {
  let area = 0;
  for (const outline of outlines) {
    area += outline.width * outline.height;
  }
  return area;
};

export const updateOutlines = (
  activeOutlines: Map<string, ActiveOutline>,
  outlines: OutlineData[],
) => {
  for (const { id, name, count, x, y, width, height, didCommit } of outlines) {
    const outline: ActiveOutline = {
      id,
      name,
      count,
      x,
      y,
      width,
      height,
      frame: 0,
      targetX: x,
      targetY: y,
      targetWidth: width,
      targetHeight: height,
      didCommit,
    };
    const key = String(outline.id);

    const existingOutline = activeOutlines.get(key);
    if (existingOutline) {
      existingOutline.count++;
      existingOutline.frame = 0;
      existingOutline.targetX = x;
      existingOutline.targetY = y;
      existingOutline.targetWidth = width;
      existingOutline.targetHeight = height;
      existingOutline.didCommit = didCommit;
    } else {
      activeOutlines.set(key, outline);
    }
  }
};

export const updateScroll = (
  activeOutlines: Map<string, ActiveOutline>,
  deltaX: number,
  deltaY: number,
) => {
  for (const outline of activeOutlines.values()) {
    const newX = outline.x - deltaX;
    const newY = outline.y - deltaY;
    outline.targetX = newX;
    outline.targetY = newY;
  }
};

export const initCanvas = (
  canvas: HTMLCanvasElement | OffscreenCanvas,
  dpr: number,
) => {
  const ctx = canvas.getContext('2d', { alpha: true }) as
    | CanvasRenderingContext2D
    | OffscreenCanvasRenderingContext2D;
  if (ctx) {
    ctx.scale(dpr, dpr);
  }
  return ctx;
};

export const drawCanvas = (
  ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,
  canvas: HTMLCanvasElement | OffscreenCanvas,
  dpr: number,
  activeOutlines: Map<string, ActiveOutline>,
) => {
  ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);

  return activeOutlines.size > 0;

  const groupedOutlinesMap = new Map<string, ActiveOutline[]>();
  const rectMap = new Map<
    string,
    {
      x: number;
      y: number;
      width: number;
      height: number;
      alpha: number;
    }
  >();

  for (const outline of activeOutlines.values()) {
    const {
      x,
      y,
      width,
      height,
      targetX,
      targetY,
      targetWidth,
      targetHeight,
      frame,
    } = outline;
    if (targetX !== x) {
      outline.x = lerp(x, targetX);
    }
    if (targetY !== y) {
      outline.y = lerp(y, targetY);
    }

    if (targetWidth !== width) {
      outline.width = lerp(width, targetWidth);
    }
    if (targetHeight !== height) {
      outline.height = lerp(height, targetHeight);
    }

    const labelKey = `${targetX ?? x},${targetY ?? y}`;
    const rectKey = `${labelKey},${targetWidth ?? width},${targetHeight ?? height}`;

    const outlines = groupedOutlinesMap.get(labelKey);
    if (outlines) {
      outlines.push(outline);
    } else {
      groupedOutlinesMap.set(labelKey, [outline]);
    }

    const alpha = 1 - frame / TOTAL_FRAMES;
    outline.frame++;

    const rect = rectMap.get(rectKey) || {
      x,
      y,
      width,
      height,
      alpha,
    };
    if (alpha > rect.alpha) {
      rect.alpha = alpha;
    }
    rectMap.set(rectKey, rect);
  }

  for (const { x, y, width, height, alpha } of rectMap.values()) {
    ctx.strokeStyle = `rgba(${PRIMARY_COLOR},${alpha})`;
    ctx.lineWidth = 1;

    ctx.beginPath();
    ctx.rect(x, y, width, height);
    ctx.stroke();
    ctx.fillStyle = `rgba(${PRIMARY_COLOR},${alpha * 0.1})`;
    ctx.fill();
  }

  ctx.font = `11px ${MONO_FONT}`;

  const labelMap = new Map<
    string,
    {
      text: string;
      width: number;
      height: number;
      alpha: number;
      x: number;
      y: number;
      outlines: ActiveOutline[];
    }
  >();

  ctx.textRendering = 'optimizeSpeed';

  // TODO(Alexis): optimizable?
  for (const outlines of groupedOutlinesMap.values()) {
    const first = outlines[0];
    const { x, y, frame } = first;
    const alpha = 1 - frame / TOTAL_FRAMES;
    const text = getLabelText(outlines);
    const { width } = ctx.measureText(text);
    const height = 11;
    labelMap.set(`${x},${y},${width},${text}`, {
      text,
      width,
      height,
      alpha,
      x,
      y,
      outlines,
    });

    let labelY: number = y - height - 4;

    if (labelY < 0) {
      labelY = 0;
    }

    if (frame > TOTAL_FRAMES) {
      for (const outline of outlines) {
        activeOutlines.delete(String(outline.id));
      }
    }
  }

  // TODO(Alexis): optimize
  const sortedLabels = Array.from(labelMap.entries()).sort(
    ([_, a], [__, b]) => {
      return getAreaFromOutlines(b.outlines) - getAreaFromOutlines(a.outlines);
    },
  );

  for (const [labelKey, label] of sortedLabels) {
    if (!labelMap.has(labelKey)) continue;

    for (const [otherKey, otherLabel] of labelMap.entries()) {
      if (labelKey === otherKey) continue;

      const { x, y, width, height } = label;
      const {
        x: otherX,
        y: otherY,
        width: otherWidth,
        height: otherHeight,
      } = otherLabel;

      if (
        x + width > otherX &&
        otherX + otherWidth > x &&
        y + height > otherY &&
        otherY + otherHeight > y
      ) {
        label.text = getLabelText(label.outlines.concat(otherLabel.outlines));
        label.width = ctx.measureText(label.text).width;
        labelMap.delete(otherKey);
      }
    }
  }

  for (const label of labelMap.values()) {
    const { x, y, alpha, width, height, text } = label;

    let labelY = y - height - 4;

    if (labelY < 0) {
      labelY = 0;
    }

    ctx.fillStyle = `rgba(${PRIMARY_COLOR},${alpha})`;
    ctx.fillRect(x, labelY, width + 4, height + 4);

    ctx.fillStyle = `rgba(255,255,255,${alpha})`;
    ctx.fillText(text, x + 2, labelY + height);
  }

  return activeOutlines.size > 0;
};
</file>

<file path="packages/scan/src/web/utils/outline.ts">
// THIS FILE WILL BE DELETED

import type { Fiber } from 'bippy';
import { type OutlineKey } from '~core/index';
import type { AggregatedChange } from '~core/instrumentation';

export interface OutlineLabel {
  alpha: number;
  color: { r: number; g: number; b: number };
  reasons: number; // based on Reason enum
  labelText: string;
  textWidth: number;
  activeOutline: Outline;
}

// using intersection observer lets us get the boundingClientRect asynchronously without forcing a reflow.
// The browser can internally optimize the bounding rect query, so this will be faster then meticulously
// Batching getBoundingClientRect at the right time in the browser rendering pipeline.
// batchGetBoundingRects function can return in sub <10ms under good conditions, but may take much longer under poor conditions.
// We interpolate the outline rects to avoid the appearance of jitter
// reference: https://w3c.github.io/IntersectionObserver/
/**
 *
 * @deprecated use getBatchedRectMap
 */
export const batchGetBoundingRects = (
  elements: Array<Element>,
): Promise<Map<Element, DOMRect>> => {
  return new Promise((resolve) => {
    const results = new Map<Element, DOMRect>();
    const observer = new IntersectionObserver((entries) => {
      for (const entry of entries) {
        const element = entry.target;
        const bounds = entry.boundingClientRect;
        results.set(element, bounds);
      }
      observer.disconnect();
      resolve(results);
    });

    for (const element of elements) {
      observer.observe(element);
    }
  });
};

type ComponentName = string;

export interface Outline {
  domNode: Element;
  /** Aggregated render info */ // TODO: Flatten AggregatedRender into Outline to avoid re-creating objects
  // this render is useless when in active outlines (confirm this rob)
  aggregatedRender: AggregatedRender; // maybe we should set this to null when its useless

  /* Active Info- we re-use the Outline object to avoid over-allocing objects, which is why we have a singular aggregatedRender and collection of it (groupedAggregatedRender) */
  alpha: number | null;
  totalFrames: number | null;
  /*
    - Invariant: This scales at a rate of O(unique components rendered at the same (x,y) coordinates)
    - renders with the same x/y position but different fibers will be a different fiber -> aggregated render entry.
  */
  groupedAggregatedRender: Map<Fiber, AggregatedRender> | null;

  /* Rects for interpolation */
  current: DOMRect | null;
  target: DOMRect | null;
  /* This value is computed before the full rendered text is shown, so its only considered an estimate */
  estimatedTextWidth: number | null; // todo: estimated is stupid just make it the actual
}

export enum RenderPhase {
  Mount = 0b001,
  Update = 0b010,
  Unmount = 0b100,
}

export const RENDER_PHASE_STRING_TO_ENUM = {
  mount: RenderPhase.Mount,
  update: RenderPhase.Update,
  unmount: RenderPhase.Unmount,
} as const;

export interface AggregatedRender {
  name: ComponentName;
  frame: number | null;
  phase: number; // union of RenderPhase
  time: number | null;
  aggregatedCount: number;
  forget: boolean;
  changes: AggregatedChange;
  unnecessary: boolean | null;
  didCommit: boolean;
  fps: number;

  computedKey: OutlineKey | null;
  computedCurrent: DOMRect | null; // reference to dom rect to copy over to new outline made at new position
}
</file>

<file path="packages/scan/src/web/utils/pin.ts">
import type { Fiber } from 'bippy';
import { Store } from '~core/index';
import { findComponentDOMNode } from '~web/views/inspector/utils';
import { readLocalStorage } from './helpers';

export interface FiberMetadata {
  componentName: string;
  parent: string;
  position: number;
  sibling: string | null;
  path: string;
  propKeys: string[];
}

const metadata = readLocalStorage<FiberMetadata>('react-scann-pinned');

export const getFiberPath = (fiber: Fiber): string => {
  const pathSegments: string[] = [];
  let currentFiber: Fiber | null = fiber;

  while (currentFiber) {
    const elementType = currentFiber.elementType;
    const name =
      typeof elementType === 'function'
        ? elementType.displayName || elementType.name
        : typeof elementType === 'string'
          ? elementType
          : 'Unknown';

    const index =
      currentFiber.index !== undefined ? `[${currentFiber.index}]` : '';
    pathSegments.unshift(`${name}${index}`);

    currentFiber = currentFiber.return ?? null;
  }

  return pathSegments.join('::');
};

export const getFiberMetadata = (fiber: Fiber): FiberMetadata | null => {
  if (!fiber || !fiber.elementType) return null;

  const componentName = fiber.elementType.name || 'UnknownComponent';
  const position = fiber.index !== undefined ? fiber.index : -1;
  const sibling = fiber.sibling?.elementType?.name || null;

  let parentFiber = fiber.return;
  let parent = 'Root';

  while (parentFiber) {
    const parentName = parentFiber.elementType?.name;

    if (typeof parentName === 'string' && parentName.trim().length > 0) {
      parent = parentName;
      break;
    }

    parentFiber = parentFiber.return;
  }

  const path = getFiberPath(fiber);

  const propKeys = fiber.pendingProps
    ? Object.keys(fiber.pendingProps).filter((key) => key !== 'children')
    : [];

  return { componentName, parent, position, sibling, path, propKeys };
};

const checkFiberMatch = (fiber: Fiber | undefined): boolean => {
  if (!fiber || !fiber.elementType || !metadata?.componentName) return false;

  if (fiber.elementType.name !== metadata.componentName) return false;

  let currentParentFiber = fiber.return;
  let parent = '';

  while (currentParentFiber) {
    if (currentParentFiber.elementType?.name) {
      parent = currentParentFiber.elementType.name;
      break;
    }
    currentParentFiber = currentParentFiber.return;
  }

  if (parent !== metadata.parent) return false;
  if (fiber.index !== metadata.position) return false;

  const fiberPath = getFiberPath(fiber);
  return fiberPath === metadata.path;
};

const fiberQueue: Fiber[] = [];
let isProcessing = false;

const processFiberQueue = (): void => {
  if (isProcessing || fiberQueue.length === 0) return;
  isProcessing = true;

  requestIdleCallback(() => {
    while (fiberQueue.length > 0) {
      const fiber = fiberQueue.shift();
      if (fiber && checkFiberMatch(fiber)) {
        // biome-ignore lint/suspicious/noConsole: Intended debug output
        console.log('🎯 Pinned component found!', fiber);
        isProcessing = false;

        const componentElement = findComponentDOMNode(fiber);

        if (!componentElement) return;

        Store.inspectState.value = {
          kind: 'focused',
          focusedDomElement: componentElement,
          fiber,
        };
        return;
      }
    }
    isProcessing = false;
  });
};

export const enqueueFiber = (fiber: Fiber) => {
  if (metadata === null || metadata.componentName !== fiber.elementType?.name) {
    return;
  }

  fiberQueue.push(fiber);
  if (!isProcessing) processFiberQueue();
};
</file>

<file path="packages/scan/src/web/constants.ts">
export const SAFE_AREA = 24;
export const MIN_SIZE = {
  width: 550,
  height: 350,
  initialHeight: 400,
} as const;

export const MIN_CONTAINER_WIDTH = 240;

export const LOCALSTORAGE_KEY = 'react-scan-widget-settings-v2';
</file>

<file path="packages/scan/tsup.config.ts">
import * as fs from 'node:fs';
import fsPromise from 'node:fs/promises';
import path from 'node:path';
import { TsconfigPathsPlugin } from '@esbuild-plugins/tsconfig-paths';
import { init, parse } from 'es-module-lexer';
import { defineConfig } from 'tsup';
import { workerPlugin } from './worker-plugin';

const DIST_PATH = './dist';

const addDirectivesToChunkFiles = async (readPath: string): Promise<void> => {
  try {
    const files = await fsPromise.readdir(readPath);
    for (const file of files) {
      if (file.endsWith('.mjs') || file.endsWith('.js')) {
        const filePath = path.join(readPath, file);
        const data = await fsPromise.readFile(filePath, 'utf8');
        const updatedContent = `'use client';\n${data}`;
        await fsPromise.writeFile(filePath, updatedContent, 'utf8');
      }
    }
  } catch (err) {
    // biome-ignore lint/suspicious/noConsole: Intended debug output
    console.error('Error:', err);
  }
};

const banner = `/**
 * Copyright 2025 Aiden Bai, Million Software, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
 * and associated documentation files (the “Software”), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
 * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */`;

void (async () => {
  await init;

  if (fs.existsSync(DIST_PATH)) {
    fs.rmSync(DIST_PATH, { recursive: true });
  }
  fs.mkdirSync(DIST_PATH, { recursive: true });

  const code = fs.readFileSync('./src/core/index.ts', 'utf8');
  const [_, allExports] = parse(code);
  const names: Array<string> = [];
  for (const exportItem of allExports) {
    names.push(exportItem.n);
  }

  const createFn = (name: string) =>
    `export let ${name}=()=>{console.error('Do not use ${name} directly in a Server Component module. It should only be used in a Client Component.');return undefined}`;
  const createVar = (name: string) => `export let ${name}=undefined`;

  let script = '';
  for (const name of names) {
    if (name[0].toLowerCase() === name[0]) {
      script += `${createFn(name)}\n`;
      continue;
    }
    script += `${createVar(name)}\n`;
  }

  setTimeout(() => {
    for (const ext of ['js', 'mjs', 'global.js']) {
      fs.writeFileSync(`./dist/rsc-shim.${ext}`, script);
    }
  }, 500);
})();

export default defineConfig([
  {
    entry: ['./src/auto.ts', './src/install-hook.ts'],
    outDir: DIST_PATH,
    banner: {
      js: banner,
    },
    splitting: false,
    clean: false,
    sourcemap: false,
    format: ['iife'],
    target: 'esnext',
    platform: 'browser',
    treeshake: true,
    dts: true,
    minify: process.env.NODE_ENV === 'production' ? 'terser' : false,
    env: {
      NODE_ENV: process.env.NODE_ENV ?? 'development',
    },
    external: [
      'react',
      'react-dom',
      'next',
      'next/navigation',
      'react-router',
      'react-router-dom',
      '@remix-run/react',
    ],
    esbuildPlugins: [workerPlugin],
    loader: {
      '.css': 'text',
      '.worker.js': 'text',
    },
  },
  {
    entry: [
      './src/index.ts',
      './src/install-hook.ts',
      './src/core/monitor/index.ts',
      './src/core/monitor/params/next.ts',
      './src/core/monitor/params/react-router-v5.ts',
      './src/core/monitor/params/react-router-v6.ts',
      './src/core/monitor/params/remix.ts',
      './src/core/monitor/params/astro/component.ts',
    ],
    banner: {
      js: banner,
    },
    outDir: DIST_PATH,
    splitting: false,
    clean: false,
    sourcemap: false,
    format: ['cjs', 'esm'],
    target: 'esnext',
    platform: 'browser',
    // FIXME: tree shaking removes use client directive
    // Info: vercel analytics does the same thing- https://github.com/vercel/analytics/blob/main/packages/web/tsup.config.js
    treeshake: false,
    dts: true,
    watch: process.env.NODE_ENV === 'development',
    async onSuccess() {
      await Promise.all([
        addDirectivesToChunkFiles(DIST_PATH),
        addDirectivesToChunkFiles(`${DIST_PATH}/core/monitor/params`),
        addDirectivesToChunkFiles(`${DIST_PATH}/core/monitor`),
      ]);
    },
    minify: false,
    env: {
      NODE_ENV: process.env.NODE_ENV ?? 'development',
      NPM_PACKAGE_VERSION: JSON.parse(
        fs.readFileSync(
          path.join(__dirname, '../scan', 'package.json'),
          'utf8',
        ),
      ).version,
    },
    external: [
      'react',
      'react-dom',
      'next',
      'next/navigation',
      'react-router',
      'react-router-dom',
      '@remix-run/react',
      'preact',
      '@preact/signals',
    ],
    loader: {
      '.css': 'text',
    },
    esbuildPlugins: [
      workerPlugin,
      TsconfigPathsPlugin({
        tsconfig: path.resolve(__dirname, './tsconfig.json'),
      }),
    ],
  },
  {
    entry: ['./src/cli.mts'],
    outDir: DIST_PATH,
    banner: {
      js: banner,
    },
    splitting: false,
    clean: false,
    sourcemap: false,
    format: ['cjs'],
    target: 'esnext',
    platform: 'node',
    minify: false,
    env: {
      NODE_ENV: process.env.NODE_ENV ?? 'development',
    },
    watch: process.env.NODE_ENV === 'development',
  },
  {
    entry: [
      './src/react-component-name/index.ts',
      './src/react-component-name/vite.ts',
      './src/react-component-name/webpack.ts',
      './src/react-component-name/esbuild.ts',
      './src/react-component-name/rspack.ts',
      './src/react-component-name/rolldown.ts',
      './src/react-component-name/rollup.ts',
      './src/react-component-name/astro.ts',
    ],
    outDir: `${DIST_PATH}/react-component-name`,
    splitting: false,
    sourcemap: false,
    clean: false,
    format: ['cjs', 'esm'],
    target: 'esnext',
    external: [
      'unplugin',
      'estree-walker',
      '@rollup/pluginutils',
      '@babel/types',
      '@babel/parser',
      '@babel/traverse',
      '@babel/generator',
      '@babel/core',
      'rollup',
      'webpack',
      'esbuild',
      'rspack',
      'vite',
    ],
    dts: true,
    minify: false,
    treeshake: true,
    env: {
      NODE_ENV: process.env.NODE_ENV || 'development',
    },
    outExtension: ({ format }) => ({
      js: format === 'esm' ? '.mjs' : '.js',
    }),
    esbuildOptions: (options, context) => {
      options.mainFields = ['module', 'main'];
      options.conditions = ['import', 'require', 'node', 'default'];
      options.format = context.format === 'esm' ? 'esm' : 'cjs';
      options.preserveSymlinks = true;
    },
  },
]);
</file>

<file path="packages/scan/src/core/monitor/utils.ts">
import { IS_CLIENT } from '~web/utils/constants';
import { onIdle } from '~web/utils/helpers';
import { isSSR } from './constants';
import { Device, type Session } from './types';

interface NetworkInformation {
  connection?: {
    effectiveType?: string;
  };
}

interface ExtendedNavigator extends Navigator {
  deviceMemory?: number;
}

const MOBILE_PATTERN =
  /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i;

const TABLET_PATTERN = /iPad|Tablet/i;

const getDeviceType = () => {
  const userAgent = navigator.userAgent;

  if (MOBILE_PATTERN.test(userAgent)) {
    return Device.MOBILE;
  }
  if (TABLET_PATTERN.test(userAgent)) {
    return Device.TABLET;
  }
  return Device.DESKTOP;
};

/**
 * Measure layout time
 */
export const doubleRAF = (callback: (...args: unknown[]) => void) => {
  return requestAnimationFrame(requestAnimationFrame.bind(window, callback));
};

export const generateId = () => {
  const alphabet =
    'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
  let id = '';
  const randomValues = crypto.getRandomValues(new Uint8Array(21));
  for (let i = 0; i < 21; i++) {
    id += alphabet[63 & randomValues[i]];
  }
  return id;
};

/**
 * @see https://deviceandbrowserinfo.com/learning_zone/articles/webgl_renderer_values
 */
const getGpuRenderer = () => {
  if (!('chrome' in window)) return ''; // Prevent WEBGL_debug_renderer_info deprecation warnings in firefox
  const gl = document
    .createElement('canvas')

    // Get the specs for the fastest GPU available. This helps provide a better
    // picture of the device's capabilities.
    .getContext('webgl', { powerPreference: 'high-performance' });
  if (!gl) return '';
  const ext = gl.getExtension('WEBGL_debug_renderer_info');
  return ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : '';
};

/**
 * Session is a loose way to fingerprint / identify a session.
 *
 * Modified from @palette.dev/browser:
 * @see https://gist.github.com/aidenybai/473689493f2d5d01bbc52e2da5950b45#file-palette-dev-browser-dist-palette-dev-mjs-L554
 * DO NOT CALL THIS EVERYTIME
 */
let cachedSession: Session;
export const getSession = async ({
  commit = null,
  branch = null,
}: {
  commit?: string | null;
  branch?: string | null;
}) => {
  if (isSSR()) return null;
  if (cachedSession) {
    return cachedSession;
  }
  const id = generateId();
  const url = window.location.toString();
  /**
   * WiFi connection strength
   *
   * Potential outputs: slow-2g, 2g, 3g, 4g
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/effectiveType
   */
  const connection = (navigator as NetworkInformation).connection;
  const wifi = connection?.effectiveType ?? null;
  /**
   * Number of CPU threads
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/hardwareConcurrency
   */
  const cpu = navigator.hardwareConcurrency;
  /**
   * Device memory (GiB)
   *
   * Potential outputs: 0.25, 0.5, 1, 2, 4, 8
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/deviceMemory
   */
  const mem = (navigator as ExtendedNavigator).deviceMemory ?? 0;

  const gpuRendererPromise = new Promise<string | null>((resolve) => {
    onIdle(() => {
      resolve(getGpuRenderer());
    });
  });

  const session = {
    id,
    url,
    route: null,
    device: getDeviceType(),
    wifi: wifi ?? '',
    cpu,
    mem,
    gpu: await gpuRendererPromise,
    agent: navigator.userAgent,
    commit,
    branch,
    version: process.env.NPM_PACKAGE_VERSION,
  };
  cachedSession = session;
  return session;
};

export const not_globally_unique_generateId = () => {
  if (!IS_CLIENT) {
    return '0';
  }

  // @ts-expect-error
  if (window.reactScanIdCounter === undefined) {
    // @ts-expect-error
    window.reactScanIdCounter = 0;
  }
  // @ts-expect-error
  return `${++window.reactScanIdCounter}`;
};
</file>

<file path="packages/scan/src/core/notifications/interaction-store.ts">
import { BoundedArray } from "~core/notifications/performance-utils";
import { CompletedInteraction } from "./performance";

type Subscriber<T> = (data: T) => void;

export class Store<T> {
  private subscribers: Set<Subscriber<T>> = new Set();
  private currentValue: T;

  constructor(initialValue: T) {
    this.currentValue = initialValue;
  }

  subscribe(subscriber: Subscriber<T>): () => void {
    this.subscribers.add(subscriber);

    subscriber(this.currentValue);

    return () => {
      this.subscribers.delete(subscriber);
    };
  }

  setState(data: T) {
    this.currentValue = data;
    this.subscribers.forEach((subscriber) => subscriber(data));
  }

  getCurrentState(): T {
    return this.currentValue;
  }
}
export const MAX_INTERACTION_BATCH = 150;
export const interactionStore = new Store<BoundedArray<CompletedInteraction>>(
  new BoundedArray(MAX_INTERACTION_BATCH)
);
</file>

<file path="packages/scan/src/core/notifications/performance-store.ts">
import { BoundedArray } from "./performance-utils";
import { PerformanceEntryChannelEvent } from "./performance";

type UnSubscribe = () => void;
type Callback<T> = (item: T) => void;
type Updater<T> = (state: BoundedArray<T>) => BoundedArray<T>;
type ChanelName = string;

type PerformanceEntryChannelsType<T> = {
  subscribe: (to: ChanelName, cb: Callback<T>) => UnSubscribe;
  publish: (
    item: T,
    to: ChanelName,
    dropFirst: boolean,
    createIfNoChannel: boolean
  ) => void;
  channels: Record<
    ChanelName,
    { callbacks: BoundedArray<Callback<T>>; state: BoundedArray<T> }
  >;
  getAvailableChannels: () => BoundedArray<string>;
  updateChannelState: (
    channel: ChanelName,
    updater: Updater<T>,
    createIfNoChannel: boolean
  ) => void;
};

export const MAX_CHANNEL_SIZE = 50;
// a set of entities communicate to each other through channels
// the state in the channel is persisted until the receiving end consumes it
// multiple subscribes to the same channel will likely lead to unintended behavior if the subscribers are separate entities
class PerformanceEntryChannels<T> implements PerformanceEntryChannelsType<T> {
  channels: PerformanceEntryChannelsType<T>["channels"] = {};
  publish(item: T, to: ChanelName, createIfNoChannel = true) {
    const existingChannel = this.channels[to];
    if (!existingChannel) {
      if (!createIfNoChannel) {
        return;
      }
      this.channels[to] = {
        callbacks: new BoundedArray<Callback<T>>(MAX_CHANNEL_SIZE),
        state: new BoundedArray<T>(MAX_CHANNEL_SIZE),
      };
      this.channels[to].state.push(item);
      return;
    }

    existingChannel.state.push(item);
    existingChannel.callbacks.forEach((cb) => cb(item));
  }

  getAvailableChannels() {
    return BoundedArray.fromArray(Object.keys(this.channels), MAX_CHANNEL_SIZE);
  }
  subscribe(to: ChanelName, cb: Callback<T>, dropFirst: boolean = false) {
    const defer = () => {
      if (!dropFirst) {
        this.channels[to].state.forEach((item) => {
          cb(item);
        });
      }
      return () => {
        const filtered = this.channels[to].callbacks.filter(
          (subscribed) => subscribed !== cb
        );
        this.channels[to].callbacks = BoundedArray.fromArray(
          filtered,
          MAX_CHANNEL_SIZE
        );
      };
    };
    const existing = this.channels[to];
    if (!existing) {
      this.channels[to] = {
        callbacks: new BoundedArray<Callback<T>>(MAX_CHANNEL_SIZE),
        state: new BoundedArray<T>(MAX_CHANNEL_SIZE),
      };
      this.channels[to].callbacks.push(cb);
      return defer();
    }

    existing.callbacks.push(cb);
    return defer();
  }
  updateChannelState(
    channel: ChanelName,
    updater: Updater<T>,
    createIfNoChannel = true
  ) {
    const existingChannel = this.channels[channel];
    if (!existingChannel) {
      if (!createIfNoChannel) {
        return;
      }

      const state = new BoundedArray<T>(MAX_CHANNEL_SIZE);
      const newChannel = {
        callbacks: new BoundedArray<Callback<T>>(MAX_CHANNEL_SIZE),
        state,
      };

      this.channels[channel] = newChannel;
      newChannel.state = updater(state);
      return;
    }

    existingChannel.state = updater(existingChannel.state);
  }

  getChannelState(channel: ChanelName) {
    return (
      this.channels[channel].state ?? new BoundedArray<T>(MAX_CHANNEL_SIZE)
    );
  }
}
// todo: discriminated union the events when we start using multiple channels
// we used to use multiple channels, but now we only use 1. This is still a useful abstraction incase we ever need more channels again
export const performanceEntryChannels =
  new PerformanceEntryChannels<PerformanceEntryChannelEvent>();
</file>

<file path="packages/scan/src/core/notifications/performance-utils.ts">
import { Fiber } from 'bippy';
export const getChildrenFromFiberLL = (fiber: Fiber) => {
  const children: Array<Fiber> = [];

  let curr: typeof fiber.child = fiber.child;

  while (curr) {
    children.push(curr);

    curr = curr.sibling;
  }

  return children;
};

type Node = Map<
  Fiber,
  {
    children: Array<Fiber>;
    parent: Fiber | null;
    isRoot: boolean;
    isSVG: boolean;
  }
>;

export const createChildrenAdjacencyList = (root: Fiber, limit: number) => {
  const tree: Node = new Map([]);

  const queue: Array<[node: Fiber, parent: Fiber | null]> = [];
  const visited = new Set<Fiber>();

  queue.push([root, root.return]);
  let traversed = 1;

  while (queue.length) {
    if (traversed >= limit) {
      return tree;
    }
    // biome-ignore lint/style/noNonNullAssertion: invariant
    const [node, parent] = queue.pop()!;
    const children = getChildrenFromFiberLL(node);

    tree.set(node, {
      children: [],
      parent,
      isRoot: node === root,
      isSVG: node.type === 'svg',
    });

    for (const child of children) {
      traversed += 1;
      // this isn't needed since the fiber tree is a TREE, not a graph, but it makes me feel safer
      if (visited.has(child)) {
        continue;
      }
      visited.add(child);
      tree.get(node)?.children.push(child);
      queue.push([child, node]);
    }
  }
  return tree;
};

const isProduction: boolean = process.env.NODE_ENV === 'production';
const prefix: string = 'Invariant failed';

// FIX ME THIS IS PRODUCTION INVARIANT LOL
export function devInvariant(
  condition: unknown,
  message?: string | (() => string),
): asserts condition {
  if (condition) {
    return;
  }

  if (isProduction) {
    throw new Error(prefix);
  }

  const provided: string | undefined =
    typeof message === 'function' ? message() : message;

  const value: string = provided ? `${prefix}: ${provided}` : prefix;
  throw new Error(value);
}

const THROW_INVARIANTS = false;

export const invariantError = (message: string | undefined) => {
  if (THROW_INVARIANTS) {
    throw new Error(message);
  }
};

export const iife = <T>(fn: () => T): T => fn();

export class BoundedArray<T> extends Array<T> {
  constructor(private capacity: number = 25) {
    super();
  }

  push(...items: T[]): number {
    const result = super.push(...items);
    while (this.length > this.capacity) {
      this.shift();
    }
    return result;
  }
  // do not couple capacity with a default param, it must be explicit
  static fromArray<T>(array: Array<T>, capacity: number) {
    const arr = new BoundedArray<T>(capacity);
    arr.push(...array);
    return arr;
  }
}
</file>

<file path="packages/scan/src/web/views/inspector/components-tree/state.ts">
import { signal } from '@preact/signals';
import type { Fiber } from 'bippy';
import type { RenderData } from '~core/instrumentation';

export interface TreeNode {
  label: string;
  title?: string;
  fiber: Fiber;
  element?: HTMLElement;
  children?: TreeNode[];
  renderData?: RenderData;
}

export interface FlattenedNode extends TreeNode {
  depth: number;
  nodeId: string;
  parentId: string | null;
  fiber: Fiber;
}

export const searchState = signal<{
  query: string;
  matches: FlattenedNode[];
  currentMatchIndex: number;
}>({
  query: '',
  matches: [],
  currentMatchIndex: -1,
});

export interface TreeItem {
  name: string;
  depth: number;
  element: HTMLElement;
  fiber: Fiber;
}

export const signalSkipTreeUpdate = /* @__PURE__ */ signal(false);
</file>

<file path="packages/scan/src/core/monitor/index.ts">
'use client';
import {
  type Fiber,
  getDisplayName,
  getTimings,
  isCompositeFiber,
} from 'bippy';
import { type FC, useEffect } from 'react';
import { IS_CLIENT } from '~web/utils/constants';
import {
  type MonitoringOptions,
  ReactScanInternals,
  Store,
  setOptions,
} from '..';
import { type Render, createInstrumentation } from '../instrumentation';
import { updateFiberRenderData } from '../utils';
import { flush } from './network';
import { computeRoute } from './params/utils';
import { initPerformanceMonitoring } from './performance';
import { getSession } from './utils';

// max retries before the set of components do not get reported (avoid memory leaks of the set of fibers stored on the component aggregation)
const MAX_RETRIES_BEFORE_COMPONENT_GC = 7;

export interface MonitoringProps {
  url?: string;
  apiKey: string;

  // For Session and Interaction
  path?: string | null; // pathname (i.e /foo/2/bar/3)
  route?: string | null; // computed from path and params (i.e /foo/:fooId/bar/:barId)

  // Only used / should be provided to compute the route when using Monitoring without supported framework
  params?: Record<string, string>;

  // Tracking regressions across commits and branches
  commit?: string | null;
  branch?: string | null;
}

export type MonitoringWithoutRouteProps = Omit<
  MonitoringProps,
  'route' | 'path'
>;

const DEFAULT_URL = 'https://monitoring.react-scan.com/api/v1/ingest';

function noopCatch() {
  return null;
}

export const Monitoring: FC<MonitoringProps> = ({
  url,
  apiKey,
  params,
  path = null, // path passed down would be reactive
  route = null,
  commit = null,
  branch = null,
}) => {
  if (!apiKey)
    throw new Error('Please provide a valid API key for React Scan monitoring');
  url ??= DEFAULT_URL;

  Store.monitor.value ??= {
    pendingRequests: 0,
    interactions: [],
    session: getSession({ commit, branch }).catch(noopCatch),
    url,
    apiKey,
    route,
    commit,
    branch,
  };

  // When using Monitoring without framework, we need to compute the route from the path and params
  if (!route && path && params) {
    Store.monitor.value.route = computeRoute(path, params);
  } else if (IS_CLIENT) {
    Store.monitor.value.route =
      route ?? path ?? new URL(window.location.toString()).pathname; // this is inaccurate on vanilla react if the path is not provided but used for session route
  }

  useEffect(() => {
    scanMonitoring({ enabled: true });
    return initPerformanceMonitoring();
  }, []);

  return null;
};

export const scanMonitoring = (options: MonitoringOptions) => {
  setOptions(options);
  startMonitoring();
};

let flushInterval: ReturnType<typeof setInterval>;

export const startMonitoring = (): void => {
  if (!Store.monitor.value) {
    if (process.env.NODE_ENV !== 'production') {
      throw new Error(
        'Invariant: startMonitoring can never be called when monitoring is not initialized',
      );
    }
  }

  if (flushInterval) {
    clearInterval(flushInterval);
  }

  flushInterval = setInterval(() => {
    try {
      void flush();
    } catch {
      /* */
    }
  }, 2000);

  if (!window.__REACT_SCAN_EXTENSION__) {
    globalThis.__REACT_SCAN__ = {
      ReactScanInternals,
    };
  }

  const instrumentation = createInstrumentation('monitoring', {
    onCommitStart() {
      // ReactScanInternals.options.value.onCommitStart?.();
    },
    onError() {
      // todo: report to server?
    },
    isValidFiber() {
      return true;
    },
    onRender(fiber, renders) {
      updateFiberRenderData(fiber, renders);

      if (isCompositeFiber(fiber)) {
        aggregateComponentRenderToInteraction(fiber, renders);
      }
      // ReactScanInternals.options.value.onRender?.(fiber, renders);
    },
    onCommitFinish() {
      // ReactScanInternals.options.value.onCommitFinish?.();
    },
    onPostCommitFiberRoot() {
      // ...
    },
    trackChanges: false,
    forceAlwaysTrackRenders: true,
  });

  ReactScanInternals.instrumentation = instrumentation;
};

const aggregateComponentRenderToInteraction = (
  fiber: Fiber,
  renders: Array<Render>,
): void => {
  const monitor = Store.monitor.value;
  if (!monitor || !monitor.interactions || monitor.interactions.length === 0)
    return;
  const lastInteraction = monitor.interactions.at(-1); // Associate component render with last interaction
  if (!lastInteraction) return;

  const displayName = getDisplayName(fiber.type);
  if (!displayName) return; // TODO(nisarg): it may be useful to somehow report the first ancestor with a display name instead of completely ignoring

  let component = lastInteraction.components.get(displayName); // TODO(nisarg): Same names are grouped together which is wrong.

  if (!component) {
    component = {
      fibers: new Set(),
      name: displayName,
      renders: 0,
      retiresAllowed: MAX_RETRIES_BEFORE_COMPONENT_GC,
      uniqueInteractionId: lastInteraction.uniqueInteractionId,
    };
    lastInteraction.components.set(displayName, component);
  }

  if (fiber.alternate && !component.fibers.has(fiber.alternate)) {
    // then the alternate tree fiber exists in the weakset, don't double count the instance
    component.fibers.add(fiber.alternate);
  }

  const rendersCount = renders.length;
  component.renders += rendersCount;

  // We leave the times undefined to differentiate between a 0ms render and a non-profiled render.
  if (fiber.actualDuration) {
    const { selfTime, totalTime } = getTimings(fiber);
    if (!component.totalTime) component.totalTime = 0;
    if (!component.selfTime) component.selfTime = 0;
    component.totalTime += totalTime;
    component.selfTime += selfTime;
  }
};
</file>

<file path="packages/scan/src/core/monitor/performance.ts">
import { type Fiber, getDisplayName } from 'bippy';
import { getCompositeComponentFromElement } from '~web/views/inspector/utils';
import { Store } from '..';
import type {
  PerformanceInteraction,
  PerformanceInteractionEntry,
} from './types';

interface PathFilters {
  skipProviders: boolean;
  skipHocs: boolean;
  skipContainers: boolean;
  skipMinified: boolean;
  skipUtilities: boolean;
  skipBoundaries: boolean;
}

const DEFAULT_FILTERS: PathFilters = {
  skipProviders: true,
  skipHocs: true,
  skipContainers: true,
  skipMinified: true,
  skipUtilities: true,
  skipBoundaries: true,
};

const FILTER_PATTERNS = {
  providers: [/Provider$/, /^Provider$/, /^Context$/],
  hocs: [/^with[A-Z]/, /^forward(?:Ref)?$/i, /^Forward(?:Ref)?\(/],
  containers: [/^(?:App)?Container$/, /^Root$/, /^ReactDev/],
  utilities: [
    /^Fragment$/,
    /^Suspense$/,
    /^ErrorBoundary$/,
    /^Portal$/,
    /^Consumer$/,
    /^Layout$/,
    /^Router/,
    /^Hydration/,
  ],
  boundaries: [/^Boundary$/, /Boundary$/, /^Provider$/, /Provider$/],
};

const shouldIncludeInPath = (
  name: string,
  filters: PathFilters = DEFAULT_FILTERS,
): boolean => {
  const patternsToCheck: Array<RegExp> = [];
  if (filters.skipProviders) patternsToCheck.push(...FILTER_PATTERNS.providers);
  if (filters.skipHocs) patternsToCheck.push(...FILTER_PATTERNS.hocs);
  if (filters.skipContainers)
    patternsToCheck.push(...FILTER_PATTERNS.containers);
  if (filters.skipUtilities) patternsToCheck.push(...FILTER_PATTERNS.utilities);
  if (filters.skipBoundaries)
    patternsToCheck.push(...FILTER_PATTERNS.boundaries);
  return !patternsToCheck.some((pattern) => pattern.test(name));
};

const minifiedPatterns = [
  /^[a-z]$/, // Single lowercase letter
  /^[a-z][0-9]$/, // Lowercase letter followed by number
  /^_+$/, // Just underscores
  /^[A-Za-z][_$]$/, // Letter followed by underscore or dollar
  /^[a-z]{1,2}$/, // 1-2 lowercase letters
];

const isMinified = (name: string): boolean => {
  for (let i = 0; i < minifiedPatterns.length; i++) {
    if (minifiedPatterns[i].test(name)) return true;
  }

  const hasNoVowels = !/[aeiou]/i.test(name);
  const hasMostlyNumbers = (name.match(/\d/g)?.length ?? 0) > name.length / 2;
  const isSingleWordLowerCase = /^[a-z]+$/.test(name);
  const hasRandomLookingChars = /[$_]{2,}/.test(name);

  // If more than 2 of the following are true, we consider the name minified
  return (
    Number(hasNoVowels) +
      Number(hasMostlyNumbers) +
      Number(isSingleWordLowerCase) +
      Number(hasRandomLookingChars) >=
    2
  );
};

export const getInteractionPath = (
  initialFiber: Fiber | null,
  filters: PathFilters = DEFAULT_FILTERS,
): Array<string> => {
  if (!initialFiber) return [];

  const currentName = getDisplayName(initialFiber.type);
  if (!currentName) return [];

  const stack = new Array<string>();
  let fiber = initialFiber;
  while (fiber.return) {
    const name = getCleanComponentName(fiber.type);
    if (name && !isMinified(name) && shouldIncludeInPath(name, filters) && name.toLowerCase() !== name) {
      stack.push(name);
    }
    fiber = fiber.return;
  }
  const fullPath = new Array<string>(stack.length);
  for (let i = 0; i < stack.length; i++) {
    fullPath[i] = stack[stack.length - i - 1];
  }
  return fullPath;
};

let currentMouseOver: Element;

interface FiberType {
  displayName?: string;
  name?: string;
  [key: string]: unknown;
}

const getCleanComponentName = (component: FiberType): string => {
  const name = getDisplayName(component);
  if (!name) return '';

  return name.replace(
    /^(?:Memo|Forward(?:Ref)?|With.*?)\((?<inner>.*?)\)$/,
    '$<inner>',
  );
};

// For future use, normalization of paths happens on server side now using path property of interaction
// const _normalizePath = (path: Array<string>): string => {
// 	const cleaned = path.filter(Boolean);
// 	const deduped = cleaned.filter((name, i) => name !== cleaned[i - 1]);
// 	return deduped.join('.');
// };

const handleMouseover = (event: Event) => {
  if (!(event.target instanceof Element)) return;
  currentMouseOver = event.target;
};

const getFirstNamedAncestorCompositeFiber = (element: Element) => {
  let curr: Element | null = element;
  let parentCompositeFiber: Fiber | null = null;
  while (!parentCompositeFiber && curr.parentElement) {
    curr = curr.parentElement;

    const fiber = getCompositeComponentFromElement(curr).parentCompositeFiber;

    if (!fiber) {
      continue;
    }
    if (getDisplayName(fiber.type)) {
      parentCompositeFiber = fiber;
    }
  }
  return parentCompositeFiber;
};

// fixme: compress me if this stays here for bad interaction time checks
let lastVisibilityHiddenAt: number | 'never-hidden' = 'never-hidden';

const onVisibilityChange = () => {
  if (document.hidden) {
    lastVisibilityHiddenAt = Date.now();
  }
};

const trackVisibilityChange = () => {
  document.removeEventListener('visibilitychange', onVisibilityChange);
  document.addEventListener('visibilitychange', onVisibilityChange);
};

// todo: update monitoring api to expose filters for component names
export function initPerformanceMonitoring(options?: Partial<PathFilters>) {
  const filters = { ...DEFAULT_FILTERS, ...options };
  const monitor = Store.monitor.value;
  if (!monitor) return;

  document.addEventListener('mouseover', handleMouseover);
  const disconnectPerformanceListener = setupPerformanceListener((entry) => {
    const target =
      entry.target ?? (entry.type === 'pointer' ? currentMouseOver : null);
    if (!target) {
      // most likely an invariant that we should log if its violated
      return;
    }
    const parentCompositeFiber = getFirstNamedAncestorCompositeFiber(target);
    if (!parentCompositeFiber) {
      return;
    }
    const displayName = getDisplayName(parentCompositeFiber.type);
    if (!displayName || isMinified(displayName)) {
      // invariant, we know its named based on getFirstNamedAncestorCompositeFiber implementation
      return;
    }

    const path = getInteractionPath(parentCompositeFiber, filters);

    monitor.interactions.push({
      componentName: displayName,
      componentPath: path,
      performanceEntry: entry,
      components: new Map(),
      url: window.location.toString(),
      route:
        Store.monitor.value?.route ?? new URL(window.location.href).pathname,
      commit: Store.monitor.value?.commit ?? null,
      branch: Store.monitor.value?.branch ?? null,
      uniqueInteractionId: entry.id,
    });
  });

  return () => {
    disconnectPerformanceListener();
    document.removeEventListener('mouseover', handleMouseover);
  };
}

const POINTER_EVENTS = new Set(['pointerdown', 'pointerup', 'click']);
const KEYBOARD_EVENTS = new Set(['keydown', 'keyup']);

const getInteractionType = (
  eventName: string,
): 'pointer' | 'keyboard' | null => {
  if (POINTER_EVENTS.has(eventName)) {
    return 'pointer';
  }
  if (KEYBOARD_EVENTS.has(eventName)) {
    return 'keyboard';
  }
  return null;
};

const setupPerformanceListener = (
  onEntry: (interaction: PerformanceInteraction) => void,
) => {
  trackVisibilityChange();
  const longestInteractionMap = new Map<string, PerformanceInteraction>();
  const interactionTargetMap = new Map<string, Element>();

  const processInteractionEntry = (entry: PerformanceInteractionEntry) => {
    if (!(entry.interactionId || entry.entryType === 'first-input')) return;

    if (
      entry.interactionId &&
      entry.target &&
      !interactionTargetMap.has(entry.interactionId)
    ) {
      interactionTargetMap.set(entry.interactionId, entry.target);
    }

    const existingInteraction = longestInteractionMap.get(entry.interactionId);

    if (existingInteraction) {
      if (entry.duration > existingInteraction.latency) {
        existingInteraction.entries = [entry];
        existingInteraction.latency = entry.duration;
      } else if (
        entry.duration === existingInteraction.latency &&
        entry.startTime === existingInteraction.entries[0].startTime
      ) {
        existingInteraction.entries.push(entry);
      }
    } else {
      const interactionType = getInteractionType(entry.name);
      if (!interactionType) return;

      const interaction: PerformanceInteraction = {
        id: entry.interactionId,
        latency: entry.duration,
        entries: [entry],
        target: entry.target,
        type: interactionType,
        startTime: entry.startTime,
        processingStart: entry.processingStart,
        processingEnd: entry.processingEnd,
        duration: entry.duration,
        inputDelay: entry.processingStart - entry.startTime,
        processingDuration: entry.processingEnd - entry.processingStart,
        presentationDelay:
          entry.duration - (entry.processingEnd - entry.startTime),
        timestamp: Date.now(),
        timeSinceTabInactive:
          lastVisibilityHiddenAt === 'never-hidden'
            ? 'never-hidden'
            : Date.now() - lastVisibilityHiddenAt,
        visibilityState: document.visibilityState,
        timeOrigin: performance.timeOrigin,
        referrer: document.referrer,
      };
      longestInteractionMap.set(interaction.id, interaction);

      onEntry(interaction);
    }
  };

  const po = new PerformanceObserver((list) => {
    const entries = list.getEntries();
    for (let i = 0, len = entries.length; i < len; i++) {
      const entry = entries[i];
      processInteractionEntry(entry as PerformanceInteractionEntry);
    }
  });

  try {
    po.observe({
      type: 'event',
      buffered: true,
      durationThreshold: 16,
    } as PerformanceObserverInit);
    po.observe({
      type: 'first-input',
      buffered: true,
    });
  } catch {
    /* Should collect error logs*/
  }

  return po.disconnect.bind(po);
};
</file>

<file path="packages/scan/src/core/notifications/outline-overlay.ts">
import { signal } from '@preact/signals';
import { iife } from './performance-utils';

export interface HeatmapOverlay {
  boundingRect: DOMRect;
  ms: number;
  name: string;
}

export let highlightCanvas: HTMLCanvasElement | null = null;
export let highlightCtx: CanvasRenderingContext2D | null = null;

let animationFrame: number | null = null;

export type TransitionHighlightState = {
  kind: 'transition';
  transitionTo: {
    name: string;
    rects: Array<DOMRect>;
    alpha: number;
  };
  current: {
    name: string;
    rects: Array<DOMRect>;
    alpha: number;
  } | null;
};
type HighlightState =
  | TransitionHighlightState
  | {
      kind: 'move-out';
      current: {
        name: string;
        rects: Array<DOMRect>;
        alpha: number;
      };
    }
  | {
      kind: 'idle';
      current: {
        name: string;
        rects: Array<DOMRect>;
      } | null;
    };

export const HighlightStore = signal<HighlightState>({
  kind: 'idle',
  current: null,
});

let currFrame: ReturnType<typeof requestAnimationFrame> | null = null;
export const drawHighlights = () => {
  if (currFrame) {
    cancelAnimationFrame(currFrame);
  }
  currFrame = requestAnimationFrame(() => {
    if (!highlightCanvas || !highlightCtx) {
      return;
    }

    highlightCtx.clearRect(0, 0, highlightCanvas.width, highlightCanvas.height);

    const color = 'hsl(271, 76%, 53%)';
    const state = HighlightStore.value;
    const { alpha, current } = iife(() => {
      switch (state.kind) {
        case 'transition': {
          const current =
            state.current?.alpha && state.current.alpha > 0
              ? state.current
              : state.transitionTo;
          return {
            alpha: current ? current.alpha : 0,
            current,
          };
        }
        case 'move-out': {
          return { alpha: state.current?.alpha ?? 0, current: state.current };
        }
        case 'idle': {
          return { alpha: 1, current: state.current };
        }
      }
      // exhaustive check
      state satisfies never;
    });

    current?.rects.forEach((rect) => {
      if (!highlightCtx) {
        // typescript cant tell this closure is synchronous/non-escaping
        return;
      }
      highlightCtx.shadowColor = color;
      highlightCtx.shadowBlur = 6;
      highlightCtx.strokeStyle = color;
      highlightCtx.lineWidth = 2;

      highlightCtx.globalAlpha = alpha;

      highlightCtx.beginPath();
      highlightCtx.rect(rect.left, rect.top, rect.width, rect.height);
      highlightCtx.stroke();

      highlightCtx.shadowBlur = 0;
      highlightCtx.beginPath();
      highlightCtx.rect(rect.left, rect.top, rect.width, rect.height);
      highlightCtx.stroke();
    });

    switch (state.kind) {
      case 'move-out': {
        if (state.current.alpha === 0) {
          HighlightStore.value = {
            kind: 'idle',
            current: null,
          };
          return;
        }
        if (state.current.alpha <= 0.01) {
          state.current.alpha = 0;
        }
        state.current.alpha = Math.max(0, state.current.alpha - 0.03);
        drawHighlights();
        return;
      }
      case 'transition': {
        if (state.current && state.current.alpha > 0) {
          state.current.alpha = Math.max(0, state.current.alpha - 0.03);
          drawHighlights();
          return;
        }

        // invariant, state.current.alpha === 0
        if (state.transitionTo.alpha === 1) {
          HighlightStore.value = {
            kind: 'idle',
            current: state.transitionTo,
          };
          return;
        }

        // intentionally linear
        state.transitionTo.alpha = Math.min(state.transitionTo.alpha + 0.03, 1);

        drawHighlights();
      }
      case 'idle': {
        // no-op
        return;
      }
    }
  });
};

let handleResizeListener: (() => void) | null = null;
export const createHighlightCanvas = (root: HTMLElement) => {
  highlightCanvas = document.createElement('canvas');
  highlightCtx = highlightCanvas.getContext('2d', { alpha: true });
  if (!highlightCtx) return null;

  const dpr = window.devicePixelRatio || 1;
  const { innerWidth, innerHeight } = window;

  highlightCanvas.style.width = `${innerWidth}px`;
  highlightCanvas.style.height = `${innerHeight}px`;
  highlightCanvas.width = innerWidth * dpr;
  highlightCanvas.height = innerHeight * dpr;
  highlightCanvas.style.position = 'fixed';
  highlightCanvas.style.left = '0';
  highlightCanvas.style.top = '0';
  highlightCanvas.style.pointerEvents = 'none';
  highlightCanvas.style.zIndex = '2147483600';

  // *** ADD DATA ATTRIBUTE ***
  highlightCanvas.setAttribute('data-react-scan-canvas', 'true');
  // *** END ADD ***

  highlightCtx.scale(dpr, dpr);

  root.appendChild(highlightCanvas);

  if (handleResizeListener) {
    window.removeEventListener('resize', handleResizeListener);
  }

  const handleResize = () => {
    if (!highlightCanvas || !highlightCtx) return;
    const dpr = window.devicePixelRatio || 1;
    const { innerWidth, innerHeight } = window;

    highlightCanvas.style.width = `${innerWidth}px`;
    highlightCanvas.style.height = `${innerHeight}px`;
    highlightCanvas.width = innerWidth * dpr;
    highlightCanvas.height = innerHeight * dpr;
    highlightCtx.scale(dpr, dpr);

    drawHighlights();
  };
  handleResizeListener = handleResize;

  window.addEventListener('resize', handleResize);

  HighlightStore.subscribe(() => {
    requestAnimationFrame(() => {
      drawHighlights();
    });
  });

  return cleanup;
};

export function cleanup() {
  if (animationFrame) {
    cancelAnimationFrame(animationFrame);
    animationFrame = null;
  }
  if (highlightCanvas?.parentNode) {
    highlightCanvas.parentNode.removeChild(highlightCanvas);
  }
  highlightCanvas = null;
  highlightCtx = null;
}
</file>

<file path="packages/scan/src/core/utils.ts">
// @ts-nocheck
import { type Fiber, getType } from 'bippy';
// import type { ComponentType } from 'preact';
import { ReactScanInternals } from '~core/index';
import type { AggregatedRender } from '~web/utils/outline';
import type { AggregatedChange, Render } from './instrumentation';

export const aggregateChanges = (
  changes: Array<Change>,
  prevAggregatedChange?: AggregatedChange,
) => {
  const newChange = {
    type: prevAggregatedChange?.type ?? 0,
    unstable: prevAggregatedChange?.unstable ?? false,
  };
  for (const change of changes) {
    newChange.type |= change.type;
    newChange.unstable = newChange.unstable || (change.unstable ?? false);
  }

  return newChange;
};

export const joinAggregations = ({
  from,
  to,
}: {
  from: AggregatedRender;
  to: AggregatedRender;
}) => {
  to.changes.type |= from.changes.type;
  to.changes.unstable = to.changes.unstable || from.changes.unstable;
  to.aggregatedCount += 1;
  to.didCommit = to.didCommit || from.didCommit;
  to.forget = to.forget || from.forget;
  to.fps = to.fps + from.fps;
  to.phase |= from.phase;
  to.time = (to.time ?? 0) + (from.time ?? 0);

  to.unnecessary = to.unnecessary || from.unnecessary;
};

export const aggregateRender = (
  newRender: Render,
  prevAggregated: AggregatedRender,
) => {
  prevAggregated.changes = aggregateChanges(
    newRender.changes,
    prevAggregated.changes,
  );
  prevAggregated.aggregatedCount += 1;
  prevAggregated.didCommit = prevAggregated.didCommit || newRender.didCommit;
  prevAggregated.forget = prevAggregated.forget || newRender.forget;
  prevAggregated.fps = prevAggregated.fps + newRender.fps;
  prevAggregated.phase |= newRender.phase;
  prevAggregated.time = (prevAggregated.time ?? 0) + (newRender.time ?? 0);

  prevAggregated.unnecessary =
    prevAggregated.unnecessary || newRender.unnecessary;
};

function descending(a: number, b: number): number {
  return b - a;
}

interface ComponentData {
  name: string;
  forget: boolean;
  time: number;
}

function getComponentGroupNames(group: ComponentData[]): string {
  let result = group[0].name;

  const len = group.length;
  const max = Math.min(4, len);

  for (let i = 1; i < max; i++) {
    result += `, ${group[i].name}`;
  }

  return result;
}

function getComponentGroupTotalTime(group: ComponentData[]): number {
  let result = group[0].time;

  for (let i = 1, len = group.length; i < len; i++) {
    result += group[i].time;
  }

  return result;
}

function componentGroupHasForget(group: ComponentData[]): boolean {
  for (let i = 0, len = group.length; i < len; i++) {
    if (group[i].forget) {
      return true;
    }
  }
  return false;
}

export const getLabelText = (
  groupedAggregatedRenders: Array<AggregatedRender>,
) => {
  let labelText = '';

  const componentsByCount = new Map<
    number,
    Array<{ name: string; forget: boolean; time: number }>
  >();

  for (const aggregatedRender of groupedAggregatedRenders) {
    const { forget, time, aggregatedCount, name } = aggregatedRender;
    if (!componentsByCount.has(aggregatedCount)) {
      componentsByCount.set(aggregatedCount, []);
    }
    const components = componentsByCount.get(aggregatedCount);
    if (components) {
      components.push({ name, forget, time: time ?? 0 });
    }
  }

  const sortedCounts = Array.from(componentsByCount.keys()).sort(descending);

  const parts: Array<string> = [];
  let cumulativeTime = 0;
  for (const count of sortedCounts) {
    const componentGroup = componentsByCount.get(count);
    if (!componentGroup) continue;

    let text = getComponentGroupNames(componentGroup);
    const totalTime = getComponentGroupTotalTime(componentGroup);
    const hasForget = componentGroupHasForget(componentGroup);

    cumulativeTime += totalTime;

    if (componentGroup.length > 4) {
      text += '…';
    }

    if (count > 1) {
      text += ` × ${count}`;
    }

    if (hasForget) {
      text = `✨${text}`;
    }

    parts.push(text);
  }

  labelText = parts.join(', ');

  if (!labelText.length) return null;

  if (labelText.length > 40) {
    labelText = `${labelText.slice(0, 40)}…`;
  }

  if (cumulativeTime >= 0.01) {
    labelText += ` (${Number(cumulativeTime.toFixed(2))}ms)`;
  }

  return labelText;
};

export const updateFiberRenderData = (fiber: Fiber, renders: Array<Render>) => {
  ReactScanInternals.options.value.onRender?.(fiber, renders);
  const type = getType(fiber.type) || fiber.type;
  if (type && (typeof type === 'function' || typeof type === 'object')) {
    const renderData = (type.renderData || {
      count: 0,
      time: 0,
      renders: [],
    }) as RenderData;
    const firstRender = renders[0];
    renderData.count += firstRender.count;
    renderData.time += firstRender.time ?? 0;
    renderData.renders.push(firstRender);
    type.renderData = renderData;
  }
};

export interface RenderData {
  count: number;
  time: number;
  renders: Array<Render>;
  displayName: string | null;
  type: unknown;
  changes?: Array<RenderChange>;
}

export function isEqual(a: unknown, b: unknown): boolean {
  return a === b || (a !== a && b !== b);
}

export const playNotificationSound = (audioContext: AudioContext) => {
  const oscillator = audioContext.createOscillator();
  const gainNode = audioContext.createGain();

  oscillator.connect(gainNode);
  gainNode.connect(audioContext.destination);

  const options = {
    type: 'sine' as OscillatorType,
    freq: [
      392,
      //  523.25,
      600,
      //  659.25
    ],
    duration: 0.3,
    gain: 0.12,
  };

  const frequencies = options.freq;
  const timePerNote = options.duration / frequencies.length;

  frequencies.forEach((freq, i) => {
    oscillator.frequency.setValueAtTime(
      freq,
      audioContext.currentTime + i * timePerNote,
    );
  });

  oscillator.type = options.type;
  gainNode.gain.setValueAtTime(options.gain, audioContext.currentTime);

  gainNode.gain.setTargetAtTime(
    0,
    audioContext.currentTime + options.duration * 0.7,
    0.05,
  );

  oscillator.start();
  oscillator.stop(audioContext.currentTime + options.duration);
};
</file>

<file path="packages/scan/src/web/utils/create-store.ts">
/**
 * Adapted from zustand v5.0.3
 *
 * https://github.com/pmndrs/zustand
 *
 * Do not modify unless you know what you are doing
 */
type SetStateInternal<T> = {
  _(
    partial: T | Partial<T> | { _(state: T): T | Partial<T> }['_'],
    replace?: false,
  ): void;
  _(state: T | { _(state: T): T }['_'], replace: true): void;
}['_'];

export interface StoreApi<T> {
  setState: SetStateInternal<T>;
  getState: () => T;
  getInitialState: () => T;
  subscribe: {
    (listener: (state: T, prevState: T) => void): () => void;
    <U>(
      selector: (state: T) => U,
      listener: (selectedState: U, prevSelectedState: U) => void,
    ): () => void;
  };
}

export type ExtractState<S> = S extends { getState: () => infer T } ? T : never;

type Get<T, K, F> = K extends keyof T ? T[K] : F;

export type Mutate<S, Ms> = number extends Ms['length' & keyof Ms]
  ? S
  : Ms extends []
    ? S
    : Ms extends [[infer Mi, infer Ma], ...infer Mrs]
      ? Mutate<StoreMutators<S, Ma>[Mi & StoreMutatorIdentifier], Mrs>
      : never;

export type StateCreator<
  T,
  Mis extends [StoreMutatorIdentifier, unknown][] = [],
  Mos extends [StoreMutatorIdentifier, unknown][] = [],
  U = T,
> = ((
  setState: Get<Mutate<StoreApi<T>, Mis>, 'setState', never>,
  getState: Get<Mutate<StoreApi<T>, Mis>, 'getState', never>,
  store: Mutate<StoreApi<T>, Mis>,
) => U) & { $$storeMutators?: Mos };

// biome-ignore lint/correctness/noUnusedVariables: <explanation>
export interface StoreMutators<S, A> {}
export type StoreMutatorIdentifier = keyof StoreMutators<unknown, unknown>;

type CreateStore = {
  <T, Mos extends [StoreMutatorIdentifier, unknown][] = []>(
    initializer: StateCreator<T, [], Mos>,
  ): Mutate<StoreApi<T>, Mos>;

  <T>(): <Mos extends [StoreMutatorIdentifier, unknown][] = []>(
    initializer: StateCreator<T, [], Mos>,
  ) => Mutate<StoreApi<T>, Mos>;
};

type CreateStoreImpl = <
  T,
  Mos extends [StoreMutatorIdentifier, unknown][] = [],
>(
  initializer: StateCreator<T, [], Mos>,
) => Mutate<StoreApi<T>, Mos>;

const createStoreImpl: CreateStoreImpl = (createState) => {
  type TState = ReturnType<typeof createState>;
  type Listener = (state: TState, prevState: TState) => void;
  let state: TState;
  const listeners: Set<Listener> = new Set();

  const setState: StoreApi<TState>['setState'] = (partial, replace) => {
    const nextState =
      typeof partial === 'function'
        ? (partial as (state: TState) => TState)(state)
        : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state =
        (replace ?? (typeof nextState !== 'object' || nextState === null))
          ? (nextState as TState)
          : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };

  const getState: StoreApi<TState>['getState'] = () => state;

  const getInitialState: StoreApi<TState>['getInitialState'] = () =>
    initialState;

  const subscribe: StoreApi<TState>['subscribe'] = (
    selectorOrListener:
      | ((state: TState, prevState: TState) => void)
      // biome-ignore lint/suspicious/noExplicitAny: <explanation>
      | ((state: TState) => any),
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    listener?: (selectedState: any, prevSelectedState: any) => void,
  ) => {
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    let selector: ((state: TState) => any) | undefined;
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    let actualListener: (state: any, prevState: any) => void;

    if (listener) {
      // Selector subscription case
      // biome-ignore lint/suspicious/noExplicitAny: <explanation>
      selector = selectorOrListener as (state: TState) => any;
      actualListener = listener;
    } else {
      // Regular subscription case
      actualListener = selectorOrListener as (
        state: TState,
        prevState: TState,
      ) => void;
    }

    let currentSlice = selector ? selector(state) : undefined;

    const wrappedListener = (newState: TState, previousState: TState) => {
      if (selector) {
        const nextSlice = selector(newState);
        const prevSlice = selector(previousState);
        if (!Object.is(currentSlice, nextSlice)) {
          currentSlice = nextSlice;
          actualListener(nextSlice, prevSlice);
        }
      } else {
        actualListener(newState, previousState);
      }
    };

    listeners.add(wrappedListener);
    // Unsubscribe
    return () => listeners.delete(wrappedListener);
  };

  const api = { setState, getState, getInitialState, subscribe };
  const initialState = (state = createState(setState, getState, api));
  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
  return api as any;
};

export const createStore = ((createState) =>
  createState ? createStoreImpl(createState) : createStoreImpl) as CreateStore;
</file>

<file path="packages/scan/src/types.ts">
import type { Fiber, FiberRoot } from 'bippy';

type ReactScanInternals = typeof import('./core/index')['ReactScanInternals'];
type Scan = typeof import('./index')['scan'];

export interface ExtendedReactRenderer {
  findFiberByHostInstance: (instance: Element) => Fiber | null;
  version: string;
  bundleType: number;
  rendererPackageName: string;
  overrideHookState?: (
    fiber: Fiber,
    id: string,
    path: string[],
    value: unknown,
  ) => void;
  overrideProps?: (fiber: Fiber, path: string[], value: unknown) => void;
  overrideContext?: (
    fiber: Fiber,
    contextType: unknown,
    path: string[],
    value: unknown,
  ) => void;
}

declare global {
  var __REACT_SCAN__: {
    ReactScanInternals: ReactScanInternals;
  };
  var reactScanCleanupListeners: (() => void) | undefined;
  var reactScan: Scan;
  var scheduler: {
    postTask: (cb: unknown, options: { priority: string }) => void;
  };

  type TTimer = NodeJS.Timeout;

  interface Window {
    reactScan: Scan;
    __REACT_SCAN_TOOLBAR_CONTAINER__?: HTMLDivElement;
    __REACT_SCAN_VERSION__?: string;
    __REACT_SCAN_EXTENSION__?: boolean;
    __REACT_DEVTOOLS_GLOBAL_HOOK__?: {
      checkDCE: (fn: unknown) => void;
      supportsFiber: boolean;
      supportsFlight: boolean;
      renderers: Map<number, ExtendedReactRenderer>;
      hasUnsupportedRendererAttached: boolean;
      onCommitFiberRoot: (
        rendererID: number,
        root: FiberRoot,
        priority: void | number,
      ) => void;
      onCommitFiberUnmount: (rendererID: number, fiber: Fiber) => void;
      onPostCommitFiberRoot: (rendererID: number, root: FiberRoot) => void;
      inject: (renderer: ExtendedReactRenderer) => number;
      _instrumentationSource?: string;
      _instrumentationIsActive?: boolean;
    };
  }
}
</file>

<file path="packages/scan/src/core/notifications/performance.ts">
import {
  Fiber,
  getDisplayName,
  getTimings,
  isHostFiber,
  traverseFiber,
} from 'bippy';
import { Store } from '../..';

import {
  BoundedArray,
  createChildrenAdjacencyList,
  invariantError,
} from '~core/notifications/performance-utils';
import {
  SectionData,
  collectInspectorDataWithoutCounts,
} from '~web/views/inspector/timeline/utils';
import {
  getFiberFromElement,
  getParentCompositeFiber,
} from '~web/views/inspector/utils';
import { performanceEntryChannels } from './performance-store';
import type {
  PerformanceInteraction,
  PerformanceInteractionEntry,
} from './types';
import { not_globally_unique_generateId } from '~core/monitor/utils';
import { getInteractionPath } from '~core/monitor/performance';

const getFirstNameFromAncestor = (
  fiber: Fiber,
  accept: (name: string) => boolean = () => true,
) => {
  let curr: Fiber | null = fiber;

  while (curr) {
    const currName = getDisplayName(curr.type);
    if (currName && accept(currName)) {
      return currName;
    }

    curr = curr.return;
  }
  return null;
};

let unsubscribeTrackVisibilityChange: (() => void) | undefined;
// fixme: compress me if this stays here for bad interaction time checks
let lastVisibilityHiddenAt: number | 'never-hidden' = 'never-hidden';

const trackVisibilityChange = () => {
  unsubscribeTrackVisibilityChange?.();
  const onVisibilityChange = () => {
    if (document.hidden) {
      lastVisibilityHiddenAt = Date.now();
    }
  };
  document.addEventListener('visibilitychange', onVisibilityChange);

  unsubscribeTrackVisibilityChange = () => {
    document.removeEventListener('visibilitychange', onVisibilityChange);
  };
};
export type FiberRenders = Record<
  string,
  {
    renderCount: number;
    parents: Set<string>;
    selfTime: number;
    totalTime: number;
    nodeInfo: Array<{
      selfTime: number;
      element: Element;
      name: string;
    }>;
    changes: ReturnType<typeof collectInspectorDataWithoutCounts>;
  }
>;

/**
 * we need to fix:
 * - if there's a tab switch during a task being tracked, then u disregard that task (i hope this doesn't make tab switches hard to debug that cause slowdowns, ug i suppose it probably would, right? Depends how the browser queues it but i suppose u can think of a scenario. It would be most optimal to subtract the timing but not sure how reliable that would be)
 * - we need to see why the tracking is just off
 * - we need to correctly implement the precise activation this time
 */

type InteractionStartStage = {
  kind: 'interaction-start';
  interactionType: 'pointer' | 'keyboard';
  interactionUUID: string;
  interactionStartDetail: number;
  blockingTimeStart: number;
  componentPath: Array<string>;
  componentName: string;
  childrenTree: Record<
    string,
    { children: Array<string>; firstNamedAncestor: string; isRoot: boolean }
  >;
  fiberRenders: FiberRenders;
  stopListeningForRenders: () => void;
};

type JSEndStage = Omit<InteractionStartStage, 'kind'> & {
  kind: 'js-end-stage';
  jsEndDetail: number;
};

type RAFStage = Omit<JSEndStage, 'kind'> & {
  kind: 'raf-stage';
  rafStart: number;
};

export type TimeoutStage = Omit<RAFStage, 'kind'> & {
  kind: 'timeout-stage';
  commitEnd: number;
  blockingTimeEnd: number;
};

export type PerformanceEntryChannelEvent =
  | {
      kind: 'entry-received';
      entry: PerformanceInteraction;
    }
  | {
      kind: 'auto-complete-race';
      interactionUUID: string;
      detailedTiming: TimeoutStage;
    };

export type CompletedInteraction = {
  detailedTiming: TimeoutStage;
  latency: number;
  completedAt: number;
  flushNeeded: boolean;
};

type UnInitializedStage = {
  kind: 'uninitialized-stage';
  // todo: no longer a uuid
  interactionUUID: string;
  interactionType: 'pointer' | 'keyboard';
};

type CurrentInteraction = {
  kind: 'pointer' | 'keyboard';
  interactionUUID: string;
  pointerUpStart: number;
  // needed for when inputs that can be clicked and trigger on change (like checkboxes)
  clickChangeStart: number | null;
  clickHandlerMicroTaskEnd: number | null;
  rafStart: number | null;
  commmitEnd: number | null;
  timeorigin: number;

  // for now i don't trust performance now timing for UTC time...
  blockingTimeStart: number;
  blockingTimeEnd: number | null;
  fiberRenders: Map<
    string,
    {
      renderCount: number;
      parents: Set<string>;
      selfTime: number;
    }
  >;
  componentPath: Array<string>;
  componentName: string;
  childrenTree: Record<
    string,
    { children: Array<string>; firstNamedAncestor: string; isRoot: boolean }
  >;
};

export let currentInteractions: Array<CurrentInteraction> = [];
export const fastHash = (str: string): string => {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash; // Convert to 32-bit integer
  }
  return hash.toString(36);
};
const getInteractionType = (
  eventName: string,
): 'pointer' | 'keyboard' | null => {
  // todo: track pointer down, but tends to not house expensive logic so not very high priority
  if (['pointerup', 'click'].includes(eventName)) {
    return 'pointer';
  }
  if (eventName.includes('key')) {
  }
  if (['keydown', 'keyup'].includes(eventName)) {
    return 'keyboard';
  }
  return null;
};
// biome-ignore lint/suspicious/noExplicitAny: shut up biome
export const getInteractionId = (interaction: any) => {
  return `${interaction.performanceEntry.type}::${normalizePath(interaction.componentPath)}::${interaction.url}`;
};
export function normalizePath(path: string[]): string {
  const cleaned = path.filter(Boolean);

  const deduped = cleaned.filter((name, i) => name !== cleaned[i - 1]);

  return deduped.join('.');
}
let onEntryAnimationId: number | null = null;
const setupPerformanceListener = (
  onEntry: (interaction: PerformanceInteraction) => void,
) => {
  trackVisibilityChange();
  const interactionMap = new Map<string, PerformanceInteraction>();
  const interactionTargetMap = new Map<string, Element>();

  const processInteractionEntry = (entry: PerformanceInteractionEntry) => {
    if (!entry.interactionId) return;

    if (
      entry.interactionId &&
      entry.target &&
      !interactionTargetMap.has(entry.interactionId)
    ) {
      interactionTargetMap.set(entry.interactionId, entry.target);
    }
    if (entry.target) {
      let current: Element | null = entry.target;
      while (current) {
        if (
          current.id === 'react-scan-toolbar-root' ||
          current.id === 'react-scan-root'
        ) {
          return;
        }
        current = current.parentElement;
      }
    }

    const existingInteraction = interactionMap.get(entry.interactionId);

    if (existingInteraction) {
      if (entry.duration > existingInteraction.latency) {
        existingInteraction.entries = [entry];
        existingInteraction.latency = entry.duration;
      } else if (
        entry.duration === existingInteraction.latency &&
        entry.startTime === existingInteraction.entries[0].startTime
      ) {
        existingInteraction.entries.push(entry);
      }
    } else {
      const interactionType = getInteractionType(entry.name);
      if (!interactionType) {
        return;
      }

      const interaction: PerformanceInteraction = {
        id: entry.interactionId,
        latency: entry.duration,
        entries: [entry],
        target: entry.target,
        type: interactionType,
        startTime: entry.startTime,
        endTime: Date.now(),
        processingStart: entry.processingStart,
        processingEnd: entry.processingEnd,
        duration: entry.duration,
        inputDelay: entry.processingStart - entry.startTime,
        processingDuration: entry.processingEnd - entry.processingStart,
        presentationDelay:
          entry.duration - (entry.processingEnd - entry.startTime),
        // componentPath:
        timestamp: Date.now(),
        timeSinceTabInactive:
          lastVisibilityHiddenAt === 'never-hidden'
            ? 'never-hidden'
            : Date.now() - lastVisibilityHiddenAt,
        visibilityState: document.visibilityState,
        timeOrigin: performance.timeOrigin,
        referrer: document.referrer,
      };
      //
      interactionMap.set(interaction.id, interaction);

      /**
       * This seems odd, but it gives us determinism that we will receive an entry AFTER our detailed timing collection
       * runs because browser semantics (raf(() => setTimeout) will always run before a doubleRaf)
       *
       * this also handles the case where multiple entries are dispatched for semantically the same interaction,
       * they will get merged into a single interaction, where the largest latency is recorded, which is what
       * we are interested in this application
       */

      if (!onEntryAnimationId) {
        onEntryAnimationId = requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            // biome-ignore lint/style/noNonNullAssertion: invariant
            onEntry(interactionMap.get(interaction.id)!);
            onEntryAnimationId = null;
          });
        });
      }
    }
  };

  const po = new PerformanceObserver((list) => {
    const entries = list.getEntries();
    for (let i = 0, len = entries.length; i < len; i++) {
      const entry = entries[i];
      processInteractionEntry(entry as PerformanceInteractionEntry);
    }
  });

  try {
    po.observe({
      type: 'event',
      buffered: true,
      durationThreshold: 16,
    } as PerformanceObserverInit);
    po.observe({
      type: 'first-input',
      buffered: true,
    });
  } catch {
    /* Should collect error logs*/
  }

  return () => po.disconnect();
};

export const setupPerformancePublisher = () => {
  return setupPerformanceListener((entry) => {
    performanceEntryChannels.publish(
      {
        kind: 'entry-received',
        entry,
      },
      'recording',
    );
  });
};

// we should actually only feed it the information it needs to complete so we can support safari
type Task = {
  completeInteraction: (
    entry: PerformanceEntryChannelEvent,
  ) => CompletedInteraction;
  startDateTime: number;
  endDateTime: number;
  type: 'keyboard' | 'pointer';
  interactionUUID: string;
};
export const MAX_INTERACTION_TASKS = 25;

let tasks = new BoundedArray<Task>(MAX_INTERACTION_TASKS);

const getAssociatedDetailedTimingInteraction = (
  entry: PerformanceInteraction,
  activeTasks: Array<Task>,
) => {
  let closestTask: Task | null = null;
  for (const task of activeTasks) {
    if (task.type !== entry.type) {
      continue;
    }

    if (closestTask === null) {
      closestTask = task;
      continue;
    }

    const getAbsoluteDiff = (task: Task, entry: PerformanceInteraction) =>
      Math.abs(task.startDateTime) - (entry.startTime + entry.timeOrigin);

    if (getAbsoluteDiff(task, entry) < getAbsoluteDiff(closestTask, entry)) {
      closestTask = task;
    }
  }

  return closestTask;
};

// this would be cool if it listened for merge, so it had to be after
export const listenForPerformanceEntryInteractions = (
  onComplete: (completedInteraction: CompletedInteraction) => void,
) => {
  // we make the assumption that the detailed timing will be ready before the performance timing
  const unsubscribe = performanceEntryChannels.subscribe(
    'recording',
    (event) => {
      const associatedDetailedInteraction =
        event.kind === 'auto-complete-race'
          ? tasks.find((task) => task.interactionUUID === event.interactionUUID)
          : getAssociatedDetailedTimingInteraction(event.entry, tasks);

      // REMINDME: this likely means we clicked a non interactable thing but our handler still ran
      // so we shouldn't treat this as an invariant, but instead use it to verify if we clicked
      // something interactable
      if (!associatedDetailedInteraction) {
        return;
      }

      const completedInteraction =
        associatedDetailedInteraction.completeInteraction(event);
      onComplete(completedInteraction);
    },
  );

  return unsubscribe;
};

type ShouldContinue = boolean;
const trackDetailedTiming = ({
  onMicroTask,
  onRAF,
  onTimeout,
  abort,
}: {
  onMicroTask: () => ShouldContinue;
  onRAF: () => ShouldContinue;
  onTimeout: () => void;
  abort?: () => boolean;
}) => {
  queueMicrotask(() => {
    if (abort?.() === true) {
      return;
    }

    if (!onMicroTask()) {
      return;
    }
    requestAnimationFrame(() => {
      if (abort?.() === true) {
        return;
      }
      if (!onRAF()) {
        return;
      }
      setTimeout(() => {
        if (abort?.() === true) {
          return;
        }
        onTimeout();
      }, 0);
    });
  });
};

const getTargetInteractionDetails = (target: Element) => {
  const associatedFiber = getFiberFromElement(target);
  if (!associatedFiber) {
    return;
  }

  // TODO: if element is minified, squash upwards till first non minified ancestor, and set name as ChildOf(<parent-name>)
  let componentName = associatedFiber
    ? getDisplayName(associatedFiber?.type)
    : 'N/A';

  if (!componentName) {
    componentName =
      getFirstNameFromAncestor(associatedFiber, (name) => name.length > 2) ??
      'N/A';
  }

  if (!componentName) {
    return;
  }

  const componentPath = getInteractionPath(associatedFiber);

  // const childrenTree = collectFiberSubtree(associatedFiber, 20); // this can be expensive if not limited

  // const firstChildSvg = Object.entries(childrenTree).find(([name, {isSvg  }]) => isSvg)

  // const firstSvg =
  //   associatedFiber.type === "svg"
  //     ? getFirstNameFromAncestor(associatedFiber)
  //     : Object.entries(childrenTree).find(([name, {isSvg  }]) => isSvg)

  // lowkey i have an idea
  return {
    componentPath,
    childrenTree: {},
    componentName,
  };
};

type LastInteractionRef = {
  current: (
    | InteractionStartStage
    | JSEndStage
    | RAFStage
    | TimeoutStage
    | UnInitializedStage
  ) & { stageStart: number };
};

/**
 *
 * handles tracking event timings for arbitrarily overlapping handlers with cancel logic
 */
export const setupDetailedPointerTimingListener = (
  kind: 'pointer' | 'keyboard',
  options: {
    onStart?: (interactionUUID: string) => void;
    onComplete?: (
      interactionUUID: string,
      finalInteraction: {
        detailedTiming: TimeoutStage;
        latency: number;
        completedAt: number;
        flushNeeded: boolean;
      },
      entry: PerformanceEntryChannelEvent,
    ) => void;
    onError?: (interactionUUID: string) => void;
  },
) => {
  let instrumentationIdInControl: string | null = null;

  const getEvent = (
    info: { phase: 'start' } | { phase: 'end'; target: Element },
  ) => {
    switch (kind) {
      case 'pointer': {
        if (info.phase === 'start') {
          return 'pointerup';
        }
        if (
          info.target instanceof HTMLInputElement ||
          info.target instanceof HTMLSelectElement
        ) {
          return 'change';
        }
        return 'click';
      }
      case 'keyboard': {
        if (info.phase === 'start') {
          return 'keydown';
        }

        return 'change';
      }
    }
  };

  const lastInteractionRef: LastInteractionRef = {
    current: {
      kind: 'uninitialized-stage',
      interactionUUID: not_globally_unique_generateId(), // the first interaction uses this
      stageStart: Date.now(),
      interactionType: kind,
    },
  };

  const onInteractionStart = (e: Event) => {
    const path = e.composedPath();
    if (
      path.some(
        (el) => el instanceof Element && el.id === 'react-scan-toolbar-root',
      )
    ) {
      return;
    }
    if (Date.now() - lastInteractionRef.current.stageStart > 2000) {
      lastInteractionRef.current = {
        kind: 'uninitialized-stage',
        interactionUUID: not_globally_unique_generateId(),
        stageStart: Date.now(),
        interactionType: kind,
      };
    }

    if (lastInteractionRef.current.kind !== 'uninitialized-stage') {
      return;
    }

    const pointerUpStart = performance.now();

    options?.onStart?.(lastInteractionRef.current.interactionUUID);
    const details = getTargetInteractionDetails(e.target as HTMLElement);

    if (!details) {
      options?.onError?.(lastInteractionRef.current.interactionUUID);
      return;
    }

    const fiberRenders: InteractionStartStage['fiberRenders'] = {};
    const stopListeningForRenders = listenForRenders(fiberRenders);
    lastInteractionRef.current = {
      ...lastInteractionRef.current,
      interactionType: kind,
      blockingTimeStart: Date.now(),
      childrenTree: details.childrenTree,
      componentName: details.componentName,
      componentPath: details.componentPath,
      fiberRenders,
      kind: 'interaction-start',
      interactionStartDetail: pointerUpStart,
      stopListeningForRenders,
    };

    const event = getEvent({ phase: 'end', target: e.target as Element });
    // biome-ignore lint/suspicious/noExplicitAny: shut up biome
    document.addEventListener(event, onLastJS as any, {
      once: true,
    });

    // this is an edge case where a click event is not fired after a pointerdown
    // im not sure why this happens, but it seems to only happen on non intractable elements
    // it causes the event handler to stay alive until a future interaction, which can break timing (looks super long)
    // or invariants (the start metadata was removed, so now its an end metadata with no start)
    requestAnimationFrame(() => {
      // biome-ignore lint/suspicious/noExplicitAny: shut up biome
      document.removeEventListener(event as any, onLastJS as any);
    });
  };

  document.addEventListener(
    getEvent({ phase: 'start' }),
    // biome-ignore lint/suspicious/noExplicitAny: shut up biome
    onInteractionStart as any,
    {
      capture: true,
    },
  );

  /**
   *
   * TODO: IF WE DETECT RENDERS DURING THIS PERIOD WE CAN INCLUDE THAT IN THE RESULT AND THEN BACK THAT OUT OF COMPUTED STYLE TIME AND ADD IT BACK INTO JS TIME
   */
  const onLastJS = (
    e: { target: Element },
    instrumentationId: string,
    abort: () => boolean,
  ) => {
    if (
      lastInteractionRef.current.kind !== 'interaction-start' &&
      instrumentationId === instrumentationIdInControl
    ) {
      if (kind === 'pointer' && e.target instanceof HTMLSelectElement) {
        lastInteractionRef.current = {
          kind: 'uninitialized-stage',
          interactionUUID: not_globally_unique_generateId(),
          stageStart: Date.now(),
          interactionType: kind,
        };
        return;
      }

      options?.onError?.(lastInteractionRef.current.interactionUUID);
      lastInteractionRef.current = {
        kind: 'uninitialized-stage',
        interactionUUID: not_globally_unique_generateId(),
        stageStart: Date.now(),
        interactionType: kind,
      };
      invariantError('pointer -> click');
      return;
    }

    instrumentationIdInControl = instrumentationId;

    trackDetailedTiming({
      abort,
      onMicroTask: () => {
        if (lastInteractionRef.current.kind === 'uninitialized-stage') {
          return false;
        }

        lastInteractionRef.current = {
          ...lastInteractionRef.current,
          kind: 'js-end-stage',
          jsEndDetail: performance.now(),
        };
        return true;
      },
      onRAF: () => {
        if (
          lastInteractionRef.current.kind !== 'js-end-stage' &&
          lastInteractionRef.current.kind !== 'raf-stage'
        ) {
          options?.onError?.(lastInteractionRef.current.interactionUUID);
          invariantError('bad transition to raf');
          lastInteractionRef.current = {
            kind: 'uninitialized-stage',
            interactionUUID: not_globally_unique_generateId(),
            stageStart: Date.now(),
            interactionType: kind,
          };
          return false;
        }

        lastInteractionRef.current = {
          ...lastInteractionRef.current,
          kind: 'raf-stage',
          rafStart: performance.now(),
        };

        return true;
      },
      onTimeout: () => {
        if (lastInteractionRef.current.kind !== 'raf-stage') {
          options?.onError?.(lastInteractionRef.current.interactionUUID);
          lastInteractionRef.current = {
            kind: 'uninitialized-stage',
            interactionUUID: not_globally_unique_generateId(),
            stageStart: Date.now(),
            interactionType: kind,
          };
          invariantError('raf->timeout');
          return;
        }
        const now = Date.now();
        const timeoutStage: TimeoutStage = Object.freeze({
          ...lastInteractionRef.current,
          kind: 'timeout-stage',
          blockingTimeEnd: now,
          commitEnd: performance.now(),
        });

        lastInteractionRef.current = {
          kind: 'uninitialized-stage',
          interactionUUID: not_globally_unique_generateId(),
          stageStart: now,
          interactionType: kind,
        };
        let completed = false;
        const completeInteraction = (event: PerformanceEntryChannelEvent) => {
          completed = true;

          const latency =
            event.kind === 'auto-complete-race'
              ? event.detailedTiming.commitEnd -
                event.detailedTiming.interactionStartDetail
              : event.entry.latency;
          const finalInteraction = {
            detailedTiming: timeoutStage,
            latency,
            completedAt: Date.now(),
            flushNeeded: true,
          };

          options?.onComplete?.(
            timeoutStage.interactionUUID,
            finalInteraction,
            event,
          );
          const newTasks = tasks.filter(
            (task) => task.interactionUUID !== timeoutStage.interactionUUID,
          );
          tasks = BoundedArray.fromArray(newTasks, MAX_INTERACTION_TASKS);

          return finalInteraction;
        };

        const task = {
          completeInteraction,
          endDateTime: Date.now(),
          startDateTime: timeoutStage.blockingTimeStart,
          type: kind,
          interactionUUID: timeoutStage.interactionUUID,
        };
        tasks.push(task);

        if (!isPerformanceEventAvailable()) {
          const newTasks = tasks.filter(
            (task) => task.interactionUUID !== timeoutStage.interactionUUID,
          );
          tasks = BoundedArray.fromArray(newTasks, MAX_INTERACTION_TASKS);
          completeInteraction({
            kind: 'auto-complete-race',
            // redundant
            detailedTiming: timeoutStage,
            interactionUUID: timeoutStage.interactionUUID,
          });
        } else {
          setTimeout(() => {
            if (completed) {
              return;
            }
            completeInteraction({
              kind: 'auto-complete-race',
              // redundant
              detailedTiming: timeoutStage,
              interactionUUID: timeoutStage.interactionUUID,
            });
            const newTasks = tasks.filter(
              (task) => task.interactionUUID !== timeoutStage.interactionUUID,
            );
            tasks = BoundedArray.fromArray(newTasks, MAX_INTERACTION_TASKS);
            // this means the max frame presentation delta we can observe is 300ms, but this should catch >99% of cases, the trade off is to not accidentally miss slowdowns if the user quickly clicked something else while this race was happening
          }, 1000);
        }
      },
    });
  };

  const onKeyPress = (e: { target: Element }) => {
    const id = not_globally_unique_generateId();
    onLastJS(e, id, () => id !== instrumentationIdInControl);
  };

  if (kind === 'keyboard') {
    // biome-ignore lint/suspicious/noExplicitAny: shut up biome
    document.addEventListener('keypress', onKeyPress as any);
  }

  return () => {
    document.removeEventListener(
      getEvent({ phase: 'start' }),
      // biome-ignore lint/suspicious/noExplicitAny: shut up biome
      onInteractionStart as any,
      {
        capture: true,
      },
    );
    // biome-ignore lint/suspicious/noExplicitAny: shut up biome
    document.removeEventListener('keypress', onKeyPress as any);
  };
};

// unused, but will be soon for monitoring
export const collectFiberSubtree = (
  fiber: Fiber,
  limit: number,
): Record<
  string,
  {
    children: Array<string>;
    firstNamedAncestor: string;
    isRoot: boolean;
    isSvg: boolean;
  }
> => {
  const adjacencyList = createChildrenAdjacencyList(fiber, limit).entries();
  const fiberToNames = Array.from(adjacencyList).map(
    ([fiber, { children, parent, isRoot, isSVG }]) => [
      getDisplayName(fiber.type) ?? 'N/A',
      {
        children: children.map((fiber) => getDisplayName(fiber.type) ?? 'N/A'),
        firstNamedAncestor: parent
          ? (getFirstNameFromAncestor(parent) ?? 'No Parent')
          : 'No Parent',
        isRoot,
        isSVG,
      },
    ],
  );

  return Object.fromEntries(fiberToNames);
};

const getHostFromFiber = (fiber: Fiber) => {
  return traverseFiber(fiber, (node) => {
    // shouldn't be too slow
    if (isHostFiber(node)) {
      return true;
    }
  })?.stateNode;
};

const isPerformanceEventAvailable = () => {
  return 'PerformanceEventTiming' in globalThis;
};

export const listenForRenders = (
  fiberRenders: InteractionStartStage['fiberRenders'],
) => {
  const listener = (fiber: Fiber) => {
    const displayName = getDisplayName(fiber.type);
    if (!displayName) {
      return;
    }
    const existing = fiberRenders[displayName];
    if (!existing) {
      const parents = new Set<string>();
      const res = fiber.return && getParentCompositeFiber(fiber.return);
      const parentCompositeName = res && getDisplayName(res[0]);
      if (parentCompositeName) {
        parents.add(parentCompositeName);
      }
      const { selfTime, totalTime } = getTimings(fiber);

      const newChanges = collectInspectorDataWithoutCounts(fiber);
      const emptySection: SectionData = {
        current: [],
        changes: new Set<string | number>(),
        changesCounts: new Map<string | number, number>(),
      };
      const changes = {
        fiberProps: newChanges.fiberProps || emptySection,
        fiberState: newChanges.fiberState || emptySection,
        fiberContext: newChanges.fiberContext || emptySection,
      };
      fiberRenders[displayName] = {
        renderCount: 1,
        parents: parents,
        selfTime,
        totalTime,
        nodeInfo: [
          {
            element: getHostFromFiber(fiber),
            name: getDisplayName(fiber.type) ?? 'Unknown',
            selfTime: getTimings(fiber).selfTime,
          },
        ],
        changes,
      };

      return;
    }
    const parentType = getParentCompositeFiber(fiber)?.[0]?.type;
    if (parentType) {
      const res = fiber.return && getParentCompositeFiber(fiber.return);
      const parentCompositeName = res && getDisplayName(res[0]);
      if (parentCompositeName) {
        existing.parents.add(parentCompositeName);
      }
    }
    const { selfTime, totalTime } = getTimings(fiber);

    const newChanges = collectInspectorDataWithoutCounts(fiber);

    if (!newChanges) return;

    const emptySection: SectionData = {
      current: [],
      changes: new Set<string | number>(),
      changesCounts: new Map<string | number, number>(),
    };

    existing.changes = {
      fiberProps: mergeSectionData(
        existing.changes?.fiberProps || emptySection,
        newChanges.fiberProps || emptySection,
      ),
      fiberState: mergeSectionData(
        existing.changes?.fiberState || emptySection,
        newChanges.fiberState || emptySection,
      ),
      fiberContext: mergeSectionData(
        existing.changes?.fiberContext || emptySection,
        newChanges.fiberContext || emptySection,
      ),
    };

    existing.renderCount += 1;
    existing.selfTime += selfTime;
    existing.totalTime += totalTime;
    existing.nodeInfo.push({
      element: getHostFromFiber(fiber),
      name: getDisplayName(fiber.type) ?? 'Unknown',
      selfTime: getTimings(fiber).selfTime,
    });
  };
  Store.interactionListeningForRenders = listener;

  return () => {
    if (Store.interactionListeningForRenders === listener) {
      Store.interactionListeningForRenders = null;
    }
  };
};

const mergeSectionData = (
  existing: SectionData,
  newData: SectionData,
): SectionData => {
  const mergedSection: SectionData = {
    current: [...existing.current],
    changes: new Set<string | number>(),
    changesCounts: new Map<string | number, number>(),
  };

  for (const value of newData.current) {
    if (!mergedSection.current.some((item) => item.name === value.name)) {
      mergedSection.current.push(value);
    }
  }

  for (const change of newData.changes) {
    if (typeof change === 'string' || typeof change === 'number') {
      mergedSection.changes.add(change);
      const existingCount = existing.changesCounts.get(change) || 0;
      const newCount = newData.changesCounts.get(change) || 0;
      mergedSection.changesCounts.set(change, existingCount + newCount);
    }
  }

  return mergedSection;
};
</file>

<file path="packages/scan/src/web/utils/helpers.ts">
import {
  type Fiber,
  MemoComponentTag,
  SimpleMemoComponentTag,
  SuspenseComponentTag,
  getDisplayName,
  hasMemoCache,
} from 'bippy';
import { type ClassValue, clsx } from 'clsx';
import { IS_CLIENT } from './constants';
import { twMerge } from 'tailwind-merge';

export const cn = (...inputs: Array<ClassValue>): string => {
  return twMerge(clsx(inputs));
};

export const isFirefox =
  /* @__PURE__ */ typeof navigator !== 'undefined' &&
  navigator.userAgent.includes('Firefox');

export const onIdle = (callback: () => void) => {
  if ('scheduler' in globalThis) {
    return globalThis.scheduler.postTask(callback, {
      priority: 'background',
    });
  }
  if ('requestIdleCallback' in window) {
    return requestIdleCallback(callback);
  }
  return setTimeout(callback, 0);
};

export const throttle = <E>(
  callback: (e?: E) => void,
  delay: number,
): ((e?: E) => void) => {
  let lastCall = 0;
  return (e?: E) => {
    const now = Date.now();
    if (now - lastCall >= delay) {
      lastCall = now;
      return callback(e);
    }
    return undefined;
  };
};

export const tryOrElse = <T>(fn: () => T, defaultValue: T): T => {
  try {
    return fn();
  } catch {
    return defaultValue;
  }
};

export const readLocalStorage = <T>(storageKey: string): T | null => {
  if (!IS_CLIENT) return null;

  try {
    const stored = localStorage.getItem(storageKey);
    return stored ? JSON.parse(stored) : null;
  } catch {
    return null;
  }
};

export const saveLocalStorage = <T>(storageKey: string, state: T): void => {
  if (!IS_CLIENT) return;

  try {
    window.localStorage.setItem(storageKey, JSON.stringify(state));
  } catch {}
};
export const removeLocalStorage = (storageKey: string): void => {
  if (!IS_CLIENT) return;

  try {
    window.localStorage.removeItem(storageKey);
  } catch {}
};

export const toggleMultipleClasses = (
  element: HTMLElement,
  classes: Array<string>,
) => {
  for (const cls of classes) {
    element.classList.toggle(cls);
  }
};

interface WrapperBadge {
  type: 'memo' | 'forwardRef' | 'lazy' | 'suspense' | 'profiler' | 'strict';
  title: string;
  compiler?: boolean;
}

export interface ExtendedDisplayName {
  name: string | null;
  wrappers: Array<string>;
  wrapperTypes: Array<WrapperBadge>;
}

// React internal tags not exported by bippy
const LazyComponentTag = 24;
const ProfilerTag = 12;

export const getExtendedDisplayName = (fiber: Fiber): ExtendedDisplayName => {
  if (!fiber) {
    return {
      name: 'Unknown',
      wrappers: [],
      wrapperTypes: [],
    };
  }

  const { tag, type, elementType } = fiber;
  let name = getDisplayName(type);
  const wrappers: Array<string> = [];
  const wrapperTypes: Array<WrapperBadge> = [];

  if (
    hasMemoCache(fiber) ||
    tag === SimpleMemoComponentTag ||
    tag === MemoComponentTag ||
    (type as { $$typeof?: symbol })?.$$typeof === Symbol.for('react.memo') ||
    (elementType as { $$typeof?: symbol })?.$$typeof ===
      Symbol.for('react.memo')
  ) {
    const compiler = hasMemoCache(fiber);
    wrapperTypes.push({
      type: 'memo',
      title: compiler
        ? 'This component has been auto-memoized by the React Compiler.'
        : 'Memoized component that skips re-renders if props are the same',
      compiler,
    });
  }

  if (tag === LazyComponentTag) {
    wrapperTypes.push({
      type: 'lazy',
      title: 'Lazily loaded component that supports code splitting',
    });
  }

  if (tag === SuspenseComponentTag) {
    wrapperTypes.push({
      type: 'suspense',
      title: 'Component that can suspend while content is loading',
    });
  }

  if (tag === ProfilerTag) {
    wrapperTypes.push({
      type: 'profiler',
      title: 'Component that measures rendering performance',
    });
  }

  if (typeof name === 'string') {
    const wrapperRegex = /^(\w+)\((.*)\)$/;
    let currentName = name;
    while (wrapperRegex.test(currentName)) {
      const match = currentName.match(wrapperRegex);
      if (match?.[1] && match?.[2]) {
        wrappers.unshift(match[1]);
        currentName = match[2];
      } else {
        break;
      }
    }
    name = currentName;
  }

  return {
    name: name || 'Unknown',
    wrappers,
    wrapperTypes,
  };
};
</file>

<file path="packages/scan/src/web/views/notifications/data.ts">
import { createContext } from 'preact';
import { SetStateAction } from 'preact/compat';
import { Dispatch, useContext } from 'preact/hooks';
import { HIGH_SEVERITY_FPS_DROP_TIME } from '~core/notifications/event-tracking';

export type GroupedFiberRender = {
  id: string;
  name: string;
  count: number;
  changes: {
    props: Array<{ name: string; count: number }>;
    state: Array<{ index: number; count: number }>;
    context: Array<{ name: string; count: number }>;
  };
  // fixme: incorrect assumption, make this nullable
  /** Not available when running in production, but we will not render notifications in production */
  totalTime: number;
  elements: Array<Element>; // can't do a weak set because need to iterate over them......
  deletedAll: boolean;
  parents: Set<string>;
};
export const getComponentName = (path: Array<string>) => {
  const filteredPath = path.filter((item) => item.length > 2);
  // in production, all names can be minified
  if (filteredPath.length === 0) {
    return path.at(-1) ?? 'Unknown';
  }
  // biome-ignore lint/style/noNonNullAssertion: invariant
  return filteredPath.at(-1)!;
};

export const getTotalTime = (
  timing: InteractionTiming | DroppedFramesTiming,
) => {
  switch (timing.kind) {
    case 'interaction': {
      const {
        renderTime,
        otherJSTime,
        framePreparation,
        frameConstruction,
        frameDraw,
      } = timing;
      return (
        renderTime +
        otherJSTime +
        framePreparation +
        frameConstruction +
        (frameDraw ?? 0)
      );
    }
    case 'dropped-frames': {
      return timing.otherTime + timing.renderTime;
    }
  }
};

export type DroppedFramesTiming = {
  kind: 'dropped-frames';
  renderTime: number;
  otherTime: number;
};
export type InteractionTiming = {
  kind: 'interaction';
  renderTime: number;
  otherJSTime: number;
  /** After JS, before paint. Things like layerize, css style recalcs */
  framePreparation: number;
  /** paint/commit. This is where the browser constructs the data structure that represents what will be drawn to screen */
  frameConstruction: number;
  /** GPU/compositing/rasterization. This is where, off the main thread, the data structure built is used to draw the next frame. This value is not available on safari due to lack of PerformanceEntry API */
  frameDraw: number | null;
};

export const isRenderMemoizable = (gropedFiberRender: GroupedFiberRender) => {
  return (
    gropedFiberRender.changes.context.length === 0 &&
    gropedFiberRender.changes.props.length === 0 &&
    gropedFiberRender.changes.state.length === 0
  );
};

export const getTimeSplit = (
  timing: DroppedFramesTiming | InteractionTiming,
) => {
  switch (timing.kind) {
    case 'dropped-frames': {
      return {
        render: timing.renderTime,
        other: timing.otherTime,
      };
    }
    case 'interaction': {
      return {
        render: timing.renderTime,
        other: getTotalTime(timing) + timing.renderTime,
      };
    }
  }
};

export type InteractionEvent = {
  kind: 'interaction';
  type: 'click' | 'keyboard';
  id: string;
  componentPath: Array<string>;
  groupedFiberRenders: Array<GroupedFiberRender>;
  timing: InteractionTiming;
  /** Not available in safari, and API used to get value is not stable on chrome */
  memory: number | null;
  timestamp: number;
};
export type DroppedFramesEvent = {
  kind: 'dropped-frames';
  id: string;
  groupedFiberRenders: Array<GroupedFiberRender>;
  timing: DroppedFramesTiming;
  /** Not available in safari, and API used to get value is not stable on chrome */
  memory: number | null;
  timestamp: number;
  fps: number;
};
export type NotificationEvent = InteractionEvent | DroppedFramesEvent;

export type NotificationsState = {
  events: Array<NotificationEvent>;
  // todo: discriminated union this all, i don't want to do it yet till i stabilize the data i need/ implement it all
  selectedEvent: NotificationEvent | null;
  filterBy: 'severity' | 'latest';
  selectedFiber: NotificationEvent['groupedFiberRenders'][number] | null;
  detailsExpanded: boolean;
  moreInfoExpanded: boolean;
  route:
    | 'render-visualization'
    | 'other-visualization'
    // | "render-guide"
    | 'render-explanation'
    // | "other-guide"
    | 'optimize';
  /**
   * Conceptually a synthetic query parameter
   */
  routeMessage: null | {
    kind: 'auto-open-overview-accordion';
    name:
      | 'other-not-javascript'
      | 'other-javascript'
      | 'render'
      | 'other-frame-drop';
  };
  audioNotificationsOptions:
    | {
        audioContext: null;
        enabled: false;
      }
    | {
        enabled: true;
        audioContext: AudioContext;
      };
};

export const getEventSeverity = (event: NotificationEvent) => {
  const totalTime = getTotalTime(event.timing);
  switch (event.kind) {
    case 'interaction': {
      if (totalTime < 200) return 'low';
      if (totalTime < 500) return 'needs-improvement';
      return 'high';
    }
    case 'dropped-frames': {
      if (totalTime < 50) return 'low';
      if (totalTime < HIGH_SEVERITY_FPS_DROP_TIME) return 'needs-improvement';
      return 'high';
    }
  }
};

export const getReadableSeverity = (
  severity: 'low' | 'needs-improvement' | 'high',
) => {
  switch (severity) {
    case 'high': {
      return 'Poor';
    }
    case 'needs-improvement': {
      return 'Laggy';
    }
    case 'low': {
      return 'Good';
    }
  }
};
export const NOTIFICATIONS_BORDER = '#27272A';
export const useNotificationsContext = () =>
  useContext(NotificationStateContext);

export const NotificationStateContext = createContext<{
  notificationState: NotificationsState;
  setNotificationState: Dispatch<SetStateAction<NotificationsState>>;
  setRoute: ({
    route,
    routeMessage,
  }: {
    route: NotificationsState['route'];
    routeMessage: NotificationsState['routeMessage'] | null;
  }) => void;
  // biome-ignore lint/style/noNonNullAssertion: we do not use default context values
}>(null!);
</file>

<file path="packages/scan/src/web/state.ts">
import { signal } from '@preact/signals';
import {
  LOCALSTORAGE_KEY,
  MIN_CONTAINER_WIDTH,
  MIN_SIZE,
  SAFE_AREA,
} from './constants';
import { IS_CLIENT } from './utils/constants';
import { readLocalStorage, saveLocalStorage } from './utils/helpers';
import type { Corner, WidgetConfig, WidgetSettings } from './widget/types';

export const signalIsSettingsOpen = /* @__PURE__ */ signal(false);
export const signalRefWidget = /* @__PURE__ */ signal<HTMLDivElement | null>(
  null,
);

export const defaultWidgetConfig = {
  corner: 'bottom-right' as Corner,
  dimensions: {
    isFullWidth: false,
    isFullHeight: false,
    width: MIN_SIZE.width,
    height: MIN_SIZE.height,
    position: { x: SAFE_AREA, y: SAFE_AREA },
  },
  lastDimensions: {
    isFullWidth: false,
    isFullHeight: false,
    width: MIN_SIZE.width,
    height: MIN_SIZE.height,
    position: { x: SAFE_AREA, y: SAFE_AREA },
  },
  componentsTree: {
    width: MIN_CONTAINER_WIDTH,
  },
} as WidgetConfig;

export const getInitialWidgetConfig = (): WidgetConfig => {
  const stored = readLocalStorage<WidgetSettings>(LOCALSTORAGE_KEY);
  if (!stored) {
    saveLocalStorage(LOCALSTORAGE_KEY, {
      corner: defaultWidgetConfig.corner,
      dimensions: defaultWidgetConfig.dimensions,
      lastDimensions: defaultWidgetConfig.lastDimensions,
      componentsTree: defaultWidgetConfig.componentsTree,
    });

    return defaultWidgetConfig;
  }

  return {
    corner: stored.corner ?? defaultWidgetConfig.corner,
    dimensions: {
      isFullWidth: false,
      isFullHeight: false,
      width: MIN_SIZE.width,
      height: MIN_SIZE.height,
      position:
        stored.dimensions.position ?? defaultWidgetConfig.dimensions.position,
    },
    lastDimensions: stored.dimensions ?? defaultWidgetConfig.dimensions,
    componentsTree: stored.componentsTree ?? defaultWidgetConfig.componentsTree,
  };
};

export const signalWidget = signal<WidgetConfig>(getInitialWidgetConfig());

export const updateDimensions = (): void => {
  if (!IS_CLIENT) return;

  const { dimensions } = signalWidget.value;
  const { width, height, position } = dimensions;

  signalWidget.value = {
    ...signalWidget.value,
    dimensions: {
      isFullWidth: width >= window.innerWidth - SAFE_AREA * 2,
      isFullHeight: height >= window.innerHeight - SAFE_AREA * 2,
      width,
      height,
      position,
    },
  };
};

export interface SlowDowns {
  slowDowns: number;
  hideNotification: boolean;
}

export type WidgetStates =
  | {
      view: 'none';
    }
  | {
      view: 'inspector';
      // extra params
    }
  // | {
  //     view: 'settings';
  //     // extra params
  //   }
  | {
      view: 'notifications';
      // extra params
    };
// | {
//     view: 'summary';
//     // extra params
//   };
export const signalWidgetViews = signal<WidgetStates>({
  view: 'none',
});
</file>

<file path="packages/scan/src/core/instrumentation.ts">
import { type Signal, signal } from '@preact/signals';
import {
  ClassComponentTag,
  type Fiber,
  type FiberRoot,
  ForwardRefTag,
  FunctionComponentTag,
  MemoComponentTag,
  type MemoizedState,
  SimpleMemoComponentTag,
  didFiberCommit,
  getDisplayName,
  getMutatedHostFibers,
  getTimings,
  getType,
  hasMemoCache,
  instrument,
  traverseContexts,
  traverseProps,
  traverseRenderedFibers,
} from 'bippy';
import { isValidElement } from 'preact';
import { isEqual } from '~core/utils';
import {
  RENDER_PHASE_STRING_TO_ENUM,
  type RenderPhase,
} from '~web/utils/outline';
import {
  collectContextChanges,
  collectPropsChanges,
  collectStateChanges,
} from '~web/views/inspector/timeline/utils';
import {
  type Change,
  type ContextChange,
  ReactScanInternals,
  type StateChange,
} from './index';

let fps = 0;
let lastTime = performance.now();
let frameCount = 0;
let initedFps = false;

const updateFPS = () => {
  frameCount++;
  const now = performance.now();
  if (now - lastTime >= 1000) {
    fps = frameCount;
    frameCount = 0;
    lastTime = now;
  }
  requestAnimationFrame(updateFPS);
};

export const getFPS = () => {
  if (!initedFps) {
    initedFps = true;
    updateFPS();
    fps = 60;
  }

  return fps;
};

export const isElementVisible = (el: Element) => {
  const style = window.getComputedStyle(el);
  return (
    style.display !== 'none' &&
    style.visibility !== 'hidden' &&
    style.contentVisibility !== 'hidden' &&
    style.opacity !== '0'
  );
};

export const isValueUnstable = (prevValue: unknown, nextValue: unknown) => {
  const prevValueString = fastSerialize(prevValue);
  const nextValueString = fastSerialize(nextValue);
  return (
    prevValueString === nextValueString &&
    unstableTypes.includes(typeof prevValue) &&
    unstableTypes.includes(typeof nextValue)
  );
};

export const isElementInViewport = (
  el: Element,
  rect = el.getBoundingClientRect(),
) => {
  const isVisible =
    rect.bottom > 0 &&
    rect.right > 0 &&
    rect.top < window.innerHeight &&
    rect.left < window.innerWidth;

  return isVisible && rect.width && rect.height;
};

export const enum ChangeReason {
  Props = 0b001,
  FunctionalState = 0b010,
  ClassState = 0b011,
  Context = 0b100,
}

export interface AggregatedChange {
  type: number; // union of AggregatedChangeReason
  unstable: boolean;
}

export interface Render {
  phase: RenderPhase;
  componentName: string | null;
  time: number | null;
  count: number;
  forget: boolean;
  changes: Array<Change>;
  unnecessary: boolean | null;
  didCommit: boolean;
  fps: number;
}

const unstableTypes = ['function', 'object'];

const cache = new WeakMap<object, string>();

export function fastSerialize(value: unknown, depth = 0): string {
  if (depth < 0) return '…';

  switch (typeof value) {
    case 'function':
      return value.toString();
    case 'string':
      return value;
    case 'number':
    case 'boolean':
    case 'undefined':
      return String(value);
    case 'object':
      break;
    default:
      return String(value);
  }

  if (value === null) return 'null';

  if (cache.has(value)) {
    const cached = cache.get(value);
    if (cached !== undefined) {
      return cached;
    }
  }

  if (Array.isArray(value)) {
    const str = value.length ? `[${value.length}]` : '[]';
    cache.set(value, str);
    return str;
  }

  if (isValidElement(value)) {
    const type = getDisplayName(value.type) ?? '';
    const propCount = value.props ? Object.keys(value.props).length : 0;
    const str = `<${type} ${propCount}>`;
    cache.set(value, str);
    return str;
  }

  if (Object.getPrototypeOf(value) === Object.prototype) {
    const keys = Object.keys(value);
    const str = keys.length ? `{${keys.length}}` : '{}';
    cache.set(value, str);
    return str;
  }

  const ctor =
    value && typeof value === 'object' ? value.constructor : undefined;
  if (ctor && typeof ctor === 'function' && ctor.name) {
    const str = `${ctor.name}{…}`;
    cache.set(value, str);
    return str;
  }

  const tagString = Object.prototype.toString.call(value).slice(8, -1);
  const str = `${tagString}{…}`;
  cache.set(value, str);
  return str;
}

export const getPropsChanges = (fiber: Fiber) => {
  const changes: Array<Change> = [];

  const prevProps = fiber.alternate?.memoizedProps || {};
  const nextProps = fiber.memoizedProps || {};

  const allKeys = new Set([
    ...Object.keys(prevProps),
    ...Object.keys(nextProps),
  ]);
  for (const propName in allKeys) {
    // const prevValue = prevProps?.[propName];
    const nextValue = nextProps?.[propName];

    const change: Change = {
      type: ChangeReason.Props,
      name: propName,
      value: nextValue,
    };
    changes.push(change);
  }

  return changes;
};

export const getStateChanges = (fiber: Fiber): StateChange[] => {
  if (!fiber) return [];
  const changes: StateChange[] = [];

  if (
    fiber.tag === FunctionComponentTag ||
    fiber.tag === ForwardRefTag ||
    fiber.tag === SimpleMemoComponentTag ||
    fiber.tag === MemoComponentTag
  ) {
    let memoizedState: MemoizedState | null = fiber.memoizedState;
    let prevState: MemoizedState | null | undefined =
      fiber.alternate?.memoizedState;
    let index = 0;

    while (memoizedState) {
      if (memoizedState.queue && memoizedState.memoizedState !== undefined) {
        const change: StateChange = {
          type: ChangeReason.FunctionalState,
          name: index.toString(),
          value: memoizedState.memoizedState,
          prevValue: prevState?.memoizedState,
        };
        if (!isEqual(change.prevValue, change.value)) {
          changes.push(change);
        }
      }
      memoizedState = memoizedState.next;
      prevState = prevState?.next;
      index++;
    }

    return changes;
  }

  if (fiber.tag === ClassComponentTag) {
    // when we have class component fiber, memoizedState is the component state
    const change: StateChange = {
      type: ChangeReason.ClassState,
      name: 'state',
      value: fiber.memoizedState,
      prevValue: fiber.alternate?.memoizedState,
    };
    if (!isEqual(change.prevValue, change.value)) {
      changes.push(change);
    }
    return changes;
  }

  return changes;
};
interface ContextFiber {
  context: unknown; // refers to Context<T>;
  memoizedValue: unknown;
}

let lastContextId = 0;
const contextIdMap = new WeakMap<ContextFiber, number>();
const getContextId = (contextFiber: ContextFiber) => {
  const existing = contextIdMap.get(contextFiber);
  if (existing) {
    return existing;
  }
  lastContextId++;
  contextIdMap.set(contextFiber, lastContextId);
  return lastContextId;
};

function getContextChangesTraversal(
  this: Array<Change>,
  nextValue: ContextFiber | null | undefined,
  prevValue: ContextFiber | null | undefined,
): void {
  if (!nextValue || !prevValue) return;
  // const prevMemoizedValue = prevValue.memoizedValue;
  const nextMemoizedValue = nextValue.memoizedValue;

  const change: ContextChange = {
    type: ChangeReason.Context,
    name:
      (nextValue.context as { displayName: string | undefined }).displayName ??
      'Context.Provider',
    value: nextMemoizedValue,
    contextType: getContextId(nextValue.context as ContextFiber),

    // unstable: false,
  };
  this.push(change);

  // const prevValueString = fastSerialize(prevMemoizedValue);
  // const nextValueString = fastSerialize(nextMemoizedValue);

  // if (
  //   unstableTypes.includes(typeof prevMemoizedValue) &&
  //   unstableTypes.includes(typeof nextMemoizedValue) &&
  //   prevValueString === nextValueString
  // ) {
  //   change.unstable = true;
  // }
}

export const getContextChanges = (fiber: Fiber) => {
  const changes: Array<ContextChange> = [];

  // Alexis: we use bind functions so that the compiler doesn't produce
  // any closures
  traverseContexts(fiber, getContextChangesTraversal.bind(changes));

  return changes;
};

type OnRenderHandler = (fiber: Fiber, renders: Array<Render>) => void;
type OnCommitStartHandler = () => void;
type OnCommitFinishHandler = () => void;
type OnErrorHandler = (error: unknown) => void;
type IsValidFiberHandler = (fiber: Fiber) => boolean;
type OnActiveHandler = () => void;

interface InstrumentationConfig {
  onCommitStart: OnCommitStartHandler;
  isValidFiber: IsValidFiberHandler;
  onRender: OnRenderHandler;
  onCommitFinish: OnCommitFinishHandler;
  onError: OnErrorHandler;
  onActive?: OnActiveHandler;
  onPostCommitFiberRoot: () => void;
  // monitoring does not need to track changes, and it adds overhead to leave it on
  trackChanges: boolean;
  // allows monitoring to continue tracking renders even if react scan dev mode is disabled
  forceAlwaysTrackRenders?: boolean;
}

interface InstrumentationInstance {
  key: string;
  config: InstrumentationConfig;
  instrumentation: Instrumentation;
}

interface Instrumentation {
  isPaused: Signal<boolean>;
  fiberRoots: WeakSet<FiberRoot>;
}

const instrumentationInstances = new Map<string, InstrumentationInstance>();
let inited = false;

const getAllInstances = () => Array.from(instrumentationInstances.values());

interface IsRenderUnnecessaryState {
  isRequiredChange: boolean;
}

function isRenderUnnecessaryTraversal(
  this: IsRenderUnnecessaryState,
  _propsName: string,
  prevValue: unknown,
  nextValue: unknown,
): void {
  if (
    !isEqual(prevValue, nextValue) &&
    !isValueUnstable(prevValue, nextValue)
  ) {
    this.isRequiredChange = true;
  }
}

// FIXME: calculation is slow
export const isRenderUnnecessary = (fiber: Fiber) => {
  if (!didFiberCommit(fiber)) return true;

  const mutatedHostFibers = getMutatedHostFibers(fiber);
  for (const mutatedHostFiber of mutatedHostFibers) {
    const state: IsRenderUnnecessaryState = {
      isRequiredChange: false,
    };
    traverseProps(mutatedHostFiber, isRenderUnnecessaryTraversal.bind(state));
    if (state.isRequiredChange) return false;
  }
  return true;
};

// // re-implement this in new-outlines
// const shouldRunUnnecessaryRenderCheck = () => {
//   // yes, this can be condensed into one conditional, but ifs are easier to reason/build on than long boolean expressions
//   if (!ReactScanInternals.options.value.trackUnnecessaryRenders) {
//     return false;
//   }

//   // only run unnecessaryRenderCheck when monitoring is active in production if the user set dangerouslyForceRunInProduction
//   if (
//     getIsProduction() &&
//     Store.monitor.value &&
//     ReactScanInternals.options.value.dangerouslyForceRunInProduction &&
//     ReactScanInternals.options.value.trackUnnecessaryRenders
//   ) {
//     return true;
//   }

//   if (getIsProduction() && Store.monitor.value) {
//     return false;
//   }

//   return ReactScanInternals.options.value.trackUnnecessaryRenders;
// };

const TRACK_UNNECESSARY_RENDERS = false;

export interface RenderData {
  selfTime: number;
  totalTime: number;
  renderCount: number;
  lastRenderTimestamp: number;
}

export interface OldRenderData {
  count: number;
  time: number;
  renders: Array<Render>;
  displayName: string | null;
  // biome-ignore lint/suspicious/noExplicitAny: temporary type hack cause im lazy
  type: any;
  // biome-ignore lint/suspicious/noExplicitAny: temporary type hack cause im lazy
  changes?: any;
}

const RENDER_DEBOUNCE_MS = 16;

export const renderDataMap = new WeakMap<object, RenderData>();

const trackRender = (
  type: unknown,
  fiberSelfTime: number,
  fiberTotalTime: number,
  hasChanges: boolean,
  hasDomMutations: boolean,
) => {
  const currentTimestamp = Date.now();
  const existingData = renderDataMap.get(type as object);

  if (
    (hasChanges || hasDomMutations) &&
    (!existingData ||
      currentTimestamp - (existingData.lastRenderTimestamp || 0) >
        RENDER_DEBOUNCE_MS)
  ) {
    const renderData: RenderData = existingData || {
      selfTime: 0,
      totalTime: 0,
      renderCount: 0,
      lastRenderTimestamp: currentTimestamp,
    };

    renderData.renderCount = (renderData.renderCount || 0) + 1;
    renderData.selfTime = fiberSelfTime || 0;
    renderData.totalTime = fiberTotalTime || 0;
    renderData.lastRenderTimestamp = currentTimestamp;

    renderDataMap.set(type as object, { ...renderData });
  }
};

export const createInstrumentation = (
  instanceKey: string,
  config: InstrumentationConfig,
) => {
  const instrumentation: Instrumentation = {
    // this will typically be false, but in cases where a user provides showToolbar: true, this will be true
    isPaused: signal(!ReactScanInternals.options.value.enabled),
    fiberRoots: new WeakSet<FiberRoot>(),
  };
  instrumentationInstances.set(instanceKey, {
    key: instanceKey,
    config,
    instrumentation,
  });
  if (!inited) {
    inited = true;

    instrument({
      name: 'react-scan',
      onActive: config.onActive,
      onCommitFiberRoot(_rendererID, root) {
        instrumentation.fiberRoots.add(root);
        // for now we always track everything for notifications, it may be worth it to make this configurable
        // if (
        //   ReactScanInternals.instrumentation?.isPaused.value &&
        //   (Store.inspectState.value.kind === "inspect-off" ||
        //     Store.inspectState.value.kind === "uninitialized") &&
        //   !config.forceAlwaysTrackRenders
        // ) {
        //   return;
        // }
        const allInstances = getAllInstances();
        for (const instance of allInstances) {
          instance.config.onCommitStart();
        }

        traverseRenderedFibers(
          root.current,
          (fiber: Fiber, phase: 'mount' | 'update' | 'unmount') => {
            const type = getType(fiber.type);
            if (!type) return null;

            const allInstances = getAllInstances();
            const validInstancesIndicies: Array<number> = [];
            for (let i = 0, len = allInstances.length; i < len; i++) {
              const instance = allInstances[i];
              if (!instance.config.isValidFiber(fiber)) continue;
              validInstancesIndicies.push(i);
            }
            if (!validInstancesIndicies.length) return null;

            const changes: Array<Change> = [];

            if (allInstances.some((instance) => instance.config.trackChanges)) {
              const changesProps = collectPropsChanges(fiber).changes;
              const changesState = collectStateChanges(fiber).changes;
              const changesContext = collectContextChanges(fiber).changes;

              changes.push.apply(
                null,
                changesProps.map(
                  (change) =>
                    ({
                      type: ChangeReason.Props,
                      name: change.name,
                      value: change.value,
                    }) as Change,
                ),
              );

              for (const change of changesState) {
                if (fiber.tag === ClassComponentTag) {
                  changes.push({
                    type: ChangeReason.ClassState,
                    name: change.name.toString(),
                    value: change.value,
                  } as Change);
                } else {
                  changes.push({
                    type: ChangeReason.FunctionalState,
                    name: change.name.toString(),
                    value: change.value,
                  } as Change);
                }
              }

              changes.push.apply(
                null,
                changesContext.map(
                  (change) =>
                    ({
                      type: ChangeReason.Context,
                      name: change.name,
                      value: change.value,
                      contextType: Number(change.contextType),
                    }) as Change,
                ),
              );
            }

            const { selfTime: fiberSelfTime, totalTime: fiberTotalTime } =
              getTimings(fiber);

            const fps = getFPS();
            const render: Render = {
              phase: RENDER_PHASE_STRING_TO_ENUM[phase],
              componentName: getDisplayName(type),
              count: 1,
              changes,
              time: fiberSelfTime,
              forget: hasMemoCache(fiber),
              // todo: allow this to be toggle-able through toolbar
              // todo: performance optimization: if the last fiber measure was very off screen, do not run isRenderUnnecessary
              unnecessary: TRACK_UNNECESSARY_RENDERS
                ? isRenderUnnecessary(fiber)
                : null,
              didCommit: didFiberCommit(fiber),
              fps,
            };

            // First, determine if this is a real render we should track
            const hasChanges = changes.length > 0;
            const hasDomMutations = getMutatedHostFibers(fiber).length > 0;

            if (phase === 'update') {
              trackRender(
                type,
                fiberSelfTime,
                fiberTotalTime,
                hasChanges,
                hasDomMutations,
              );
            }

            for (let i = 0, len = validInstancesIndicies.length; i < len; i++) {
              const index = validInstancesIndicies[i];
              const instance = allInstances[index];
              instance.config.onRender(fiber, [render]);
            }
          },
        );

        for (const instance of allInstances) {
          instance.config.onCommitFinish();
        }
      },
      onPostCommitFiberRoot() {
        const allInstances = getAllInstances();
        for (const instance of allInstances) {
          instance.config.onPostCommitFiberRoot();
        }
      },
    });
  }
  return instrumentation;
};
</file>

<file path="packages/scan/src/web/views/inspector/timeline/utils.ts">
import {
  ClassComponentTag,
  type ContextDependency,
  type Fiber,
  ForwardRefTag,
  FunctionComponentTag,
  MemoComponentTag,
  type MemoizedState,
  SimpleMemoComponentTag,
} from 'bippy';
import { isEqual } from '~core/utils';
import { getChangedPropsDetailed, isPromise } from '../utils';

interface ChangeTrackingInfo {
  count: number;
  currentValue: unknown;
  previousValue: unknown;
  lastUpdated: number;
}

type ChangeKey = string | number;

const propsTracker = new Map<string, ChangeTrackingInfo>();
const stateTracker = new Map<ChangeKey, ChangeTrackingInfo>();
const contextTracker = new Map<string, ChangeTrackingInfo>();
let lastComponentType: unknown = null;

const STATE_NAME_REGEX = /\[(?<name>\w+),\s*set\w+\]/g;
const PROPS_ORDER_REGEX = /\(\s*{\s*(?<props>[^}]+)\s*}\s*\)/;

export const getStateNames = (fiber: Fiber): Array<string> => {
  const componentSource = fiber.type?.toString?.() || '';
  return componentSource
    ? Array.from(
        componentSource.matchAll(STATE_NAME_REGEX),
        (m: RegExpMatchArray) => m.groups?.name ?? '',
      )
    : [];
};

export const resetTracking = () => {
  propsTracker.clear();
  stateTracker.clear();
  contextTracker.clear();
  lastComponentType = null;
};

export const isInitialComponentUpdate = (fiber: Fiber): boolean => {
  const isNewComponent = fiber.type !== lastComponentType;
  lastComponentType = fiber.type;
  return isNewComponent;
};

export const trackChange = (
  tracker: Map<ChangeKey, ChangeTrackingInfo>,
  key: ChangeKey,
  currentValue: unknown,
  previousValue: unknown,
): { hasChanged: boolean; count: number } => {
  const existing = tracker.get(key);
  const isInitialValue = tracker === propsTracker || tracker === contextTracker;
  const hasChanged = !isEqual(currentValue, previousValue);

  if (!existing) {
    // For props and context, start with count 1 if there's a change
    tracker.set(key, {
      count: hasChanged && isInitialValue ? 1 : 0,
      currentValue,
      previousValue,
      lastUpdated: Date.now(),
    });

    return {
      hasChanged,
      count: hasChanged && isInitialValue ? 1 : isInitialValue ? 0 : 1,
    };
  }

  if (!isEqual(existing.currentValue, currentValue)) {
    const newCount = existing.count + 1;
    tracker.set(key, {
      count: newCount,
      currentValue,
      previousValue: existing.currentValue,
      lastUpdated: Date.now(),
    });
    return { hasChanged: true, count: newCount };
  }

  return { hasChanged: false, count: existing.count };
};

export { propsTracker, stateTracker, contextTracker };

export interface SectionData {
  current: Array<{ name: string | number; value: unknown }>;
  changes: Set<string | number>;
  changesCounts: Map<string | number, number>;
}

export interface InspectorData {
  fiberProps: SectionData;
  fiberState: SectionData;
  fiberContext: SectionData;
}

export const getStateFromFiber = (
  fiber: Fiber,
): Record<string | number, unknown> => {
  if (!fiber) return {};

  if (
    fiber.tag === FunctionComponentTag ||
    fiber.tag === ForwardRefTag ||
    fiber.tag === SimpleMemoComponentTag ||
    fiber.tag === MemoComponentTag
  ) {
    let memoizedState: MemoizedState | null = fiber.memoizedState;
    const state: Record<number, unknown> = {};
    let index = 0;

    while (memoizedState) {
      if (memoizedState.queue && memoizedState.memoizedState !== undefined) {
        state[index] = memoizedState.memoizedState;
      }
      memoizedState = memoizedState.next;
      index++;
    }

    return state;
  }

  if (fiber.tag === ClassComponentTag) {
    return fiber.memoizedState || {};
  }

  return {};
};

/**
 * Used to preserve the order of the fiber's props as represented in source code
 */
export const getPropsOrder = (fiber: Fiber): Array<string> => {
  const componentSource = fiber.type?.toString?.() || '';
  const match = componentSource.match(PROPS_ORDER_REGEX);
  if (!match?.groups?.props) return [];

  return match.groups.props
    .split(',')
    .map((prop: string) => prop.trim().split(':')[0].split('=')[0].trim())
    .filter(Boolean);
};

export interface InspectorDataResult {
  data: InspectorData;
  shouldUpdate: boolean;
}

interface BaseChange {
  name: string | number;
  value: unknown;
  prevValue: unknown;
}

interface PropChange extends BaseChange {
  name: string;
}

interface StateChange extends BaseChange {
  name: string | number;
}

interface ContextChange extends BaseChange {
  name: string;
  contextType: unknown;
}

interface CollectorResult<T extends BaseChange = BaseChange> {
  current: Record<string | number, unknown>;
  prev: Record<string | number, unknown>;
  changes: Array<T>;
}

export const collectPropsChanges = (
  fiber: Fiber,
): CollectorResult<PropChange> => {
  const currentProps = fiber.memoizedProps || {};
  const prevProps = fiber.alternate?.memoizedProps || {};

  const current: Record<string, unknown> = {};
  const prev: Record<string, unknown> = {};

  const allProps = Object.keys(currentProps);
  for (const key of allProps) {
    if (key in currentProps) {
      current[key] = currentProps[key];
      prev[key] = prevProps[key];
    }
  }

  const changes = getChangedPropsDetailed(fiber).map((change) => ({
    name: change.name,
    value: change.value,
    prevValue: change.prevValue,
  }));

  return { current, prev, changes };
};

export const collectStateChanges = (
  fiber: Fiber,
): CollectorResult<StateChange> => {
  const current = getStateFromFiber(fiber);
  const prev = fiber.alternate ? getStateFromFiber(fiber.alternate) : {};
  const changes: Array<StateChange> = [];

  for (const [index, value] of Object.entries(current)) {
    const stateKey = fiber.tag === ClassComponentTag ? index : Number(index);
    if (fiber.alternate && !isEqual(prev[index], value)) {
      changes.push({
        name: stateKey,
        value,
        prevValue: prev[index],
      });
    }
  }

  return { current, prev, changes };
};

export const collectContextChanges = (
  fiber: Fiber,
): CollectorResult<ContextChange> => {
  const currentContexts = getAllFiberContexts(fiber);
  const prevContexts = fiber.alternate
    ? getAllFiberContexts(fiber.alternate)
    : new Map();

  const current: Record<string, unknown> = {};
  const prev: Record<string, unknown> = {};
  const changes: Array<ContextChange> = [];

  const seenContexts = new Set<unknown>();
  for (const [contextType, ctx] of currentContexts) {
    const name = ctx.displayName;
    const contextKey = contextType;

    if (seenContexts.has(contextKey)) continue;
    seenContexts.add(contextKey);

    current[name] = ctx.value;

    const prevCtx = prevContexts.get(contextType);
    if (prevCtx) {
      prev[name] = prevCtx.value;
      if (!isEqual(prevCtx.value, ctx.value)) {
        changes.push({
          name,
          value: ctx.value,
          prevValue: prevCtx.value,
          contextType,
        });
      }
    }
  }

  return { current, prev, changes };
};

export const collectInspectorData = (fiber: Fiber): InspectorDataResult => {
  const emptySection = (): SectionData => ({
    current: [],
    changes: new Set<string | number>(),
    changesCounts: new Map<string | number, number>(),
  });

  if (!fiber) {
    return {
      data: {
        fiberProps: emptySection(),
        fiberState: emptySection(),
        fiberContext: emptySection(),
      },
      shouldUpdate: false,
    };
  }

  let hasNewChanges = false;
  const isInitialUpdate = isInitialComponentUpdate(fiber);

  const propsData = emptySection();
  if (fiber.memoizedProps) {
    const { current, changes } = collectPropsChanges(fiber);

    for (const [key, value] of Object.entries(current)) {
      propsData.current.push({
        name: key,
        value: isPromise(value)
          ? { type: 'promise', displayValue: 'Promise' }
          : value,
      });
    }

    for (const change of changes) {
      const { hasChanged, count } = trackChange(
        propsTracker,
        change.name,
        change.value,
        change.prevValue,
      );

      if (hasChanged) {
        hasNewChanges = true;
        propsData.changes.add(change.name);
        propsData.changesCounts.set(change.name, count);
      }
    }
  }

  const stateData = emptySection();
  const { current: stateCurrent, changes: stateChanges } =
    collectStateChanges(fiber);

  for (const [index, value] of Object.entries(stateCurrent)) {
    const stateKey = fiber.tag === ClassComponentTag ? index : Number(index);
    stateData.current.push({ name: stateKey, value });
  }

  for (const change of stateChanges) {
    const { hasChanged, count } = trackChange(
      stateTracker,
      change.name,
      change.value,
      change.prevValue,
    );

    if (hasChanged) {
      hasNewChanges = true;
      stateData.changes.add(change.name);
      stateData.changesCounts.set(change.name, count);
    }
  }

  const contextData = emptySection();
  const { current: contextCurrent, changes: contextChanges } =
    collectContextChanges(fiber);

  for (const [name, value] of Object.entries(contextCurrent)) {
    contextData.current.push({ name, value });
  }

  if (!isInitialUpdate) {
    for (const change of contextChanges) {
      const { hasChanged, count } = trackChange(
        contextTracker,
        change.name,
        change.value,
        change.prevValue,
      );

      if (hasChanged) {
        hasNewChanges = true;
        contextData.changes.add(change.name);
        contextData.changesCounts.set(change.name, count);
      }
    }
  }

  if (!hasNewChanges && !isInitialUpdate) {
    propsData.changes.clear();
    stateData.changes.clear();
    contextData.changes.clear();
  }

  return {
    data: {
      fiberProps: propsData,
      fiberState: stateData,
      fiberContext: contextData,
    },
    shouldUpdate: hasNewChanges || isInitialUpdate,
  };
};

interface ContextInfo {
  value: unknown;
  displayName: string;
  contextType: unknown;
}
// hm we potentially want to revalidate this if a fiber has new context's, i'm not sure how we can do that reactively
// i suppose we can do one traversal on render (or during the existing traversal) that checks if any new context providers were mounted
// and when that happens we revalidate this cache

// i suppose a case this breaks is if a fiber changes ancestors through a key but doesn't remount
// then it would have new parents... and that new parent may have new context
// may be a fine trade off
// the motivation is this fiber traversal on every rendering fiber is extremely expensive
const fiberContextsCache = new WeakMap<Fiber, Map<unknown, ContextInfo>>();

export const getAllFiberContexts = (
  fiber: Fiber,
): Map<unknown, ContextInfo> => {
  if (!fiber) {
    return new Map<unknown, ContextInfo>();
  }

  // todo validate this works

  const cachedContexts = fiberContextsCache.get(fiber);
  if (cachedContexts) {
    return cachedContexts;
  }

  const contexts = new Map<unknown, ContextInfo>();
  let currentFiber: Fiber | null = fiber;

  while (currentFiber) {
    const dependencies = currentFiber.dependencies;

    if (dependencies?.firstContext) {
      let contextItem: ContextDependency<unknown> | null =
        dependencies.firstContext;

      while (contextItem) {
        const memoizedValue = contextItem.memoizedValue;
        const displayName = contextItem.context?.displayName;

        if (!contexts.has(memoizedValue)) {
          contexts.set(contextItem.context, {
            value: memoizedValue,
            displayName: displayName ?? 'UnnamedContext',
            contextType: null,
          });
        }

        if (contextItem === contextItem.next) {
          break;
        }

        contextItem = contextItem.next;
      }
    }

    currentFiber = currentFiber.return;
  }

  // Cache the result for this fiber
  fiberContextsCache.set(fiber, contexts);

  return contexts;
};

export const collectInspectorDataWithoutCounts = (fiber: Fiber) => {
  const emptySection = (): SectionData => ({
    current: [],
    changes: new Set<string | number>(),
    changesCounts: new Map<string | number, number>(),
  });

  if (!fiber) {
    return {
      fiberProps: emptySection(),
      fiberState: emptySection(),
      fiberContext: emptySection(),
    };
  }

  // let hasNewChanges = false;

  const propsData = emptySection();
  if (fiber.memoizedProps) {
    const { current, changes } = collectPropsChanges(fiber);

    for (const [key, value] of Object.entries(current)) {
      propsData.current.push({
        name: key,
        value: isPromise(value)
          ? { type: 'promise', displayValue: 'Promise' }
          : value,
      });
    }

    for (const change of changes) {
      // hasNewChanges = true;
      propsData.changes.add(change.name);
      propsData.changesCounts.set(change.name, 1);
    }
  }

  const stateData = emptySection();
  if (fiber.memoizedState) {
    const { current, changes } = collectStateChanges(fiber);

    for (const [key, value] of Object.entries(current)) {
      stateData.current.push({
        name: key,
        value: isPromise(value)
          ? { type: 'promise', displayValue: 'Promise' }
          : value,
      });
    }

    for (const change of changes) {
      // hasNewChanges = true;
      stateData.changes.add(change.name);
      stateData.changesCounts.set(change.name, 1);
    }
  }

  const contextData = emptySection();
  const { current, changes } = collectContextChanges(fiber);

  for (const [key, value] of Object.entries(current)) {
    contextData.current.push({
      name: key,
      value: isPromise(value)
        ? { type: 'promise', displayValue: 'Promise' }
        : value,
    });
  }

  for (const change of changes) {
    // hasNewChanges = true;
    contextData.changes.add(change.name);
    contextData.changesCounts.set(change.name, 1);
  }
  // todo: is isInitialUpdate correct? Is this necessary:
  // if (!hasNewChanges && !isInitialUpdate) {
  //   propsData.changes.clear();
  //   stateData.changes.clear();
  //   contextData.changes.clear();
  // }

  return {
    // data: {
    fiberProps: propsData,
    fiberState: stateData,
    fiberContext: contextData,
    // },
  };
};
</file>

<file path="packages/scan/src/core/notifications/event-tracking.ts">
import { useSyncExternalStore } from 'preact/compat';
import { not_globally_unique_generateId } from '~core/monitor/utils';
import { MAX_INTERACTION_BATCH, interactionStore } from './interaction-store';
import {
  FiberRenders,
  PerformanceEntryChannelEvent,
  TimeoutStage,
  listenForPerformanceEntryInteractions,
  listenForRenders,
  setupDetailedPointerTimingListener,
  setupPerformancePublisher,
} from './performance';
import {
  MAX_CHANNEL_SIZE,
  performanceEntryChannels,
} from './performance-store';
import { BoundedArray } from './performance-utils';
import { createStore } from '~web/utils/create-store';

let profileListeners: Array<(interaction: FinalInteraction) => void> = [];

type FinalInteraction = {
  detailedTiming: TimeoutStage;
  latency: number;
  completedAt: number;
};

export const listenForProfile = (
  listener: (interaction: FinalInteraction) => void,
) => {
  profileListeners.push(listener);

  return () => {
    profileListeners = profileListeners.filter(
      (existingListener) => existingListener !== listener,
    );
  };
};

export let interactionStatus:
  | { kind: 'started'; startedAt: number }
  | { kind: 'completed'; startedAt: number; endedAt: number }
  | { kind: 'no-interaction' } = {
  kind: 'no-interaction',
};

type NewInteractionStoreState = {
  /**
   * problem definition: we need to store bounds but how do we handle uninitialized bounds
   *
   * i guess what we said before, we just have one active bounds and that's all that matters chat
   */

  startAt: number;
  endAt: number;
};

export const interactionStatusStore: {
  state: NewInteractionStoreState | null;
  listeners: Array<(state: NewInteractionStoreState) => void>;
  addListener: (cb: (state: NewInteractionStoreState) => void) => () => void;
} = {
  state: null,
  addListener: (cb) => {
    interactionStatusStore.listeners.push(cb);
    return () => {
      interactionStatusStore.listeners =
        interactionStatusStore.listeners.filter((l) => l !== cb);
    };
  },
  listeners: [],
};

let accumulatedFiberRendersOverTask: null | FiberRenders = null;
type InteractionEvent = {
  kind: 'interaction';
  data: {
    startAt: number;
    endAt: number;
    meta: {
      detailedTiming: TimeoutStage;
      latency: number;
      kind: PerformanceEntryChannelEvent['kind'];
    };
  };
};

type LongRenderPipeline = {
  kind: 'long-render';
  data: {
    startAt: number;
    endAt: number;
    meta: {
      latency: number;
      fiberRenders: FiberRenders;
      fps: number;
    };
  };
};

export type SlowdownEvent = (InteractionEvent | LongRenderPipeline) & {
  id: string;
};

type ToolbarEventStoreState = {
  state: {
    events: Array<SlowdownEvent>;
  };
  actions: {
    addEvent: (event: SlowdownEvent) => void;
    addListener: (listener: (event: SlowdownEvent) => void) => () => void;
    clear: () => void;
  };
};

type DebugEvent = {
  kind: string;
  at: number;
  meta?: unknown;
};
export const debugEventStore = createStore<{
  state: {
    events: Array<DebugEvent>;
  };
  actions: {
    // biome-ignore lint/suspicious/noExplicitAny: debug only store
    addEvent: (event: any) => void;
    clear: () => void;
  };
}>()((set) => ({
  state: {
    events: [],
  },
  actions: {
    addEvent: (event: DebugEvent) => {
      set((store) => ({
        state: {
          events: [...store.state.events, event],
        },
      }));
    },
    clear: () => {
      set({
        state: {
          events: [],
        },
      });
    },
  },
}));

export const toolbarEventStore = createStore<ToolbarEventStoreState>()(
  (set, get) => {
    const listeners = new Set<(event: SlowdownEvent) => void>();

    return {
      state: {
        events: [],
      },

      actions: {
        addEvent: (event: SlowdownEvent) => {
          listeners.forEach((listener) => listener(event));

          const events = [...get().state.events, event];
          const applyOverlapCheckToLongRenderEvent = (
            longRenderEvent: LongRenderPipeline & { id: string },
            onOverlap: (
              overlapsWith: InteractionEvent & { id: string },
            ) => void,
          ) => {
            const overlapsWith = events.find((event) => {
              if (event.kind === 'long-render') {
                return;
              }

              if (event.id === longRenderEvent.id) {
                return;
              }

              /**
               * |---x-----------x------ (interaction)
               * |x-----------x          (long-render)
               */

              if (
                longRenderEvent.data.startAt <= event.data.startAt &&
                longRenderEvent.data.endAt <= event.data.endAt &&
                longRenderEvent.data.endAt >= event.data.startAt
              ) {
                return true;
              }

              /**
             * |x-----------x---- (interaction)
             * |--x------------x  (long-render)
             *

             */

              if (
                event.data.startAt <= longRenderEvent.data.startAt &&
                event.data.endAt >= longRenderEvent.data.startAt
              ) {
                return true;
              }

              /**
               *
               * |--x-------------x    (interaction)
               * |x------------------x (long-render)
               *
               */

              if (
                longRenderEvent.data.startAt <= event.data.startAt &&
                longRenderEvent.data.endAt >= event.data.endAt
              ) {
                return true;
              }
            }) as undefined | (InteractionEvent & { id: string }); // invariant: because we early check the typechecker does not know it must be the case that when it finds something, it will be an interaction it overlaps with

            if (overlapsWith) {
              onOverlap(overlapsWith);
            }
          };

          const toRemove = new Set<string>();

          events.forEach((event) => {
            if (event.kind === 'interaction') return;
            applyOverlapCheckToLongRenderEvent(event, () => {
              toRemove.add(event.id);
            });
          });

          const withRemovedEvents = events.filter(
            (event) => !toRemove.has(event.id),
          );

          set(() => ({
            state: {
              events: withRemovedEvents,
            },
          }));
        },

        addListener: (listener: (event: SlowdownEvent) => void) => {
          listeners.add(listener);
          return () => {
            listeners.delete(listener);
          };
        },

        clear: () => {
          set({
            state: {
              events: [],
            },
          });
        },
      },
    };
  },
);

export const useToolbarEventLog = () => {
  return useSyncExternalStore(
    toolbarEventStore.subscribe,
    toolbarEventStore.getState,
  );
};

let taskDirtyAt: null | number = null;
let taskDirtyOrigin: null | number = null;

let previousTrackCurrentMouseOverElementCallback:
  | ((e: MouseEvent) => void)
  | null = null;

let overToolbar: boolean | null;

const trackCurrentMouseOverToolbar = () => {
  const callback = (e: MouseEvent) => {
    overToolbar = e
      .composedPath()
      .map((path) => (path as Element).id)
      .filter(Boolean)
      .includes('react-scan-toolbar');
  };

  document.addEventListener('mouseover', callback);
  previousTrackCurrentMouseOverElementCallback = callback;

  return () => {
    if (previousTrackCurrentMouseOverElementCallback) {
      document.removeEventListener(
        'mouseover',
        previousTrackCurrentMouseOverElementCallback,
      );
    }
  };
};

// stops long tasks b/c backgrounded from being reported
export const startDirtyTaskTracking = () => {
  const onVisibilityChange = () => {
    taskDirtyAt = performance.now();
    taskDirtyOrigin = performance.timeOrigin;
  };

  document.addEventListener('visibilitychange', onVisibilityChange);

  return () => {
    document.removeEventListener('visibilitychange', onVisibilityChange);
  };
};

export const HIGH_SEVERITY_FPS_DROP_TIME = 150;

let framesDrawnInTheLastSecond: Array<number> = [];

export function startLongPipelineTracking() {
  let rafHandle: number;
  let timeoutHandle: ReturnType<typeof setTimeout>;

  function measure() {
    let unSub: (() => void) | null = null;
    accumulatedFiberRendersOverTask = null;
    accumulatedFiberRendersOverTask = {};
    unSub = listenForRenders(accumulatedFiberRendersOverTask);
    const startOrigin = performance.timeOrigin;
    const startTime = performance.now();
    rafHandle = requestAnimationFrame(() => {
      // very low overhead, on the order of dozens of microseconds to run
      timeoutHandle = setTimeout(() => {
        const endNow = performance.now();
        const duration = endNow - startTime;
        const endOrigin = performance.timeOrigin;
        framesDrawnInTheLastSecond.push(endNow + endOrigin);

        const framesInTheLastSecond = framesDrawnInTheLastSecond.filter(
          (frameAt) => endNow + endOrigin - frameAt <= 1000,
        );

        const fps = framesInTheLastSecond.length;
        framesDrawnInTheLastSecond = framesInTheLastSecond;

        const taskConsideredDirty =
          taskDirtyAt !== null && taskDirtyOrigin !== null
            ? endNow + endOrigin - (taskDirtyOrigin + taskDirtyAt) < 100
            : null;
        // not useful to report slowdowns caused by things like outlines (can get expensive not fully optimized)
        const wasTaskInfluencedByToolbar = overToolbar !== null && overToolbar;

        if (
          duration > HIGH_SEVERITY_FPS_DROP_TIME &&
          !taskConsideredDirty &&
          document.visibilityState === 'visible' &&
          !wasTaskInfluencedByToolbar
        ) {
          const endAt = endOrigin + endNow;
          const startAt = startTime + startOrigin;

          toolbarEventStore.getState().actions.addEvent({
            kind: 'long-render',
            id: not_globally_unique_generateId(),
            data: {
              endAt: endAt,
              startAt: startAt,
              meta: {
                // biome-ignore lint/style/noNonNullAssertion: invariant: this will exist by this point
                fiberRenders: accumulatedFiberRendersOverTask!,
                latency: duration,
                fps,
              },
            },
          });
        }

        taskDirtyAt = null;
        taskDirtyOrigin = null;

        unSub?.();
        measure();
      }, 0);
    });
    return unSub;
  }

  const measureUnSub = measure();

  return () => {
    measureUnSub();
    cancelAnimationFrame(rafHandle);
    clearTimeout(timeoutHandle);
  };
}
export const startTimingTracking = () => {
  const unSubPerformance = setupPerformancePublisher();
  const unSubMouseOver = trackCurrentMouseOverToolbar();
  const unSubDirtyTaskTracking = startDirtyTaskTracking();
  const unSubLongPipelineTracking = startLongPipelineTracking();

  const onComplete = async (
    _: string,
    finalInteraction: FinalInteraction,
    event: PerformanceEntryChannelEvent,
  ) => {
    toolbarEventStore.getState().actions.addEvent({
      kind: 'interaction',
      id: not_globally_unique_generateId(),
      data: {
        startAt: finalInteraction.detailedTiming.blockingTimeStart,
        endAt: performance.now() + performance.timeOrigin,
        meta: { ...finalInteraction, kind: event.kind }, // TODO, will need interaction specific metadata here
      },
    });

    const existingCompletedInteractions =
      performanceEntryChannels.getChannelState('recording');

    finalInteraction.detailedTiming.stopListeningForRenders();

    if (existingCompletedInteractions.length) {
      // then performance entry and our detailed timing handlers are out of sync, we disregard that entry
      // it may be possible the performance entry returned before detailed timing. If that's the case we should update
      // assumptions and deal with mapping the entry back to the detailed timing here
      performanceEntryChannels.updateChannelState(
        'recording',
        () => new BoundedArray(MAX_CHANNEL_SIZE),
      );
    }
  };
  const unSubDetailedPointerTiming = setupDetailedPointerTimingListener(
    'pointer',
    {
      onComplete,
    },
  );
  const unSubDetailedKeyboardTiming = setupDetailedPointerTimingListener(
    'keyboard',
    {
      onComplete,
    },
  );

  const unSubInteractions = listenForPerformanceEntryInteractions(
    (completedInteraction) => {
      interactionStore.setState(
        BoundedArray.fromArray(
          interactionStore.getCurrentState().concat(completedInteraction),
          MAX_INTERACTION_BATCH,
        ),
      );
    },
  );

  return () => {
    unSubMouseOver();
    unSubDirtyTaskTracking();
    unSubLongPipelineTracking();
    unSubPerformance();
    unSubDetailedPointerTiming();
    unSubInteractions();
    unSubDetailedKeyboardTiming();
  };
};
</file>

<file path="packages/scan/src/core/index.ts">
import { type Signal, signal } from '@preact/signals';
import {
  type Fiber,
  type FiberRoot,
  detectReactBuildType,
  getRDTHook,
  getType,
  isInstrumentationActive,
} from 'bippy';
import type { ComponentType } from 'preact';
import type { ReactNode } from 'preact/compat';
import type { RenderData } from 'src/core/utils';
import { initReactScanInstrumentation } from 'src/new-outlines';
import styles from '~web/assets/css/styles.css';
import { createToolbar } from '~web/toolbar';
import { IS_CLIENT } from '~web/utils/constants';
import { readLocalStorage, saveLocalStorage } from '~web/utils/helpers';
import type { Outline } from '~web/utils/outline';
import type { States } from '~web/views/inspector/utils';
import type {
  ChangeReason,
  Render,
  createInstrumentation,
} from './instrumentation';
import type { InternalInteraction } from './monitor/types';
import type { getSession } from './monitor/utils';
import { startTimingTracking } from './notifications/event-tracking';
import { createHighlightCanvas } from './notifications/outline-overlay';
import packageJson from '../../package.json';
// --- Import html-to-image ---
import * as htmlToImage from '../html-to-image';
import type { Options as HtmlToImageOptions } from '../html-to-image';
import { getPixelRatio } from '../html-to-image/util';
// --- END: Ensure necessary imports ---

// --- START: Helper function to load image data URLs ---
const loadImage = (url: string): Promise<HTMLImageElement> => {
  return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = (err) => {
          console.error(`[React Scan Iframe] Failed to load image data URL: ${url.substring(0,100)}...`);
          reject(err);
      };
      img.src = url;
  });
};
// --- END: Helper function ---


// --- START: Helper function to find visible fixed/sticky elements ---
interface FixedStickyElementInfo {
  element: HTMLElement;
  rect: DOMRect; // Viewport relative position
}

const findVisibleFixedStickyElements = (): FixedStickyElementInfo[] => {
  const elements: FixedStickyElementInfo[] = [];
  // Query all elements - consider performance implications if the DOM is huge.
  // Optimizations could involve querying only elements potentially having fixed/sticky styles
  // or listening to specific mutation observers, but querySelectorAll is simpler for now.
  const allElementsNodeList = document.querySelectorAll('*');
  const viewportWidth = document.documentElement.clientWidth;
  const viewportHeight = document.documentElement.clientHeight;

  // Correct: Convert NodeList to Array before iterating with for...of
  const allElementsArray = Array.from(allElementsNodeList);

  for (const element of allElementsArray) { // Iterate over the converted array
      if (!(element instanceof HTMLElement)) continue;

      const style = window.getComputedStyle(element);
      const position = style.position;
      const isFixedOrSticky = position === 'fixed' || position === 'sticky';

      if (!isFixedOrSticky) continue;

      const rect = element.getBoundingClientRect();

      // Basic visibility checks
      const isVisible =
          style.display !== 'none' &&
          style.visibility !== 'hidden' &&
          style.opacity !== '0' &&
          rect.width > 0 &&
          rect.height > 0;

      if (!isVisible) continue;

      // Check if it overlaps with the viewport
      const isInViewport =
          rect.bottom > 0 &&
          rect.right > 0 &&
          rect.top < viewportHeight &&
          rect.left < viewportWidth;

      if (isInViewport) {
          elements.push({ element, rect });
      }
  }
  return elements;
};
// --- END: Helper function ---


// --- Global State and Types (Original - unchanged) ---
let rootContainer: HTMLDivElement | null = null;
let shadowRoot: ShadowRoot | null = null;

interface RootContainer {
  rootContainer: HTMLDivElement;
  shadowRoot: ShadowRoot;
}

const initRootContainer = (): RootContainer => {
  if (rootContainer && shadowRoot) {
    return { rootContainer, shadowRoot };
  }

  rootContainer = document.createElement('div');
  rootContainer.id = 'react-scan-root'; // Keep this ID for potential filtering

  shadowRoot = rootContainer.attachShadow({ mode: 'open' });

  rootContainer.style.setProperty('display', 'none', 'important');

  const cssStyles = document.createElement('style');
  cssStyles.textContent = styles;

  shadowRoot.appendChild(cssStyles);

  document.documentElement.appendChild(rootContainer);

  return { rootContainer, shadowRoot };
};

export interface Options {
  enabled?: boolean;
  dangerouslyForceRunInProduction?: boolean;
  log?: boolean;
  showToolbar?: boolean;
  animationSpeed?: 'slow' | 'fast' | 'off';
  trackUnnecessaryRenders?: boolean;
  showFPS?: boolean;
  showNotificationCount?: boolean;
  _debug?: 'verbose' | false;
  onCommitStart?: () => void;
  onRender?: (fiber: Fiber, renders: Array<Render>) => void;
  onCommitFinish?: () => void;
  onPaintStart?: (outlines: Array<Outline>) => void;
  onPaintFinish?: (outlines: Array<Outline>) => void;
}

export type MonitoringOptions = Pick<
  Options,
  | 'enabled'
  | 'onCommitStart'
  | 'onCommitFinish'
  | 'onPaintStart'
  | 'onPaintFinish'
  | 'onRender'
>;

interface Monitor {
  pendingRequests: number;
  interactions: Array<InternalInteraction>;
  session: ReturnType<typeof getSession>;
  url: string | null;
  route: string | null;
  apiKey: string | null;
  commit: string | null;
  branch: string | null;
}

export interface StoreType {
  inspectState: Signal<States>;
  wasDetailsOpen: Signal<boolean>;
  lastReportTime: Signal<number>;
  isInIframe: Signal<boolean>;
  monitor: Signal<Monitor | null>;
  fiberRoots: WeakSet<Fiber>; // Changed from Set to WeakSet
  reportData: Map<number, RenderData>;
  legacyReportData: Map<string, RenderData>; // Consider removing if legacy not needed
  changesListeners: Map<number, Array<ChangesListener>>;
  interactionListeningForRenders:
    | ((fiber: Fiber, renders: Array<Render>) => void)
    | null;
}

export type OutlineKey = `${string}-${string}`;

export interface Internals {
  instrumentation: ReturnType<typeof createInstrumentation> | null;
  componentAllowList: WeakMap<ComponentType<unknown>, Options> | null;
  options: Signal<Options>;
  scheduledOutlines: Map<Fiber, Outline>;
  activeOutlines: Map<OutlineKey, Outline>;
  onRender: ((fiber: Fiber, renders: Array<Render>) => void) | null;
  Store: StoreType;
  version: string;
}

export type FunctionalComponentStateChange = {
  type: ChangeReason.FunctionalState;
  value: unknown;
  prevValue?: unknown;
  count?: number | undefined;
  name: string;
};
export type ClassComponentStateChange = {
  type: ChangeReason.ClassState;
  value: unknown;
  prevValue?: unknown;
  count?: number | undefined;
  name: 'state';
};

export type StateChange =
  | FunctionalComponentStateChange
  | ClassComponentStateChange;
export type PropsChange = {
  type: ChangeReason.Props;
  name: string;
  value: unknown;
  prevValue?: unknown;
  count?: number | undefined;
};
export type ContextChange = {
  type: ChangeReason.Context;
  name: string;
  value: unknown;
  prevValue?: unknown;
  count?: number | undefined;
  contextType: number;
};

export type Change = StateChange | PropsChange | ContextChange;

export type ChangesPayload = {
  propsChanges: Array<PropsChange>;
  stateChanges: Array<
    FunctionalComponentStateChange | ClassComponentStateChange
  >;
  contextChanges: Array<ContextChange>;
};
export type ChangesListener = (changes: ChangesPayload) => void;

export const Store: StoreType = {
  wasDetailsOpen: signal(true),
  isInIframe: signal(IS_CLIENT && window.self !== window.top),
  inspectState: signal<States>({
    kind: 'uninitialized',
  }),
  monitor: signal<Monitor | null>(null),
  fiberRoots: new WeakSet<Fiber>(), // Use WeakSet
  reportData: new Map<number, RenderData>(),
  legacyReportData: new Map<string, RenderData>(),
  lastReportTime: signal(0),
  interactionListeningForRenders: null,
  changesListeners: new Map(),
};

export const ReactScanInternals: Internals = {
  instrumentation: null,
  componentAllowList: null,
  options: signal({
    enabled: true,
    log: false,
    showToolbar: true,
    animationSpeed: 'fast',
    dangerouslyForceRunInProduction: false,
    showFPS: true,
    showNotificationCount: true,
  }),
  onRender: null,
  scheduledOutlines: new Map(),
  activeOutlines: new Map(),
  Store,
  version: packageJson.version,
};

if (IS_CLIENT && window.__REACT_SCAN_EXTENSION__) {
  window.__REACT_SCAN_VERSION__ = ReactScanInternals.version;
}

export type LocalStorageOptions = Omit<
  Options,
  | 'onCommitStart'
  | 'onRender'
  | 'onCommitFinish'
  | 'onPaintStart'
  | 'onPaintFinish'
>;

// --- START: MODIFIED CODE for postMessage Communication ---

/**
 * Scans the iframe's DOM for all elements with the 'data-sourcefile' attribute
 * and returns a list of unique file paths found.
 * @returns {string[]} An array of unique source file paths.
 */
const findAllSourceFiles = (): string[] => {
    if (!IS_CLIENT) return [];
    const fileSet = new Set<string>();
    const elementsWithSourceFile = document.querySelectorAll('[data-sourcefile]');
    elementsWithSourceFile.forEach((element) => {
        const sourceFile = (element as HTMLElement).dataset.sourcefile;
        if (sourceFile) {
            fileSet.add(sourceFile);
        }
    });
    return Array.from(fileSet);
};


/**
 * Handles incoming messages from the parent window.
 * Handles requests for file lists, iframe URL, and page screenshots.
 * @param {MessageEvent} event - The message event object.
 */
const handleParentMessage = async (event: MessageEvent) => {
    const PARENT_ORIGIN = '*'; // WARNING: Use specific origin in production!

    if (PARENT_ORIGIN !== '*' && event.origin !== PARENT_ORIGIN) {
        console.warn(`[React Scan Iframe] Ignoring message from untrusted origin: ${event.origin}`);
        return;
    }

    const request = event.data;

    if (!request || !request.type) {
        console.warn('[React Scan Iframe] Received invalid message:', event.data);
        return;
    }

    // --- Handle File List Request ---
    if (request.type === 'REQUEST_FILE_LIST') {
        console.log('[React Scan Iframe] Received REQUEST_FILE_LIST from parent.');
        const files = findAllSourceFiles();
        window.parent.postMessage({
            type: 'FILE_LIST_RESPONSE',
            payload: { files: files },
            requestId: request.requestId,
        }, PARENT_ORIGIN);
        console.log('[React Scan Iframe] Sent FILE_LIST_RESPONSE to parent:', files);
    }
    // --- Handle URL Request ---
    else if (request.type === 'REQUEST_IFRAME_URL') {
        console.log('[React Scan Iframe] Received REQUEST_IFRAME_URL from parent.');
        const currentUrl = window.location.href;
        window.parent.postMessage({
            type: 'IFRAME_URL_RESPONSE',
            payload: { url: currentUrl },
            requestId: request.requestId,
        }, PARENT_ORIGIN);
        console.log('[React Scan Iframe] Sent IFRAME_URL_RESPONSE to parent:', currentUrl);
    }
    // --- START: Handle Screenshot Request (Adjust Fixed Elements & Crop) ---
    else if (request.type === 'REQUEST_PAGE_SCREENSHOT') {
      // console.log('[React Scan Iframe] Received REQUEST_PAGE_SCREENSHOT (Visible + Fixed/Sticky + DPR) from parent.');
      try {
          const body = document.body;
          const documentElement = document.documentElement;

          // 1. Get viewport dimensions, scroll offsets, and pixel ratio
          const viewportWidth = documentElement.clientWidth;
          const viewportHeight = documentElement.clientHeight;
          const scrollLeft = documentElement.scrollLeft || body.scrollLeft;
          const scrollTop = documentElement.scrollTop || body.scrollTop;
          const pixelRatio = getPixelRatio(); // Get device pixel ratio

          // console.log(`[React Scan Iframe] Capture details: VpW=${viewportWidth}, VpH=${viewportHeight}, ScrollX=${scrollLeft}, ScrollY=${scrollTop}, DPR=${pixelRatio}`);

          // 2. Capture the main scrollable content (background layer) with pixel ratio
          const mainContentOptions: HtmlToImageOptions = {
              width: viewportWidth,
              height: viewportHeight,
              pixelRatio: pixelRatio, // Apply pixel ratio
              backgroundColor: '#ffffff',
              style: {
                  transform: `translate(-${scrollLeft}px, -${scrollTop}px)`,
                  width: `${Math.max(body.scrollWidth, documentElement.scrollWidth)}px`,
                  height: `${Math.max(body.scrollHeight, documentElement.scrollHeight)}px`,
                  margin: '0', padding: '0',
              },
          };
          const mainContentDataUrl = await htmlToImage.toPng(body, mainContentOptions);

          // 3. Identify visible fixed/sticky elements
          const fixedStickyElements = findVisibleFixedStickyElements();

          // 4. Capture each fixed/sticky element individually with pixel ratio
          const fixedStickyCaptures = await Promise.allSettled(
              fixedStickyElements.map(async ({ element, rect }) => {
                  try {
                      const elementOptions: HtmlToImageOptions = {
                          width: Math.ceil(rect.width),
                          height: Math.ceil(rect.height),
                          pixelRatio: pixelRatio, // Apply pixel ratio
                          backgroundColor: undefined, // Transparent background
                          style: { margin: '0', padding: '0' }
                      };
                      const dataUrl = await htmlToImage.toPng(element, elementOptions);
                      return { element, rect, dataUrl };
                  } catch (captureError) {
                      console.warn(`[React Scan Iframe] Failed to capture fixed/sticky element:`, element, captureError);
                      return null;
                  }
              })
          );

          // 5. Combine captures onto a final canvas (scaled by pixel ratio)
          const finalCanvas = document.createElement('canvas');
          // Set canvas physical dimensions (higher resolution)
          finalCanvas.width = viewportWidth * pixelRatio;
          finalCanvas.height = viewportHeight * pixelRatio;
          const ctx = finalCanvas.getContext('2d');

          if (!ctx) {
              throw new Error("Failed to get 2D context for final canvas");
          }

          // Draw the main content first (drawImage scales based on source image dimensions)
          try {
              const mainImage = await loadImage(mainContentDataUrl);
               // Ensure drawing covers the full scaled canvas
              ctx.drawImage(mainImage, 0, 0, finalCanvas.width, finalCanvas.height);
          } catch (e) {
               console.error("[React Scan Iframe] Failed to load main content image", e);
               ctx.fillStyle = '#cccccc'; // Example fallback
               ctx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
          }

          // Draw fixed/sticky elements on top, scaling positions and dimensions
          for (const result of fixedStickyCaptures) {
              if (result.status === 'fulfilled' && result.value) {
                  const { rect, dataUrl } = result.value;
                  try {
                      const fixedStickyImage = await loadImage(dataUrl);
                      // Scale draw position and size by pixelRatio
                      ctx.drawImage(
                          fixedStickyImage,
                          rect.left * pixelRatio,    // Scaled X position
                          rect.top * pixelRatio,     // Scaled Y position
                          rect.width * pixelRatio,   // Scaled width
                          rect.height * pixelRatio   // Scaled height
                      );
                  } catch (e) {
                      console.warn(`[React Scan Iframe] Failed to load or draw fixed/sticky image:`, result.value.element, e);
                  }
              }
          }

          // 6. Get final data URL (now high-resolution) and send response
          const finalDataUrl = finalCanvas.toDataURL('image/png');
          window.parent.postMessage({
              type: 'PAGE_SCREENSHOT_RESPONSE',
              payload: { dataUrl: finalDataUrl },
              requestId: request.requestId,
          }, PARENT_ORIGIN);
          // console.log('[React Scan Iframe] Sent PAGE_SCREENSHOT_RESPONSE (Visible + Fixed/Sticky + DPR) to parent.');

      } catch (error) {
          console.error('[React Scan Iframe] Error capturing composite page screenshot:', error);
          let errorMessage = 'Failed to capture composite page screenshot.';
          if (error instanceof Error) {
              errorMessage += ` Reason: ${error.message}`;
          }
          window.parent.postMessage({
              type: 'PAGE_SCREENSHOT_RESPONSE',
              error: errorMessage,
              requestId: request.requestId,
          }, PARENT_ORIGIN);
      }
  }
    // --- END: Handle Screenshot Request (Adjust Fixed Elements & Crop) ---
};


let messageListenerAdded = false;

const addMessageListener = () => {
     if (!IS_CLIENT || messageListenerAdded) {
        return;
    }
    window.addEventListener('message', handleParentMessage);
    messageListenerAdded = true;
    console.log('[React Scan Iframe] Message listener added.');
};

// --- END: MODIFIED CODE for postMessage Communication ---

// --- Original Option Handling, Initialization, Exports (Unchanged) ---
// ... (keep the rest of the file as it was previously, including start(), scan(), setOptions(), etc.) ...

function isOptionKey(key: string): key is keyof Options {
  // Use a more robust check if default options change
  const defaultKeys = Object.keys(ReactScanInternals.options.value);
  return defaultKeys.includes(key);
}


const validateOptions = (options: Partial<Options>): Partial<Options> => {
  const errors: Array<string> = [];
  const validOptions: Partial<Options> = {};

  for (const key in options) {
    if (!isOptionKey(key)) {
        if(ReactScanInternals.options.value._debug) {
           console.warn(`[React Scan] Unknown option provided during validation: "${key}"`);
        }
        continue; // Skip unknown keys strictly
    }


    const value = options[key];
    switch (key) {
      case 'enabled':
      case 'log':
      case 'showToolbar':
      case 'showNotificationCount':
      case 'dangerouslyForceRunInProduction':
      case 'trackUnnecessaryRenders': // Added this
      case 'showFPS':
        if (typeof value !== 'boolean') {
          errors.push(`- ${key} must be a boolean. Got "${value}"`);
        } else {
          validOptions[key] = value;
        }
        break;
      case 'animationSpeed':
        if (!['slow', 'fast', 'off'].includes(value as string)) {
          errors.push(
            `- Invalid animation speed "${value}". Using default "fast"`,
          );
          // Don't set invalid value
        } else {
          validOptions[key] = value as 'slow' | 'fast' | 'off';
        }
        break;
      case '_debug': // Added this
         if (value !== 'verbose' && value !== false && value !== undefined) {
             errors.push(`- _debug must be 'verbose' or false. Got "${value}"`);
         } else {
             validOptions[key] = value;
         }
         break;
      case 'onCommitStart':
      case 'onCommitFinish':
      case 'onPaintStart':
      case 'onPaintFinish':
      case 'onRender': // Keep validation for potential future use or logging
        if (value !== undefined && typeof value !== 'function') { // Allow undefined
          errors.push(`- ${key} must be a function or undefined. Got "${value}"`);
        } else {
           // Cast to avoid type errors if these are used later
          validOptions[key] = value as any;
        }
        break;
      default:
        // This case should ideally not be reached due to isOptionKey check
         if(ReactScanInternals.options.value._debug) {
           console.warn(`[React Scan] Unknown option slipped through validation: "${key}"`);
        }
    }
  }


  if (errors.length > 0) {
    console.warn(`[React Scan] Invalid options detected:\n${errors.join('\n')}`);
  }

  return validOptions;
};

export const getReport = (type?: ComponentType<unknown>) => {
  if (type) {
    // Check both maps? Or just legacy? Assuming legacy for now.
    for (const reportData of Array.from(Store.legacyReportData.values())) {
      if (reportData.type === type) {
        return reportData;
      }
    }
    // Check the new map by iterating if needed, but needs a way to map type to ID
    // Example (might be slow):
    // for (const [id, reportData] of Store.reportData.entries()) {
    //    // Need a way to get fiber from ID or type from ID
    // }
    return null;
  }
  // Return both maps or a combined representation? Returning legacy for now.
  return Store.legacyReportData;
};

export const setOptions = (userOptions: Partial<Options>) => {
  const validOptions = validateOptions(userOptions);

  if (Object.keys(validOptions).length === 0 && !userOptions.hasOwnProperty('enabled')) { // Check enabled specifically if it's the only key
      // No valid options to set, maybe log in debug mode
       if(ReactScanInternals.options.value._debug === 'verbose') {
          console.log('[React Scan] setOptions called with no valid options or only invalid options.', userOptions);
       }
      return ReactScanInternals.options.value; // Return current options
  }

  const currentOptions = ReactScanInternals.options.value;
  const showToolbarChanged = validOptions.hasOwnProperty('showToolbar') && validOptions.showToolbar !== currentOptions.showToolbar;
  const enabledChanged = validOptions.hasOwnProperty('enabled') && validOptions.enabled !== currentOptions.enabled;


  const newOptions = {
    ...currentOptions,
    ...validOptions,
  };

  const { instrumentation } = ReactScanInternals;
  if (instrumentation && validOptions.hasOwnProperty('enabled')) {
    instrumentation.isPaused.value = validOptions.enabled === false;
  }

  ReactScanInternals.options.value = newOptions;

  // Save options only if they are not the defaults or have changed
  // This prevents unnecessary localStorage writes on initial load if options are default
  // Add a check to see if the new options differ from stored ones before saving?
  // Or just save whenever setOptions is called with valid changes.
  try {
       const storableOptions: Partial<LocalStorageOptions> = {};
       for (const key in newOptions) {
           if (key !== 'onCommitStart' && key !== 'onRender' && key !== 'onCommitFinish' && key !== 'onPaintStart' && key !== 'onPaintFinish') {
            // @ts-expect-error
               storableOptions[key as keyof LocalStorageOptions] = newOptions[key as keyof LocalStorageOptions];
           }
       }
      saveLocalStorage('react-scan-options', storableOptions);
  } catch(e) {
      console.error("[React Scan] Failed to save options to localStorage", e);
  }


  // Re-initialize toolbar *only* if showToolbar explicitly changed
  // or if enabled changed from false to true and showToolbar is true
  if (showToolbarChanged || (enabledChanged && newOptions.enabled === true && newOptions.showToolbar === true)) {
    initToolbar(!!newOptions.showToolbar);
  } else if (enabledChanged && newOptions.enabled === false) {
      // If disabled, ensure toolbar is removed/cleaned up
      initToolbar(false);
  }


  return newOptions;
};

export const getOptions = () => ReactScanInternals.options;

let isProduction: boolean | null = null;
let rdtHook: ReturnType<typeof getRDTHook>;
export const getIsProduction = () => {
  if (isProduction !== null) {
    return isProduction;
  }
   if (!IS_CLIENT) return false; // Cannot determine on server

  try {
      rdtHook ??= getRDTHook();
      if (!rdtHook || !rdtHook.renderers) {
           console.warn("[React Scan] React DevTools hook not found or has no renderers. Assuming development build.");
           isProduction = false;
           return isProduction;
      }
      isProduction = false; // Default to false
      for (const renderer of rdtHook.renderers.values()) {
        const buildType = detectReactBuildType(renderer);
        if (buildType === 'production') {
          isProduction = true;
          break; // Found a production build, no need to check further
        }
      }
  } catch(e) {
      console.error("[React Scan] Error detecting React build type:", e);
      isProduction = false; // Assume dev on error
  }
  return isProduction;
};


export const start = () => {
  try {
    if (!IS_CLIENT) {
      return;
    }

    // Add the listener regardless of production status or other options
    addMessageListener();


    // Send load success message *after* listener is added, if in an iframe
    if (Store.isInIframe.value) {
        const PARENT_ORIGIN = '*'; // WARNING: Use specific origin in production!
        window.parent.postMessage({
            type: 'IFRAME_LOAD_SUCCESS',
            payload: {} // No specific payload needed for now
        }, PARENT_ORIGIN);
        console.log('[React Scan Iframe] Sent IFRAME_LOAD_SUCCESS to parent.');
    }

    const isProd = getIsProduction(); // Determine production status

    if (
      isProd &&
      !ReactScanInternals.options.value.dangerouslyForceRunInProduction
    ) {
      console.log('[React Scan] Production environment detected. React Scan disabled unless dangerouslyForceRunInProduction is set.');
      // Return here *after* adding the listener if we don't force run in prod
      return;
    }

    // Load stored options *after* the production check
    const localStorageOptions =
      readLocalStorage<LocalStorageOptions>('react-scan-options');

    let initialOptions = { ...ReactScanInternals.options.value };
    if (localStorageOptions) {
      const validLocalOptions = validateOptions(localStorageOptions);
      initialOptions = { ...initialOptions, ...validLocalOptions };
    }
    // Update the signal *once* after merging defaults and stored options
    ReactScanInternals.options.value = initialOptions;

    const options = initialOptions; // Use the merged options

    // Initialize React instrumentation if enabled
    if (options.enabled !== false) {
      initReactScanInstrumentation(() => {
        // Callback for when instrumentation is active
        initToolbar(!!options.showToolbar);
      });
    } else if (options.showToolbar === true) {
        // If scanning is disabled but toolbar is shown, init toolbar without instrumentation callback
        initToolbar(true);
    }

    // Original check for instrumentation activation delay - keep this
    if (!Store.monitor.value && IS_CLIENT) {
      setTimeout(() => {
        if (isInstrumentationActive()) return;
        console.error(
          '[React Scan] Failed to load React instrumentation. This can happen if React runs before React Scan is imported, or if React DevTools are disabled or interfering. Ensure React Scan is imported early.'
        );
      }, 5000);
    }
  } catch (e) {
    console.error('[React Scan] Error during start():', e);
  }
};


const initToolbar = (showToolbar: boolean) => {
  try {
      window.reactScanCleanupListeners?.(); // Cleanup previous listeners if any

      const windowToolbarContainer = document.getElementById('react-scan-toolbar-root');
      if (windowToolbarContainer) {
          windowToolbarContainer.remove();
          // Clear the reference in case it was cached elsewhere, though direct ID access is safer
          // window.__REACT_SCAN_TOOLBAR_CONTAINER__ = undefined;
      }


      if (!showToolbar) {
         window.reactScanCleanupListeners = undefined; // Ensure no listeners if toolbar hidden
         return; // Don't create toolbar if not needed
      }


      // Create toolbar only if shown
      const { shadowRoot } = initRootContainer(); // Ensure root container exists
      createToolbar(shadowRoot); // Render toolbar into shadow DOM

      // Start necessary listeners only when toolbar is shown
      const cleanupTimingTracking = startTimingTracking();
      const cleanupOutlineCanvas = createNotificationsOutlineCanvas();

      window.reactScanCleanupListeners = () => {
        cleanupTimingTracking();
        cleanupOutlineCanvas?.();
        // Optionally remove the toolbar container on cleanup?
        // document.getElementById('react-scan-toolbar-root')?.remove();
      };

  } catch (e) {
       console.error("[React Scan] Error initializing toolbar:", e);
       window.reactScanCleanupListeners = undefined; // Clear listeners on error
  }
};


const createNotificationsOutlineCanvas = () => {
  try {
    // Ensure it runs in the client context
    if (!IS_CLIENT) return undefined;
    const highlightRoot = document.documentElement;
    // Cleanup existing canvas before creating a new one
    const existingCanvas = highlightRoot.querySelector('canvas[style*="z-index: 2147483600"]');
    existingCanvas?.remove();

    return createHighlightCanvas(highlightRoot);
  } catch (e) {
    console.error('[React Scan] Failed to create notifications outline canvas:', e);
    return undefined; // Return undefined if creation fails
  }
};


export const scan = (options: Options = {}) => {
  setOptions(options); // Update and save options
  addMessageListener(); // Ensure listener is always added (idempotent)

  // Start instrumentation/UI based on the *updated* options
  const currentOptions = ReactScanInternals.options.value;
  if (currentOptions.enabled !== false || currentOptions.showToolbar === true) {
     start();
  } else {
      // If options explicitly disable and hide toolbar, ensure cleanup
      initToolbar(false);
      // Consider stopping instrumentation if it was running?
      // ReactScanInternals.instrumentation?.isPaused.value = true;
  }
};


export const useScan = (options: Options = {}) => {
  // This hook implies usage within a React component, likely client-side
  if (!IS_CLIENT) return; // Basic guard

  // Use effect to apply options only once on mount/options change?
  // Or just call scan directly? Calling directly might be simpler.
  scan(options); // Apply options and start/stop as needed

  // Hooks usually don't return anything for side effects like this.
  // Could return status or methods if needed later.
};


export const onRender = (
  type: unknown,
  _onRender: (fiber: Fiber, renders: Array<Render>) => void,
) => {
  // Ensure type is valid for comparison (function or class component type)
   if (!type || (typeof type !== 'function' && typeof type !== 'object')) {
      console.warn("[React Scan] Invalid type provided to onRender. Expected component type.", type);
      return;
   }


  const prevOnRender = ReactScanInternals.onRender;
  ReactScanInternals.onRender = (fiber: Fiber, renders: Array<Render>) => {
    // Call previous listener first if it exists
    prevOnRender?.(fiber, renders);
    // Use bippy's getType for consistent comparison, comparing against the provided type
    if (getType(fiber.type) === type) {
      try {
          _onRender(fiber, renders);
      } catch (e) {
          console.error("[React Scan] Error in onRender callback for type:", type, e);
      }
    }
  };
};


export const ignoredProps = new WeakSet<
  Exclude<ReactNode, undefined | null | string | number | boolean | bigint>
>();

export const ignoreScan = (node: ReactNode) => {
  // Ensure node is an object (like a React element) before adding
  if (node && typeof node === 'object') {
    ignoredProps.add(node);
  }
};


// Ensure addMessageListener is called when the module loads in a client environment
if (IS_CLIENT) {
    addMessageListener();
    // Optionally trigger start() based on some initial condition or stored options?
    // Example: Start if previously enabled and not in production (unless forced)
    // const storedOpts = readLocalStorage<LocalStorageOptions>('react-scan-options');
    // if (storedOpts?.enabled !== false && (!getIsProduction() || storedOpts?.dangerouslyForceRunInProduction)) {
    //    start();
    // }
    // Or simply rely on explicit `scan()` call by the user.
}
</file>

<file path="packages/scan/src/new-outlines/index.ts">
import {
  type Fiber,
  didFiberCommit,
  getDisplayName,
  getFiberId,
  getNearestHostFibers,
  getTimings,
  getType,
  isCompositeFiber,
} from 'bippy';
import {
  Change,
  ContextChange,
  PropsChange,
  ReactScanInternals,
  Store,
  ignoredProps,
} from '~core/index';
import {
  ChangeReason,
  createInstrumentation,
  getContextChanges,
  getStateChanges,
  OldRenderData,
} from '~core/instrumentation';
import { log, logIntro } from '~web/utils/log';
import { inspectorUpdateSignal } from '~web/views/inspector/states';
import {
  OUTLINE_ARRAY_SIZE,
  drawCanvas,
  initCanvas,
  updateOutlines,
  updateScroll,
} from './canvas';
import type { ActiveOutline, BlueprintOutline, OutlineData } from './types';
import { getChangedPropsDetailed } from '~web/views/inspector/utils';

// The worker code will be replaced at build time
const workerCode = '__WORKER_CODE__';

let worker: Worker | null = null;
let canvas: HTMLCanvasElement | null = null;
let ctx: CanvasRenderingContext2D | null = null;
let dpr = 1;
let animationFrameId: number | null = null;
const activeOutlines = new Map<string, ActiveOutline>();

const blueprintMap = new Map<Fiber, BlueprintOutline>();
const blueprintMapKeys = new Set<Fiber>();

export const outlineFiber = (fiber: Fiber) => {
  if (!isCompositeFiber(fiber)) return;
  const name =
    typeof fiber.type === 'string' ? fiber.type : getDisplayName(fiber);
  if (!name) return;
  const blueprint = blueprintMap.get(fiber);
  const nearestFibers = getNearestHostFibers(fiber);
  const didCommit = didFiberCommit(fiber);

  if (!blueprint) {
    blueprintMap.set(fiber, {
      name,
      count: 1,
      elements: nearestFibers.map((fiber) => fiber.stateNode),
      didCommit: didCommit ? 1 : 0,
    });
    blueprintMapKeys.add(fiber);
  } else {
    blueprint.count++;
  }
};

const mergeRects = (rects: DOMRect[]) => {
  const firstRect = rects[0];
  if (rects.length === 1) return firstRect;

  let minX: number | undefined;
  let minY: number | undefined;
  let maxX: number | undefined;
  let maxY: number | undefined;

  for (let i = 0, len = rects.length; i < len; i++) {
    const rect = rects[i];
    minX = minX == null ? rect.x : Math.min(minX, rect.x);
    minY = minY == null ? rect.y : Math.min(minY, rect.y);
    maxX =
      maxX == null ? rect.x + rect.width : Math.max(maxX, rect.x + rect.width);
    maxY =
      maxY == null
        ? rect.y + rect.height
        : Math.max(maxY, rect.y + rect.height);
  }

  if (minX == null || minY == null || maxX == null || maxY == null) {
    return rects[0];
  }

  return new DOMRect(minX, minY, maxX - minX, maxY - minY);
};

interface IntersectionState {
  resolveNext: ((value: IntersectionObserverEntry[]) => void) | null;
  seenElements: Set<Element>;
  uniqueElements: Set<Element>;
  done: boolean;
}

function onIntersect(
  this: IntersectionState,
  entries: IntersectionObserverEntry[],
  observer: IntersectionObserver,
) {
  const newEntries: IntersectionObserverEntry[] = [];

  for (const entry of entries) {
    const element = entry.target;
    if (!this.seenElements.has(element)) {
      this.seenElements.add(element);
      newEntries.push(entry);
    }
  }

  if (newEntries.length > 0 && this.resolveNext) {
    this.resolveNext(newEntries);
    this.resolveNext = null;
  }

  if (this.seenElements.size === this.uniqueElements.size) {
    observer.disconnect();
    this.done = true;
    if (this.resolveNext) {
      this.resolveNext([]);
    }
  }
}

export const getBatchedRectMap = async function* (
  elements: Element[],
): AsyncGenerator<IntersectionObserverEntry[], void, unknown> {
  const state: IntersectionState = {
    uniqueElements: new Set(elements),
    seenElements: new Set(),
    resolveNext: null,
    done: false,
  };
  const observer = new IntersectionObserver(onIntersect.bind(state));

  for (const element of state.uniqueElements) {
    observer.observe(element);
  }

  while (!state.done) {
    const entries = await new Promise<IntersectionObserverEntry[]>(
      (resolve) => {
        state.resolveNext = resolve;
      },
    );
    if (entries.length > 0) {
      yield entries;
    }
  }
};

const SupportedArrayBuffer =
  typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : ArrayBuffer;

export const flushOutlines = async () => {
  const elements: Element[] = [];

  for (const fiber of blueprintMapKeys) {
    const blueprint = blueprintMap.get(fiber);
    if (!blueprint) continue;
    for (let i = 0; i < blueprint.elements.length; i++) {
      if (!(blueprint.elements[i] instanceof Element)) {
        // TODO: filter this at the root
        continue;
      }
      elements.push(blueprint.elements[i]);
    }
  }

  const rectsMap = new Map<Element, DOMRect>();

  // TODO(Alexis): too complex, needs breakdown
  for await (const entries of getBatchedRectMap(elements)) {
    for (const entry of entries) {
      const element = entry.target;
      const rect = entry.intersectionRect;
      if (entry.isIntersecting && rect.width && rect.height) {
        rectsMap.set(element, rect);
      }
    }

    const blueprints: BlueprintOutline[] = [];
    const blueprintRects: DOMRect[] = [];
    const blueprintIds: number[] = [];

    for (const fiber of blueprintMapKeys) {
      const blueprint = blueprintMap.get(fiber);
      if (!blueprint) continue;

      const rects: DOMRect[] = [];
      for (let i = 0; i < blueprint.elements.length; i++) {
        const element = blueprint.elements[i];
        const rect = rectsMap.get(element);
        if (!rect) continue;
        rects.push(rect);
      }

      if (!rects.length) continue;

      blueprints.push(blueprint);
      blueprintRects.push(mergeRects(rects));
      blueprintIds.push(getFiberId(fiber));
    }

    if (blueprints.length > 0) {
      const arrayBuffer = new SupportedArrayBuffer(
        blueprints.length * OUTLINE_ARRAY_SIZE * 4,
      );
      const sharedView = new Float32Array(arrayBuffer);
      const blueprintNames = new Array(blueprints.length);
      let outlineData: OutlineData[] | undefined;

      for (let i = 0, len = blueprints.length; i < len; i++) {
        const blueprint = blueprints[i];
        const id = blueprintIds[i];
        const { x, y, width, height } = blueprintRects[i];
        const { count, name, didCommit } = blueprint;

        if (worker) {
          const scaledIndex = i * OUTLINE_ARRAY_SIZE;
          sharedView[scaledIndex] = id;
          sharedView[scaledIndex + 1] = count;
          sharedView[scaledIndex + 2] = x;
          sharedView[scaledIndex + 3] = y;
          sharedView[scaledIndex + 4] = width;
          sharedView[scaledIndex + 5] = height;
          sharedView[scaledIndex + 6] = didCommit;
          blueprintNames[i] = name;
        } else {
          outlineData ||= new Array(blueprints.length);
          outlineData[i] = {
            id,
            name,
            count,
            x,
            y,
            width,
            height,
            didCommit: didCommit as 0 | 1,
          };
        }
      }

      if (worker) {
        worker.postMessage({
          type: 'draw-outlines',
          data: arrayBuffer,
          names: blueprintNames,
        });
      } else if (canvas && ctx && outlineData) {
        updateOutlines(activeOutlines, outlineData);
        if (!animationFrameId) {
          animationFrameId = requestAnimationFrame(draw);
        }
      }
    }
  }

  for (const fiber of blueprintMapKeys) {
    blueprintMap.delete(fiber);
    blueprintMapKeys.delete(fiber);
  }
};

const draw = () => {
  if (!ctx || !canvas) return;

  const shouldContinue = drawCanvas(ctx, canvas, dpr, activeOutlines);

  if (shouldContinue) {
    animationFrameId = requestAnimationFrame(draw);
  } else {
    animationFrameId = null;
  }
};

const IS_OFFSCREEN_CANVAS_WORKER_SUPPORTED =
  typeof OffscreenCanvas !== 'undefined' && typeof Worker !== 'undefined';

const getDpr = () => {
  return Math.min(window.devicePixelRatio || 1, 2);
};

export const getCanvasEl = () => {
  cleanup();
  const host = document.createElement('div');
  host.setAttribute('data-react-scan', 'true');
  const shadowRoot = host.attachShadow({ mode: 'open' });

  const canvasEl = document.createElement('canvas');
  canvasEl.style.position = 'fixed';
  canvasEl.style.top = '0';
  canvasEl.style.left = '0';
  canvasEl.style.pointerEvents = 'none';
  canvasEl.style.zIndex = '2147483646';
  canvasEl.setAttribute('aria-hidden', 'true');

  // *** ADD DATA ATTRIBUTE ***
  canvasEl.setAttribute('data-react-scan-canvas', 'true');
  // *** END ADD ***
  shadowRoot.appendChild(canvasEl);

  if (!canvasEl) return null;

  dpr = getDpr();
  canvas = canvasEl;

  const { innerWidth, innerHeight } = window;
  canvasEl.style.width = `${innerWidth}px`;
  canvasEl.style.height = `${innerHeight}px`;
  const width = innerWidth * dpr;
  const height = innerHeight * dpr;
  canvasEl.width = width;
  canvasEl.height = height;

  if (
    IS_OFFSCREEN_CANVAS_WORKER_SUPPORTED &&
    !window.__REACT_SCAN_EXTENSION__
  ) {
    try {
      worker = new Worker(
        URL.createObjectURL(
          new Blob([workerCode], { type: 'application/javascript' }),
        ),
      );

      const offscreenCanvas = canvasEl.transferControlToOffscreen();
      worker?.postMessage(
        {
          type: 'init',
          canvas: offscreenCanvas,
          width: canvasEl.width,
          height: canvasEl.height,
          dpr,
        },
        [offscreenCanvas],
      );
    } catch (e) {
      // biome-ignore lint/suspicious/noConsole: Intended debug output
      console.warn('Failed to initialize OffscreenCanvas worker:', e);
    }
  }

  if (!worker) {
    ctx = initCanvas(canvasEl, dpr) as CanvasRenderingContext2D;
  }

  let isResizeScheduled = false;
  window.addEventListener('resize', () => {
    if (!isResizeScheduled) {
      isResizeScheduled = true;
      // TODO(Alexis): bindable
      setTimeout(() => {
        const width = window.innerWidth;
        const height = window.innerHeight;
        dpr = getDpr();
        canvasEl.style.width = `${width}px`;
        canvasEl.style.height = `${height}px`;
        if (worker) {
          worker.postMessage({
            type: 'resize',
            width,
            height,
            dpr,
          });
        } else {
          canvasEl.width = width * dpr;
          canvasEl.height = height * dpr;
          if (ctx) {
            ctx.resetTransform();
            ctx.scale(dpr, dpr);
          }
          draw();
        }
        isResizeScheduled = false;
      });
    }
  });

  let prevScrollX = window.scrollX;
  let prevScrollY = window.scrollY;
  let isScrollScheduled = false;

  window.addEventListener('scroll', () => {
    if (!isScrollScheduled) {
      isScrollScheduled = true;
      // TODO(Alexis): bindable
      setTimeout(() => {
        const { scrollX, scrollY } = window;
        const deltaX = scrollX - prevScrollX;
        const deltaY = scrollY - prevScrollY;
        prevScrollX = scrollX;
        prevScrollY = scrollY;
        if (worker) {
          worker.postMessage({
            type: 'scroll',
            deltaX,
            deltaY,
          });
        } else {
          requestAnimationFrame(
            updateScroll.bind(null, activeOutlines, deltaX, deltaY),
          );
        }
        isScrollScheduled = false;
      }, 16 * 2);
    }
  });

  setInterval(() => {
    if (blueprintMapKeys.size) {
      requestAnimationFrame(flushOutlines);
    }
  }, 16 * 2);

  shadowRoot.appendChild(canvasEl);
  return host;
};

export const hasStopped = () => {
  return globalThis.__REACT_SCAN_STOP__;
};

export const stop = () => {
  globalThis.__REACT_SCAN_STOP__ = true;
  cleanup();
};

export const cleanup = () => {
  const host = document.querySelector('[data-react-scan]');
  if (host) {
    host.remove();
  }
};

const reportRenderToListeners = (fiber: Fiber) => {
  if (isCompositeFiber(fiber)) {
    // report render has a non trivial cost because it calls Date.now(), so we want to avoid the computation if possible
    if (
      ReactScanInternals.options.value.showToolbar !== false &&
      Store.inspectState.value.kind === 'focused'
    ) {
      const reportFiber = fiber;
      const { selfTime } = getTimings(fiber);
      const displayName = getDisplayName(fiber.type);
      const fiberId = getFiberId(reportFiber);

      const currentData = Store.reportData.get(fiberId);
      const existingCount = currentData?.count ?? 0;
      const existingTime = currentData?.time ?? 0;

      const changes: Array<Change> = [];

      // optimization, for now only track changes on inspected prop, cleanup later when changes is used in outline drawing
      const listeners = Store.changesListeners.get(getFiberId(fiber));

      if (listeners?.length) {
        const propsChanges: Array<PropsChange> = getChangedPropsDetailed(
          fiber,
        ).map((change) => ({
          type: ChangeReason.Props,
          name: change.name,
          value: change.value,
          prevValue: change.prevValue,
          unstable: false,
        }));

        const stateChanges = getStateChanges(fiber);

        // context changes are incorrect, bippy needs to tell us the context dependencies that changed and provide those values every render
        // currently, we say every context change, regardless of the render it happened, is a change. Which requires us to hack change tracking
        // in the whats-changed toolbar component
        const fiberContext = getContextChanges(fiber);
        const contextChanges: Array<ContextChange> = fiberContext.map(
          (info) => ({
            name: info.name,
            type: ChangeReason.Context,
            value: info.value,
            contextType: info.contextType,
          }),
        );

        listeners.forEach((listener) => {
          listener({
            propsChanges,
            stateChanges,
            contextChanges,
          });
        });
      }
      const fiberData: OldRenderData = {
        count: existingCount + 1,
        time: existingTime + selfTime || 0,
        renders: [],
        displayName,
        type: getType(fiber.type) || null,
        changes,
      };

      Store.reportData.set(fiberId, fiberData);
      needsReport = true;
    }
  }
};

let needsReport = false;
let reportInterval: ReturnType<typeof setInterval>;
export const startReportInterval = () => {
  clearInterval(reportInterval);
  reportInterval = setInterval(() => {
    if (needsReport) {
      Store.lastReportTime.value = Date.now();
      needsReport = false;
    }
  }, 50);
};

export const isValidFiber = (fiber: Fiber) => {
  if (ignoredProps.has(fiber.memoizedProps)) {
    return false;
  }

  return true;
};
export const initReactScanInstrumentation = (setupToolbar: () => void) => {
  if (hasStopped()) return;
  // todo: don't hardcode string getting weird ref error in iife when using process.env
  let schedule: ReturnType<typeof requestAnimationFrame>;
  let mounted = false;

  const scheduleSetup = () => {
    if (mounted) {
      return;
    }
    if (schedule) {
      cancelAnimationFrame(schedule);
    }
    schedule = requestAnimationFrame(() => {
      mounted = true;
      const host = getCanvasEl();
      if (host) {
        document.documentElement.appendChild(host);
      }
      setupToolbar();
    }); // TODO(Alexis): perhaps a better timing
  };

  const instrumentation = createInstrumentation('react-scan-devtools-0.1.0', {
    onCommitStart: () => {
      ReactScanInternals.options.value.onCommitStart?.();
    },
    onActive: () => {
      if (hasStopped()) return;

      scheduleSetup();
      if (!window.__REACT_SCAN_EXTENSION__) {
        globalThis.__REACT_SCAN__ = {
          ReactScanInternals,
        };
      }
      startReportInterval();
      logIntro();
    },
    onError: () => {
      // todo: ingest errors without accidentally collecting data about user
    },
    isValidFiber,
    onRender: (fiber, renders) => {
      if (isCompositeFiber(fiber)) {
        Store.interactionListeningForRenders?.(fiber, renders);
      }
      const isOverlayPaused =
        ReactScanInternals.instrumentation?.isPaused.value;
      const isInspectorInactive =
        Store.inspectState.value.kind === 'inspect-off' ||
        Store.inspectState.value.kind === 'uninitialized';
      const shouldFullyAbort = isOverlayPaused && isInspectorInactive;

      if (shouldFullyAbort) {
        return;
      }
      if (!isOverlayPaused) {
        outlineFiber(fiber);
      }
      if (ReactScanInternals.options.value.log) {
        // this can be expensive given enough re-renders
        log(renders);
      }

      if (Store.inspectState.value.kind === 'focused') {
        inspectorUpdateSignal.value = Date.now();
      }
      if (!isInspectorInactive) {
        reportRenderToListeners(fiber);
      }

      ReactScanInternals.options.value.onRender?.(fiber, renders);
    },
    onCommitFinish: () => {
      scheduleSetup();
      ReactScanInternals.options.value.onCommitFinish?.();
    },
    onPostCommitFiberRoot() {
      scheduleSetup();
    },
    trackChanges: false,
  });
  ReactScanInternals.instrumentation = instrumentation;
};
</file>

</files>
